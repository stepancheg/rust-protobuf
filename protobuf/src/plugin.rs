// This file is generated by rust-protobuf 3.5.0-pre. Do not edit
// .proto file is parsed by protoc --rust_out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/protobuf/compiler/plugin.proto`

///  The version number of protocol compiler.
// @@protoc_insertion_point(message:google.protobuf.compiler.Version)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Version {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.compiler.Version.major)
    pub major: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:google.protobuf.compiler.Version.minor)
    pub minor: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:google.protobuf.compiler.Version.patch)
    pub patch: ::std::option::Option<i32>,
    ///  A suffix for alpha, beta or rc release, e.g., "alpha-1", "rc2". It should
    ///  be empty for mainline stable releases.
    // @@protoc_insertion_point(field:google.protobuf.compiler.Version.suffix)
    pub suffix: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.compiler.Version.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Version {
    fn default() -> &'a Version {
        <Version as crate::Message>::default_instance()
    }
}

impl Version {
    pub fn new() -> Version {
        ::std::default::Default::default()
    }

    // optional int32 major = 1;

    pub fn major(&self) -> i32 {
        self.major.unwrap_or(0)
    }

    pub fn clear_major(&mut self) {
        self.major = ::std::option::Option::None;
    }

    pub fn has_major(&self) -> bool {
        self.major.is_some()
    }

    // Param is passed by value, moved
    pub fn set_major(&mut self, v: i32) {
        self.major = ::std::option::Option::Some(v);
    }

    // optional int32 minor = 2;

    pub fn minor(&self) -> i32 {
        self.minor.unwrap_or(0)
    }

    pub fn clear_minor(&mut self) {
        self.minor = ::std::option::Option::None;
    }

    pub fn has_minor(&self) -> bool {
        self.minor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minor(&mut self, v: i32) {
        self.minor = ::std::option::Option::Some(v);
    }

    // optional int32 patch = 3;

    pub fn patch(&self) -> i32 {
        self.patch.unwrap_or(0)
    }

    pub fn clear_patch(&mut self) {
        self.patch = ::std::option::Option::None;
    }

    pub fn has_patch(&self) -> bool {
        self.patch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_patch(&mut self, v: i32) {
        self.patch = ::std::option::Option::Some(v);
    }

    // optional string suffix = 4;

    pub fn suffix(&self) -> &str {
        match self.suffix.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_suffix(&mut self) {
        self.suffix = ::std::option::Option::None;
    }

    pub fn has_suffix(&self) -> bool {
        self.suffix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suffix(&mut self, v: ::std::string::String) {
        self.suffix = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_suffix(&mut self) -> &mut ::std::string::String {
        if self.suffix.is_none() {
            self.suffix = ::std::option::Option::Some(::std::string::String::new());
        }
        self.suffix.as_mut().unwrap()
    }

    // Take field
    pub fn take_suffix(&mut self) -> ::std::string::String {
        self.suffix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "major",
            |m: &Version| { &m.major },
            |m: &mut Version| { &mut m.major },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "minor",
            |m: &Version| { &m.minor },
            |m: &mut Version| { &mut m.minor },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "patch",
            |m: &Version| { &m.patch },
            |m: &mut Version| { &mut m.patch },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "suffix",
            |m: &Version| { &m.suffix },
            |m: &mut Version| { &mut m.suffix },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<Version>(
            "Version",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for Version {
    const NAME: &'static str = "Version";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.major = ::std::option::Option::Some(is.read_int32()?);
                },
                16 => {
                    self.minor = ::std::option::Option::Some(is.read_int32()?);
                },
                24 => {
                    self.patch = ::std::option::Option::Some(is.read_int32()?);
                },
                34 => {
                    self.suffix = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.major {
            my_size += crate::rt::int32_size(1, v);
        }
        if let Some(v) = self.minor {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.patch {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.suffix.as_ref() {
            my_size += crate::rt::string_size(4, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.major {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.minor {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.patch {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.suffix.as_ref() {
            os.write_string(4, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Version {
        Version::new()
    }

    fn clear(&mut self) {
        self.major = ::std::option::Option::None;
        self.minor = ::std::option::Option::None;
        self.patch = ::std::option::Option::None;
        self.suffix = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Version {
        static instance: Version = Version {
            major: ::std::option::Option::None,
            minor: ::std::option::Option::None,
            patch: ::std::option::Option::None,
            suffix: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for Version {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Version").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Version {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for Version {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  An encoded CodeGeneratorRequest is written to the plugin's stdin.
// @@protoc_insertion_point(message:google.protobuf.compiler.CodeGeneratorRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CodeGeneratorRequest {
    // message fields
    ///  The .proto files that were explicitly listed on the command-line.  The
    ///  code generator should generate code only for these files.  Each file's
    ///  descriptor will be included in proto_file, below.
    // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorRequest.file_to_generate)
    pub file_to_generate: ::std::vec::Vec<::std::string::String>,
    ///  The generator parameter passed on the command-line.
    // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorRequest.parameter)
    pub parameter: ::std::option::Option<::std::string::String>,
    ///  FileDescriptorProtos for all files in files_to_generate and everything
    ///  they import.  The files will appear in topological order, so each file
    ///  appears before any file that imports it.
    ///
    ///  protoc guarantees that all proto_files will be written after
    ///  the fields above, even though this is not technically guaranteed by the
    ///  protobuf wire format.  This theoretically could allow a plugin to stream
    ///  in the FileDescriptorProtos and handle them one by one rather than read
    ///  the entire set into memory at once.  However, as of this writing, this
    ///  is not similarly optimized on protoc's end -- it will store all fields in
    ///  memory at once before sending them to the plugin.
    ///
    ///  Type names of fields and extensions in the FileDescriptorProto are always
    ///  fully qualified.
    // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorRequest.proto_file)
    pub proto_file: ::std::vec::Vec<crate::descriptor::FileDescriptorProto>,
    ///  The version number of protocol compiler.
    // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorRequest.compiler_version)
    pub compiler_version: crate::MessageField<Version>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.compiler.CodeGeneratorRequest.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CodeGeneratorRequest {
    fn default() -> &'a CodeGeneratorRequest {
        <CodeGeneratorRequest as crate::Message>::default_instance()
    }
}

impl CodeGeneratorRequest {
    pub fn new() -> CodeGeneratorRequest {
        ::std::default::Default::default()
    }

    // optional string parameter = 2;

    pub fn parameter(&self) -> &str {
        match self.parameter.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_parameter(&mut self) {
        self.parameter = ::std::option::Option::None;
    }

    pub fn has_parameter(&self) -> bool {
        self.parameter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameter(&mut self, v: ::std::string::String) {
        self.parameter = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameter(&mut self) -> &mut ::std::string::String {
        if self.parameter.is_none() {
            self.parameter = ::std::option::Option::Some(::std::string::String::new());
        }
        self.parameter.as_mut().unwrap()
    }

    // Take field
    pub fn take_parameter(&mut self) -> ::std::string::String {
        self.parameter.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "file_to_generate",
            |m: &CodeGeneratorRequest| { &m.file_to_generate },
            |m: &mut CodeGeneratorRequest| { &mut m.file_to_generate },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "parameter",
            |m: &CodeGeneratorRequest| { &m.parameter },
            |m: &mut CodeGeneratorRequest| { &mut m.parameter },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "proto_file",
            |m: &CodeGeneratorRequest| { &m.proto_file },
            |m: &mut CodeGeneratorRequest| { &mut m.proto_file },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, Version>(
            "compiler_version",
            |m: &CodeGeneratorRequest| { &m.compiler_version },
            |m: &mut CodeGeneratorRequest| { &mut m.compiler_version },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CodeGeneratorRequest>(
            "CodeGeneratorRequest",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CodeGeneratorRequest {
    const NAME: &'static str = "CodeGeneratorRequest";

    fn is_initialized(&self) -> bool {
        for v in &self.proto_file {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.compiler_version {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file_to_generate.push(is.read_string()?);
                },
                18 => {
                    self.parameter = ::std::option::Option::Some(is.read_string()?);
                },
                122 => {
                    self.proto_file.push(is.read_message()?);
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.compiler_version)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.file_to_generate {
            my_size += crate::rt::string_size(1, &value);
        };
        if let Some(v) = self.parameter.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        for value in &self.proto_file {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.compiler_version.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.file_to_generate {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.parameter.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.proto_file {
            crate::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        if let Some(v) = self.compiler_version.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CodeGeneratorRequest {
        CodeGeneratorRequest::new()
    }

    fn clear(&mut self) {
        self.file_to_generate.clear();
        self.parameter = ::std::option::Option::None;
        self.proto_file.clear();
        self.compiler_version.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CodeGeneratorRequest {
        static instance: CodeGeneratorRequest = CodeGeneratorRequest {
            file_to_generate: ::std::vec::Vec::new(),
            parameter: ::std::option::Option::None,
            proto_file: ::std::vec::Vec::new(),
            compiler_version: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CodeGeneratorRequest {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CodeGeneratorRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CodeGeneratorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CodeGeneratorRequest {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  The plugin writes an encoded CodeGeneratorResponse to stdout.
// @@protoc_insertion_point(message:google.protobuf.compiler.CodeGeneratorResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CodeGeneratorResponse {
    // message fields
    ///  Error message.  If non-empty, code generation failed.  The plugin process
    ///  should exit with status code zero even if it reports an error in this way.
    ///
    ///  This should be used to indicate errors in .proto files which prevent the
    ///  code generator from generating correct code.  Errors which indicate a
    ///  problem in protoc itself -- such as the input CodeGeneratorRequest being
    ///  unparseable -- should be reported by writing a message to stderr and
    ///  exiting with a non-zero status code.
    // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorResponse.error)
    pub error: ::std::option::Option<::std::string::String>,
    ///  A bitmask of supported features that the code generator supports.
    ///  This is a bitwise "or" of values from the Feature enum.
    // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorResponse.supported_features)
    pub supported_features: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorResponse.file)
    pub file: ::std::vec::Vec<code_generator_response::File>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.compiler.CodeGeneratorResponse.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CodeGeneratorResponse {
    fn default() -> &'a CodeGeneratorResponse {
        <CodeGeneratorResponse as crate::Message>::default_instance()
    }
}

impl CodeGeneratorResponse {
    pub fn new() -> CodeGeneratorResponse {
        ::std::default::Default::default()
    }

    // optional string error = 1;

    pub fn error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_error(&mut self) {
        self.error = ::std::option::Option::None;
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error = ::std::option::Option::Some(::std::string::String::new());
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 supported_features = 2;

    pub fn supported_features(&self) -> u64 {
        self.supported_features.unwrap_or(0)
    }

    pub fn clear_supported_features(&mut self) {
        self.supported_features = ::std::option::Option::None;
    }

    pub fn has_supported_features(&self) -> bool {
        self.supported_features.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supported_features(&mut self, v: u64) {
        self.supported_features = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "error",
            |m: &CodeGeneratorResponse| { &m.error },
            |m: &mut CodeGeneratorResponse| { &mut m.error },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "supported_features",
            |m: &CodeGeneratorResponse| { &m.supported_features },
            |m: &mut CodeGeneratorResponse| { &mut m.supported_features },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "file",
            |m: &CodeGeneratorResponse| { &m.file },
            |m: &mut CodeGeneratorResponse| { &mut m.file },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<CodeGeneratorResponse>(
            "CodeGeneratorResponse",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for CodeGeneratorResponse {
    const NAME: &'static str = "CodeGeneratorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.supported_features = ::std::option::Option::Some(is.read_uint64()?);
                },
                122 => {
                    self.file.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.error.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.supported_features {
            my_size += crate::rt::uint64_size(2, v);
        }
        for value in &self.file {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.error.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.supported_features {
            os.write_uint64(2, v)?;
        }
        for v in &self.file {
            crate::rt::write_message_field_with_cached_size(15, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CodeGeneratorResponse {
        CodeGeneratorResponse::new()
    }

    fn clear(&mut self) {
        self.error = ::std::option::Option::None;
        self.supported_features = ::std::option::Option::None;
        self.file.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CodeGeneratorResponse {
        static instance: CodeGeneratorResponse = CodeGeneratorResponse {
            error: ::std::option::Option::None,
            supported_features: ::std::option::Option::None,
            file: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for CodeGeneratorResponse {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CodeGeneratorResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CodeGeneratorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for CodeGeneratorResponse {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `CodeGeneratorResponse`
pub mod code_generator_response {
    ///  Represents a single generated file.
    // @@protoc_insertion_point(message:google.protobuf.compiler.CodeGeneratorResponse.File)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct File {
        // message fields
        ///  The file name, relative to the output directory.  The name must not
        ///  contain "." or ".." components and must be relative, not be absolute (so,
        ///  the file cannot lie outside the output directory).  "/" must be used as
        ///  the path separator, not "\".
        ///
        ///  If the name is omitted, the content will be appended to the previous
        ///  file.  This allows the generator to break large files into small chunks,
        ///  and allows the generated text to be streamed back to protoc so that large
        ///  files need not reside completely in memory at one time.  Note that as of
        ///  this writing protoc does not optimize for this -- it will read the entire
        ///  CodeGeneratorResponse before writing files to disk.
        // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorResponse.File.name)
        pub name: ::std::option::Option<::std::string::String>,
        ///  If non-empty, indicates that the named file should already exist, and the
        ///  content here is to be inserted into that file at a defined insertion
        ///  point.  This feature allows a code generator to extend the output
        ///  produced by another code generator.  The original generator may provide
        ///  insertion points by placing special annotations in the file that look
        ///  like:
        ///    @@protoc_insertion_point(NAME)
        ///  The annotation can have arbitrary text before and after it on the line,
        ///  which allows it to be placed in a comment.  NAME should be replaced with
        ///  an identifier naming the point -- this is what other generators will use
        ///  as the insertion_point.  Code inserted at this point will be placed
        ///  immediately above the line containing the insertion point (thus multiple
        ///  insertions to the same point will come out in the order they were added).
        ///  The double-@ is intended to make it unlikely that the generated code
        ///  could contain things that look like insertion points by accident.
        ///
        ///  For example, the C++ code generator places the following line in the
        ///  .pb.h files that it generates:
        ///    // @@protoc_insertion_point(namespace_scope)
        ///  This line appears within the scope of the file's package namespace, but
        ///  outside of any particular class.  Another plugin can then specify the
        ///  insertion_point "namespace_scope" to generate additional classes or
        ///  other declarations that should be placed in this scope.
        ///
        ///  Note that if the line containing the insertion point begins with
        ///  whitespace, the same whitespace will be added to every line of the
        ///  inserted text.  This is useful for languages like Python, where
        ///  indentation matters.  In these languages, the insertion point comment
        ///  should be indented the same amount as any inserted code will need to be
        ///  in order to work correctly in that context.
        ///
        ///  The code generator that generates the initial file and the one which
        ///  inserts into it must both run as part of a single invocation of protoc.
        ///  Code generators are executed in the order in which they appear on the
        ///  command line.
        ///
        ///  If |insertion_point| is present, |name| must also be present.
        // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorResponse.File.insertion_point)
        pub insertion_point: ::std::option::Option<::std::string::String>,
        ///  The file contents.
        // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorResponse.File.content)
        pub content: ::std::option::Option<::std::string::String>,
        ///  Information describing the file content being inserted. If an insertion
        ///  point is used, this information will be appropriately offset and inserted
        ///  into the code generation metadata for the generated files.
        // @@protoc_insertion_point(field:google.protobuf.compiler.CodeGeneratorResponse.File.generated_code_info)
        pub generated_code_info: crate::MessageField<crate::descriptor::GeneratedCodeInfo>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.compiler.CodeGeneratorResponse.File.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a File {
        fn default() -> &'a File {
            <File as crate::Message>::default_instance()
        }
    }

    impl File {
        pub fn new() -> File {
            ::std::default::Default::default()
        }

        // optional string name = 1;

        pub fn name(&self) -> &str {
            match self.name.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name(&mut self) {
            self.name = ::std::option::Option::None;
        }

        pub fn has_name(&self) -> bool {
            self.name.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name(&mut self, v: ::std::string::String) {
            self.name = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name(&mut self) -> &mut ::std::string::String {
            if self.name.is_none() {
                self.name = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name.as_mut().unwrap()
        }

        // Take field
        pub fn take_name(&mut self) -> ::std::string::String {
            self.name.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string insertion_point = 2;

        pub fn insertion_point(&self) -> &str {
            match self.insertion_point.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_insertion_point(&mut self) {
            self.insertion_point = ::std::option::Option::None;
        }

        pub fn has_insertion_point(&self) -> bool {
            self.insertion_point.is_some()
        }

        // Param is passed by value, moved
        pub fn set_insertion_point(&mut self, v: ::std::string::String) {
            self.insertion_point = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_insertion_point(&mut self) -> &mut ::std::string::String {
            if self.insertion_point.is_none() {
                self.insertion_point = ::std::option::Option::Some(::std::string::String::new());
            }
            self.insertion_point.as_mut().unwrap()
        }

        // Take field
        pub fn take_insertion_point(&mut self) -> ::std::string::String {
            self.insertion_point.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string content = 15;

        pub fn content(&self) -> &str {
            match self.content.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_content(&mut self) {
            self.content = ::std::option::Option::None;
        }

        pub fn has_content(&self) -> bool {
            self.content.is_some()
        }

        // Param is passed by value, moved
        pub fn set_content(&mut self, v: ::std::string::String) {
            self.content = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_content(&mut self) -> &mut ::std::string::String {
            if self.content.is_none() {
                self.content = ::std::option::Option::Some(::std::string::String::new());
            }
            self.content.as_mut().unwrap()
        }

        // Take field
        pub fn take_content(&mut self) -> ::std::string::String {
            self.content.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "name",
                |m: &File| { &m.name },
                |m: &mut File| { &mut m.name },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "insertion_point",
                |m: &File| { &m.insertion_point },
                |m: &mut File| { &mut m.insertion_point },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "content",
                |m: &File| { &m.content },
                |m: &mut File| { &mut m.content },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, crate::descriptor::GeneratedCodeInfo>(
                "generated_code_info",
                |m: &File| { &m.generated_code_info },
                |m: &mut File| { &mut m.generated_code_info },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<File>(
                "CodeGeneratorResponse.File",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for File {
        const NAME: &'static str = "File";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name = ::std::option::Option::Some(is.read_string()?);
                    },
                    18 => {
                        self.insertion_point = ::std::option::Option::Some(is.read_string()?);
                    },
                    122 => {
                        self.content = ::std::option::Option::Some(is.read_string()?);
                    },
                    130 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.generated_code_info)?;
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.insertion_point.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.content.as_ref() {
                my_size += crate::rt::string_size(15, &v);
            }
            if let Some(v) = self.generated_code_info.as_ref() {
                let len = v.compute_size();
                my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.name.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.insertion_point.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.content.as_ref() {
                os.write_string(15, v)?;
            }
            if let Some(v) = self.generated_code_info.as_ref() {
                crate::rt::write_message_field_with_cached_size(16, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> File {
            File::new()
        }

        fn clear(&mut self) {
            self.name = ::std::option::Option::None;
            self.insertion_point = ::std::option::Option::None;
            self.content = ::std::option::Option::None;
            self.generated_code_info.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static File {
            static instance: File = File {
                name: ::std::option::Option::None,
                insertion_point: ::std::option::Option::None,
                content: ::std::option::Option::None,
                generated_code_info: crate::MessageField::none(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for File {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("CodeGeneratorResponse.File").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for File {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for File {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Sync with code_generator.h.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.compiler.CodeGeneratorResponse.Feature)
    pub enum Feature {
        // @@protoc_insertion_point(enum_value:google.protobuf.compiler.CodeGeneratorResponse.Feature.FEATURE_NONE)
        FEATURE_NONE = 0,
        // @@protoc_insertion_point(enum_value:google.protobuf.compiler.CodeGeneratorResponse.Feature.FEATURE_PROTO3_OPTIONAL)
        FEATURE_PROTO3_OPTIONAL = 1,
    }

    impl crate::Enum for Feature {
        const NAME: &'static str = "Feature";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Feature> {
            match value {
                0 => ::std::option::Option::Some(Feature::FEATURE_NONE),
                1 => ::std::option::Option::Some(Feature::FEATURE_PROTO3_OPTIONAL),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Feature> {
            match str {
                "FEATURE_NONE" => ::std::option::Option::Some(Feature::FEATURE_NONE),
                "FEATURE_PROTO3_OPTIONAL" => ::std::option::Option::Some(Feature::FEATURE_PROTO3_OPTIONAL),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Feature] = &[
            Feature::FEATURE_NONE,
            Feature::FEATURE_PROTO3_OPTIONAL,
        ];
    }

    impl crate::EnumFull for Feature {
        fn enum_descriptor() -> crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("CodeGeneratorResponse.Feature").unwrap()).clone()
        }

        fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for Feature {
        fn default() -> Self {
            Feature::FEATURE_NONE
        }
    }

    impl Feature {
        pub(in super) fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
            crate::reflect::GeneratedEnumDescriptorData::new::<Feature>("CodeGeneratorResponse.Feature")
        }
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n%google/protobuf/compiler/plugin.proto\x12\x18google.protobuf.compiler\
    \x1a\x20google/protobuf/descriptor.proto\"c\n\x07Version\x12\x14\n\x05ma\
    jor\x18\x01\x20\x01(\x05R\x05major\x12\x14\n\x05minor\x18\x02\x20\x01(\
    \x05R\x05minor\x12\x14\n\x05patch\x18\x03\x20\x01(\x05R\x05patch\x12\x16\
    \n\x06suffix\x18\x04\x20\x01(\tR\x06suffix\"\xf1\x01\n\x14CodeGeneratorR\
    equest\x12(\n\x10file_to_generate\x18\x01\x20\x03(\tR\x0efileToGenerate\
    \x12\x1c\n\tparameter\x18\x02\x20\x01(\tR\tparameter\x12C\n\nproto_file\
    \x18\x0f\x20\x03(\x0b2$.google.protobuf.FileDescriptorProtoR\tprotoFile\
    \x12L\n\x10compiler_version\x18\x03\x20\x01(\x0b2!.google.protobuf.compi\
    ler.VersionR\x0fcompilerVersion\"\x94\x03\n\x15CodeGeneratorResponse\x12\
    \x14\n\x05error\x18\x01\x20\x01(\tR\x05error\x12-\n\x12supported_feature\
    s\x18\x02\x20\x01(\x04R\x11supportedFeatures\x12H\n\x04file\x18\x0f\x20\
    \x03(\x0b24.google.protobuf.compiler.CodeGeneratorResponse.FileR\x04file\
    \x1a\xb1\x01\n\x04File\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    '\n\x0finsertion_point\x18\x02\x20\x01(\tR\x0einsertionPoint\x12\x18\n\
    \x07content\x18\x0f\x20\x01(\tR\x07content\x12R\n\x13generated_code_info\
    \x18\x10\x20\x01(\x0b2\".google.protobuf.GeneratedCodeInfoR\x11generated\
    CodeInfo\"8\n\x07Feature\x12\x10\n\x0cFEATURE_NONE\x10\0\x12\x1b\n\x17FE\
    ATURE_PROTO3_OPTIONAL\x10\x01BW\n\x1ccom.google.protobuf.compilerB\x0cPl\
    uginProtosZ)google.golang.org/protobuf/types/pluginpbJ\xf9C\n\x07\x12\
    \x05.\0\xb6\x01\x01\n\xca\x11\n\x01\x0c\x12\x03.\0\x122\xc1\x0c\x20Proto\
    col\x20Buffers\x20-\x20Google's\x20data\x20interchange\x20format\n\x20Co\
    pyright\x202008\x20Google\x20Inc.\x20\x20All\x20rights\x20reserved.\n\
    \x20https://developers.google.com/protocol-buffers/\n\n\x20Redistributio\
    n\x20and\x20use\x20in\x20source\x20and\x20binary\x20forms,\x20with\x20or\
    \x20without\n\x20modification,\x20are\x20permitted\x20provided\x20that\
    \x20the\x20following\x20conditions\x20are\n\x20met:\n\n\x20\x20\x20\x20\
    \x20*\x20Redistributions\x20of\x20source\x20code\x20must\x20retain\x20th\
    e\x20above\x20copyright\n\x20notice,\x20this\x20list\x20of\x20conditions\
    \x20and\x20the\x20following\x20disclaimer.\n\x20\x20\x20\x20\x20*\x20Red\
    istributions\x20in\x20binary\x20form\x20must\x20reproduce\x20the\x20abov\
    e\n\x20copyright\x20notice,\x20this\x20list\x20of\x20conditions\x20and\
    \x20the\x20following\x20disclaimer\n\x20in\x20the\x20documentation\x20an\
    d/or\x20other\x20materials\x20provided\x20with\x20the\n\x20distribution.\
    \n\x20\x20\x20\x20\x20*\x20Neither\x20the\x20name\x20of\x20Google\x20Inc\
    .\x20nor\x20the\x20names\x20of\x20its\n\x20contributors\x20may\x20be\x20\
    used\x20to\x20endorse\x20or\x20promote\x20products\x20derived\x20from\n\
    \x20this\x20software\x20without\x20specific\x20prior\x20written\x20permi\
    ssion.\n\n\x20THIS\x20SOFTWARE\x20IS\x20PROVIDED\x20BY\x20THE\x20COPYRIG\
    HT\x20HOLDERS\x20AND\x20CONTRIBUTORS\n\x20\"AS\x20IS\"\x20AND\x20ANY\x20\
    EXPRESS\x20OR\x20IMPLIED\x20WARRANTIES,\x20INCLUDING,\x20BUT\x20NOT\n\
    \x20LIMITED\x20TO,\x20THE\x20IMPLIED\x20WARRANTIES\x20OF\x20MERCHANTABIL\
    ITY\x20AND\x20FITNESS\x20FOR\n\x20A\x20PARTICULAR\x20PURPOSE\x20ARE\x20D\
    ISCLAIMED.\x20IN\x20NO\x20EVENT\x20SHALL\x20THE\x20COPYRIGHT\n\x20OWNER\
    \x20OR\x20CONTRIBUTORS\x20BE\x20LIABLE\x20FOR\x20ANY\x20DIRECT,\x20INDIR\
    ECT,\x20INCIDENTAL,\n\x20SPECIAL,\x20EXEMPLARY,\x20OR\x20CONSEQUENTIAL\
    \x20DAMAGES\x20(INCLUDING,\x20BUT\x20NOT\n\x20LIMITED\x20TO,\x20PROCUREM\
    ENT\x20OF\x20SUBSTITUTE\x20GOODS\x20OR\x20SERVICES;\x20LOSS\x20OF\x20USE\
    ,\n\x20DATA,\x20OR\x20PROFITS;\x20OR\x20BUSINESS\x20INTERRUPTION)\x20HOW\
    EVER\x20CAUSED\x20AND\x20ON\x20ANY\n\x20THEORY\x20OF\x20LIABILITY,\x20WH\
    ETHER\x20IN\x20CONTRACT,\x20STRICT\x20LIABILITY,\x20OR\x20TORT\n\x20(INC\
    LUDING\x20NEGLIGENCE\x20OR\x20OTHERWISE)\x20ARISING\x20IN\x20ANY\x20WAY\
    \x20OUT\x20OF\x20THE\x20USE\n\x20OF\x20THIS\x20SOFTWARE,\x20EVEN\x20IF\
    \x20ADVISED\x20OF\x20THE\x20POSSIBILITY\x20OF\x20SUCH\x20DAMAGE.\n2\xfb\
    \x04\x20Author:\x20kenton@google.com\x20(Kenton\x20Varda)\n\n\x20WARNING\
    :\x20\x20The\x20plugin\x20interface\x20is\x20currently\x20EXPERIMENTAL\
    \x20and\x20is\x20subject\x20to\n\x20\x20\x20change.\n\n\x20protoc\x20(ak\
    a\x20the\x20Protocol\x20Compiler)\x20can\x20be\x20extended\x20via\x20plu\
    gins.\x20\x20A\x20plugin\x20is\n\x20just\x20a\x20program\x20that\x20read\
    s\x20a\x20CodeGeneratorRequest\x20from\x20stdin\x20and\x20writes\x20a\n\
    \x20CodeGeneratorResponse\x20to\x20stdout.\n\n\x20Plugins\x20written\x20\
    using\x20C++\x20can\x20use\x20google/protobuf/compiler/plugin.h\x20inste\
    ad\n\x20of\x20dealing\x20with\x20the\x20raw\x20protocol\x20defined\x20he\
    re.\n\n\x20A\x20plugin\x20executable\x20needs\x20only\x20to\x20be\x20pla\
    ced\x20somewhere\x20in\x20the\x20path.\x20\x20The\n\x20plugin\x20should\
    \x20be\x20named\x20\"protoc-gen-$NAME\",\x20and\x20will\x20then\x20be\
    \x20used\x20when\x20the\n\x20flag\x20\"--${NAME}_out\"\x20is\x20passed\
    \x20to\x20protoc.\n\n\x08\n\x01\x02\x12\x030\0!\n\x08\n\x01\x08\x12\x031\
    \05\n\t\n\x02\x08\x01\x12\x031\05\n\x08\n\x01\x08\x12\x032\0-\n\t\n\x02\
    \x08\x08\x12\x032\0-\n\x08\n\x01\x08\x12\x034\0@\n\t\n\x02\x08\x0b\x12\
    \x034\0@\n\t\n\x02\x03\0\x12\x036\0*\n6\n\x02\x04\0\x12\x049\0@\x01\x1a*\
    \x20The\x20version\x20number\x20of\x20protocol\x20compiler.\n\n\n\n\x03\
    \x04\0\x01\x12\x039\x08\x0f\n\x0b\n\x04\x04\0\x02\0\x12\x03:\x02\x1b\n\
    \x0c\n\x05\x04\0\x02\0\x04\x12\x03:\x02\n\n\x0c\n\x05\x04\0\x02\0\x05\
    \x12\x03:\x0b\x10\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03:\x11\x16\n\x0c\n\
    \x05\x04\0\x02\0\x03\x12\x03:\x19\x1a\n\x0b\n\x04\x04\0\x02\x01\x12\x03;\
    \x02\x1b\n\x0c\n\x05\x04\0\x02\x01\x04\x12\x03;\x02\n\n\x0c\n\x05\x04\0\
    \x02\x01\x05\x12\x03;\x0b\x10\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03;\x11\
    \x16\n\x0c\n\x05\x04\0\x02\x01\x03\x12\x03;\x19\x1a\n\x0b\n\x04\x04\0\
    \x02\x02\x12\x03<\x02\x1b\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03<\x02\n\n\
    \x0c\n\x05\x04\0\x02\x02\x05\x12\x03<\x0b\x10\n\x0c\n\x05\x04\0\x02\x02\
    \x01\x12\x03<\x11\x16\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x03<\x19\x1a\n\
    \x80\x01\n\x04\x04\0\x02\x03\x12\x03?\x02\x1d\x1as\x20A\x20suffix\x20for\
    \x20alpha,\x20beta\x20or\x20rc\x20release,\x20e.g.,\x20\"alpha-1\",\x20\
    \"rc2\".\x20It\x20should\n\x20be\x20empty\x20for\x20mainline\x20stable\
    \x20releases.\n\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x03?\x02\n\n\x0c\n\x05\
    \x04\0\x02\x03\x05\x12\x03?\x0b\x11\n\x0c\n\x05\x04\0\x02\x03\x01\x12\
    \x03?\x12\x18\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x03?\x1b\x1c\nO\n\x02\
    \x04\x01\x12\x04C\0_\x01\x1aC\x20An\x20encoded\x20CodeGeneratorRequest\
    \x20is\x20written\x20to\x20the\x20plugin's\x20stdin.\n\n\n\n\x03\x04\x01\
    \x01\x12\x03C\x08\x1c\n\xd1\x01\n\x04\x04\x01\x02\0\x12\x03G\x02'\x1a\
    \xc3\x01\x20The\x20.proto\x20files\x20that\x20were\x20explicitly\x20list\
    ed\x20on\x20the\x20command-line.\x20\x20The\n\x20code\x20generator\x20sh\
    ould\x20generate\x20code\x20only\x20for\x20these\x20files.\x20\x20Each\
    \x20file's\n\x20descriptor\x20will\x20be\x20included\x20in\x20proto_file\
    ,\x20below.\n\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03G\x02\n\n\x0c\n\x05\
    \x04\x01\x02\0\x05\x12\x03G\x0b\x11\n\x0c\n\x05\x04\x01\x02\0\x01\x12\
    \x03G\x12\"\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03G%&\nB\n\x04\x04\x01\
    \x02\x01\x12\x03J\x02\x20\x1a5\x20The\x20generator\x20parameter\x20passe\
    d\x20on\x20the\x20command-line.\n\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\
    \x03J\x02\n\n\x0c\n\x05\x04\x01\x02\x01\x05\x12\x03J\x0b\x11\n\x0c\n\x05\
    \x04\x01\x02\x01\x01\x12\x03J\x12\x1b\n\x0c\n\x05\x04\x01\x02\x01\x03\
    \x12\x03J\x1e\x1f\n\x87\x06\n\x04\x04\x01\x02\x02\x12\x03Z\x02/\x1a\xf9\
    \x05\x20FileDescriptorProtos\x20for\x20all\x20files\x20in\x20files_to_ge\
    nerate\x20and\x20everything\n\x20they\x20import.\x20\x20The\x20files\x20\
    will\x20appear\x20in\x20topological\x20order,\x20so\x20each\x20file\n\
    \x20appears\x20before\x20any\x20file\x20that\x20imports\x20it.\n\n\x20pr\
    otoc\x20guarantees\x20that\x20all\x20proto_files\x20will\x20be\x20writte\
    n\x20after\n\x20the\x20fields\x20above,\x20even\x20though\x20this\x20is\
    \x20not\x20technically\x20guaranteed\x20by\x20the\n\x20protobuf\x20wire\
    \x20format.\x20\x20This\x20theoretically\x20could\x20allow\x20a\x20plugi\
    n\x20to\x20stream\n\x20in\x20the\x20FileDescriptorProtos\x20and\x20handl\
    e\x20them\x20one\x20by\x20one\x20rather\x20than\x20read\n\x20the\x20enti\
    re\x20set\x20into\x20memory\x20at\x20once.\x20\x20However,\x20as\x20of\
    \x20this\x20writing,\x20this\n\x20is\x20not\x20similarly\x20optimized\
    \x20on\x20protoc's\x20end\x20--\x20it\x20will\x20store\x20all\x20fields\
    \x20in\n\x20memory\x20at\x20once\x20before\x20sending\x20them\x20to\x20t\
    he\x20plugin.\n\n\x20Type\x20names\x20of\x20fields\x20and\x20extensions\
    \x20in\x20the\x20FileDescriptorProto\x20are\x20always\n\x20fully\x20qual\
    ified.\n\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03Z\x02\n\n\x0c\n\x05\x04\
    \x01\x02\x02\x06\x12\x03Z\x0b\x1e\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\
    \x03Z\x1f)\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03Z,.\n7\n\x04\x04\x01\
    \x02\x03\x12\x03]\x02(\x1a*\x20The\x20version\x20number\x20of\x20protoco\
    l\x20compiler.\n\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03]\x02\n\n\x0c\n\
    \x05\x04\x01\x02\x03\x06\x12\x03]\x0b\x12\n\x0c\n\x05\x04\x01\x02\x03\
    \x01\x12\x03]\x13#\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03]&'\nL\n\x02\
    \x04\x02\x12\x05b\0\xb6\x01\x01\x1a?\x20The\x20plugin\x20writes\x20an\
    \x20encoded\x20CodeGeneratorResponse\x20to\x20stdout.\n\n\n\n\x03\x04\
    \x02\x01\x12\x03b\x08\x1d\n\xed\x03\n\x04\x04\x02\x02\0\x12\x03k\x02\x1c\
    \x1a\xdf\x03\x20Error\x20message.\x20\x20If\x20non-empty,\x20code\x20gen\
    eration\x20failed.\x20\x20The\x20plugin\x20process\n\x20should\x20exit\
    \x20with\x20status\x20code\x20zero\x20even\x20if\x20it\x20reports\x20an\
    \x20error\x20in\x20this\x20way.\n\n\x20This\x20should\x20be\x20used\x20t\
    o\x20indicate\x20errors\x20in\x20.proto\x20files\x20which\x20prevent\x20\
    the\n\x20code\x20generator\x20from\x20generating\x20correct\x20code.\x20\
    \x20Errors\x20which\x20indicate\x20a\n\x20problem\x20in\x20protoc\x20its\
    elf\x20--\x20such\x20as\x20the\x20input\x20CodeGeneratorRequest\x20being\
    \n\x20unparseable\x20--\x20should\x20be\x20reported\x20by\x20writing\x20\
    a\x20message\x20to\x20stderr\x20and\n\x20exiting\x20with\x20a\x20non-zer\
    o\x20status\x20code.\n\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03k\x02\n\n\
    \x0c\n\x05\x04\x02\x02\0\x05\x12\x03k\x0b\x11\n\x0c\n\x05\x04\x02\x02\0\
    \x01\x12\x03k\x12\x17\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03k\x1a\x1b\n\
    \x89\x01\n\x04\x04\x02\x02\x01\x12\x03o\x02)\x1a|\x20A\x20bitmask\x20of\
    \x20supported\x20features\x20that\x20the\x20code\x20generator\x20support\
    s.\n\x20This\x20is\x20a\x20bitwise\x20\"or\"\x20of\x20values\x20from\x20\
    the\x20Feature\x20enum.\n\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03o\x02\n\
    \n\x0c\n\x05\x04\x02\x02\x01\x05\x12\x03o\x0b\x11\n\x0c\n\x05\x04\x02\
    \x02\x01\x01\x12\x03o\x12$\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03o'(\n+\
    \n\x04\x04\x02\x04\0\x12\x04r\x02u\x03\x1a\x1d\x20Sync\x20with\x20code_g\
    enerator.h.\n\n\x0c\n\x05\x04\x02\x04\0\x01\x12\x03r\x07\x0e\n\r\n\x06\
    \x04\x02\x04\0\x02\0\x12\x03s\x04\x15\n\x0e\n\x07\x04\x02\x04\0\x02\0\
    \x01\x12\x03s\x04\x10\n\x0e\n\x07\x04\x02\x04\0\x02\0\x02\x12\x03s\x13\
    \x14\n\r\n\x06\x04\x02\x04\0\x02\x01\x12\x03t\x04\x20\n\x0e\n\x07\x04\
    \x02\x04\0\x02\x01\x01\x12\x03t\x04\x1b\n\x0e\n\x07\x04\x02\x04\0\x02\
    \x01\x02\x12\x03t\x1e\x1f\n4\n\x04\x04\x02\x03\0\x12\x05x\x02\xb4\x01\
    \x03\x1a%\x20Represents\x20a\x20single\x20generated\x20file.\n\n\x0c\n\
    \x05\x04\x02\x03\0\x01\x12\x03x\n\x0e\n\xae\x05\n\x06\x04\x02\x03\0\x02\
    \0\x12\x04\x84\x01\x04\x1d\x1a\x9d\x05\x20The\x20file\x20name,\x20relati\
    ve\x20to\x20the\x20output\x20directory.\x20\x20The\x20name\x20must\x20no\
    t\n\x20contain\x20\".\"\x20or\x20\"..\"\x20components\x20and\x20must\x20\
    be\x20relative,\x20not\x20be\x20absolute\x20(so,\n\x20the\x20file\x20can\
    not\x20lie\x20outside\x20the\x20output\x20directory).\x20\x20\"/\"\x20mu\
    st\x20be\x20used\x20as\n\x20the\x20path\x20separator,\x20not\x20\"\\\".\
    \n\n\x20If\x20the\x20name\x20is\x20omitted,\x20the\x20content\x20will\
    \x20be\x20appended\x20to\x20the\x20previous\n\x20file.\x20\x20This\x20al\
    lows\x20the\x20generator\x20to\x20break\x20large\x20files\x20into\x20sma\
    ll\x20chunks,\n\x20and\x20allows\x20the\x20generated\x20text\x20to\x20be\
    \x20streamed\x20back\x20to\x20protoc\x20so\x20that\x20large\n\x20files\
    \x20need\x20not\x20reside\x20completely\x20in\x20memory\x20at\x20one\x20\
    time.\x20\x20Note\x20that\x20as\x20of\n\x20this\x20writing\x20protoc\x20\
    does\x20not\x20optimize\x20for\x20this\x20--\x20it\x20will\x20read\x20th\
    e\x20entire\n\x20CodeGeneratorResponse\x20before\x20writing\x20files\x20\
    to\x20disk.\n\n\x0f\n\x07\x04\x02\x03\0\x02\0\x04\x12\x04\x84\x01\x04\
    \x0c\n\x0f\n\x07\x04\x02\x03\0\x02\0\x05\x12\x04\x84\x01\r\x13\n\x0f\n\
    \x07\x04\x02\x03\0\x02\0\x01\x12\x04\x84\x01\x14\x18\n\x0f\n\x07\x04\x02\
    \x03\0\x02\0\x03\x12\x04\x84\x01\x1b\x1c\n\xae\x10\n\x06\x04\x02\x03\0\
    \x02\x01\x12\x04\xab\x01\x04(\x1a\x9d\x10\x20If\x20non-empty,\x20indicat\
    es\x20that\x20the\x20named\x20file\x20should\x20already\x20exist,\x20and\
    \x20the\n\x20content\x20here\x20is\x20to\x20be\x20inserted\x20into\x20th\
    at\x20file\x20at\x20a\x20defined\x20insertion\n\x20point.\x20\x20This\
    \x20feature\x20allows\x20a\x20code\x20generator\x20to\x20extend\x20the\
    \x20output\n\x20produced\x20by\x20another\x20code\x20generator.\x20\x20T\
    he\x20original\x20generator\x20may\x20provide\n\x20insertion\x20points\
    \x20by\x20placing\x20special\x20annotations\x20in\x20the\x20file\x20that\
    \x20look\n\x20like:\n\x20\x20\x20@@protoc_insertion_point(NAME)\n\x20The\
    \x20annotation\x20can\x20have\x20arbitrary\x20text\x20before\x20and\x20a\
    fter\x20it\x20on\x20the\x20line,\n\x20which\x20allows\x20it\x20to\x20be\
    \x20placed\x20in\x20a\x20comment.\x20\x20NAME\x20should\x20be\x20replace\
    d\x20with\n\x20an\x20identifier\x20naming\x20the\x20point\x20--\x20this\
    \x20is\x20what\x20other\x20generators\x20will\x20use\n\x20as\x20the\x20i\
    nsertion_point.\x20\x20Code\x20inserted\x20at\x20this\x20point\x20will\
    \x20be\x20placed\n\x20immediately\x20above\x20the\x20line\x20containing\
    \x20the\x20insertion\x20point\x20(thus\x20multiple\n\x20insertions\x20to\
    \x20the\x20same\x20point\x20will\x20come\x20out\x20in\x20the\x20order\
    \x20they\x20were\x20added).\n\x20The\x20double-@\x20is\x20intended\x20to\
    \x20make\x20it\x20unlikely\x20that\x20the\x20generated\x20code\n\x20coul\
    d\x20contain\x20things\x20that\x20look\x20like\x20insertion\x20points\
    \x20by\x20accident.\n\n\x20For\x20example,\x20the\x20C++\x20code\x20gene\
    rator\x20places\x20the\x20following\x20line\x20in\x20the\n\x20.pb.h\x20f\
    iles\x20that\x20it\x20generates:\n\x20\x20\x20//\x20@@protoc_insertion_p\
    oint(namespace_scope)\n\x20This\x20line\x20appears\x20within\x20the\x20s\
    cope\x20of\x20the\x20file's\x20package\x20namespace,\x20but\n\x20outside\
    \x20of\x20any\x20particular\x20class.\x20\x20Another\x20plugin\x20can\
    \x20then\x20specify\x20the\n\x20insertion_point\x20\"namespace_scope\"\
    \x20to\x20generate\x20additional\x20classes\x20or\n\x20other\x20declarat\
    ions\x20that\x20should\x20be\x20placed\x20in\x20this\x20scope.\n\n\x20No\
    te\x20that\x20if\x20the\x20line\x20containing\x20the\x20insertion\x20poi\
    nt\x20begins\x20with\n\x20whitespace,\x20the\x20same\x20whitespace\x20wi\
    ll\x20be\x20added\x20to\x20every\x20line\x20of\x20the\n\x20inserted\x20t\
    ext.\x20\x20This\x20is\x20useful\x20for\x20languages\x20like\x20Python,\
    \x20where\n\x20indentation\x20matters.\x20\x20In\x20these\x20languages,\
    \x20the\x20insertion\x20point\x20comment\n\x20should\x20be\x20indented\
    \x20the\x20same\x20amount\x20as\x20any\x20inserted\x20code\x20will\x20ne\
    ed\x20to\x20be\n\x20in\x20order\x20to\x20work\x20correctly\x20in\x20that\
    \x20context.\n\n\x20The\x20code\x20generator\x20that\x20generates\x20the\
    \x20initial\x20file\x20and\x20the\x20one\x20which\n\x20inserts\x20into\
    \x20it\x20must\x20both\x20run\x20as\x20part\x20of\x20a\x20single\x20invo\
    cation\x20of\x20protoc.\n\x20Code\x20generators\x20are\x20executed\x20in\
    \x20the\x20order\x20in\x20which\x20they\x20appear\x20on\x20the\n\x20comm\
    and\x20line.\n\n\x20If\x20|insertion_point|\x20is\x20present,\x20|name|\
    \x20must\x20also\x20be\x20present.\n\n\x0f\n\x07\x04\x02\x03\0\x02\x01\
    \x04\x12\x04\xab\x01\x04\x0c\n\x0f\n\x07\x04\x02\x03\0\x02\x01\x05\x12\
    \x04\xab\x01\r\x13\n\x0f\n\x07\x04\x02\x03\0\x02\x01\x01\x12\x04\xab\x01\
    \x14#\n\x0f\n\x07\x04\x02\x03\0\x02\x01\x03\x12\x04\xab\x01&'\n$\n\x06\
    \x04\x02\x03\0\x02\x02\x12\x04\xae\x01\x04!\x1a\x14\x20The\x20file\x20co\
    ntents.\n\n\x0f\n\x07\x04\x02\x03\0\x02\x02\x04\x12\x04\xae\x01\x04\x0c\
    \n\x0f\n\x07\x04\x02\x03\0\x02\x02\x05\x12\x04\xae\x01\r\x13\n\x0f\n\x07\
    \x04\x02\x03\0\x02\x02\x01\x12\x04\xae\x01\x14\x1b\n\x0f\n\x07\x04\x02\
    \x03\0\x02\x02\x03\x12\x04\xae\x01\x1e\x20\n\xe1\x01\n\x06\x04\x02\x03\0\
    \x02\x03\x12\x04\xb3\x01\x048\x1a\xd0\x01\x20Information\x20describing\
    \x20the\x20file\x20content\x20being\x20inserted.\x20If\x20an\x20insertio\
    n\n\x20point\x20is\x20used,\x20this\x20information\x20will\x20be\x20appr\
    opriately\x20offset\x20and\x20inserted\n\x20into\x20the\x20code\x20gener\
    ation\x20metadata\x20for\x20the\x20generated\x20files.\n\n\x0f\n\x07\x04\
    \x02\x03\0\x02\x03\x04\x12\x04\xb3\x01\x04\x0c\n\x0f\n\x07\x04\x02\x03\0\
    \x02\x03\x06\x12\x04\xb3\x01\r\x1e\n\x0f\n\x07\x04\x02\x03\0\x02\x03\x01\
    \x12\x04\xb3\x01\x1f2\n\x0f\n\x07\x04\x02\x03\0\x02\x03\x03\x12\x04\xb3\
    \x0157\n\x0c\n\x04\x04\x02\x02\x02\x12\x04\xb5\x01\x02\x1a\n\r\n\x05\x04\
    \x02\x02\x02\x04\x12\x04\xb5\x01\x02\n\n\r\n\x05\x04\x02\x02\x02\x06\x12\
    \x04\xb5\x01\x0b\x0f\n\r\n\x05\x04\x02\x02\x02\x01\x12\x04\xb5\x01\x10\
    \x14\n\r\n\x05\x04\x02\x02\x02\x03\x12\x04\xb5\x01\x17\x19\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(crate::descriptor::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(4);
            messages.push(Version::generated_message_descriptor_data());
            messages.push(CodeGeneratorRequest::generated_message_descriptor_data());
            messages.push(CodeGeneratorResponse::generated_message_descriptor_data());
            messages.push(code_generator_response::File::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(1);
            enums.push(code_generator_response::Feature::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
