// This file is generated by rust-protobuf 3.5.0-pre. Do not edit
// .proto file is parsed by protoc --rust_out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `google/protobuf/descriptor.proto`

///  The protocol compiler can output a FileDescriptorSet containing the .proto
///  files it parses.
// @@protoc_insertion_point(message:google.protobuf.FileDescriptorSet)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileDescriptorSet {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorSet.file)
    pub file: ::std::vec::Vec<FileDescriptorProto>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FileDescriptorSet.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileDescriptorSet {
    fn default() -> &'a FileDescriptorSet {
        <FileDescriptorSet as crate::Message>::default_instance()
    }
}

impl FileDescriptorSet {
    pub fn new() -> FileDescriptorSet {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "file",
            |m: &FileDescriptorSet| { &m.file },
            |m: &mut FileDescriptorSet| { &mut m.file },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<FileDescriptorSet>(
            "FileDescriptorSet",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for FileDescriptorSet {
    const NAME: &'static str = "FileDescriptorSet";

    fn is_initialized(&self) -> bool {
        for v in &self.file {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.file.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.file {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.file {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileDescriptorSet {
        FileDescriptorSet::new()
    }

    fn clear(&mut self) {
        self.file.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileDescriptorSet {
        static instance: FileDescriptorSet = FileDescriptorSet {
            file: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for FileDescriptorSet {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileDescriptorSet").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileDescriptorSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for FileDescriptorSet {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Describes a complete .proto file.
// @@protoc_insertion_point(message:google.protobuf.FileDescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.package)
    pub package: ::std::option::Option<::std::string::String>,
    ///  Names of files imported by this file.
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.dependency)
    pub dependency: ::std::vec::Vec<::std::string::String>,
    ///  Indexes of the public imported files in the dependency list above.
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.public_dependency)
    pub public_dependency: ::std::vec::Vec<i32>,
    ///  Indexes of the weak imported files in the dependency list.
    ///  For Google-internal migration only. Do not use.
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.weak_dependency)
    pub weak_dependency: ::std::vec::Vec<i32>,
    ///  All top-level definitions in this file.
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.message_type)
    pub message_type: ::std::vec::Vec<DescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.enum_type)
    pub enum_type: ::std::vec::Vec<EnumDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.service)
    pub service: ::std::vec::Vec<ServiceDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.extension)
    pub extension: ::std::vec::Vec<FieldDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.options)
    pub options: crate::MessageField<FileOptions>,
    ///  This field contains optional information about the original source code.
    ///  You may safely remove this entire field without harming runtime
    ///  functionality of the descriptors -- the information is needed only by
    ///  development tools.
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.source_code_info)
    pub source_code_info: crate::MessageField<SourceCodeInfo>,
    ///  The syntax of the proto file.
    ///  The supported values are "proto2" and "proto3".
    // @@protoc_insertion_point(field:google.protobuf.FileDescriptorProto.syntax)
    pub syntax: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FileDescriptorProto.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileDescriptorProto {
    fn default() -> &'a FileDescriptorProto {
        <FileDescriptorProto as crate::Message>::default_instance()
    }
}

impl FileDescriptorProto {
    pub fn new() -> FileDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string package = 2;

    pub fn package(&self) -> &str {
        match self.package.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_package(&mut self) {
        self.package = ::std::option::Option::None;
    }

    pub fn has_package(&self) -> bool {
        self.package.is_some()
    }

    // Param is passed by value, moved
    pub fn set_package(&mut self, v: ::std::string::String) {
        self.package = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_package(&mut self) -> &mut ::std::string::String {
        if self.package.is_none() {
            self.package = ::std::option::Option::Some(::std::string::String::new());
        }
        self.package.as_mut().unwrap()
    }

    // Take field
    pub fn take_package(&mut self) -> ::std::string::String {
        self.package.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string syntax = 12;

    pub fn syntax(&self) -> &str {
        match self.syntax.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_syntax(&mut self) {
        self.syntax = ::std::option::Option::None;
    }

    pub fn has_syntax(&self) -> bool {
        self.syntax.is_some()
    }

    // Param is passed by value, moved
    pub fn set_syntax(&mut self, v: ::std::string::String) {
        self.syntax = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_syntax(&mut self) -> &mut ::std::string::String {
        if self.syntax.is_none() {
            self.syntax = ::std::option::Option::Some(::std::string::String::new());
        }
        self.syntax.as_mut().unwrap()
    }

    // Take field
    pub fn take_syntax(&mut self) -> ::std::string::String {
        self.syntax.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &FileDescriptorProto| { &m.name },
            |m: &mut FileDescriptorProto| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "package",
            |m: &FileDescriptorProto| { &m.package },
            |m: &mut FileDescriptorProto| { &mut m.package },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "dependency",
            |m: &FileDescriptorProto| { &m.dependency },
            |m: &mut FileDescriptorProto| { &mut m.dependency },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "public_dependency",
            |m: &FileDescriptorProto| { &m.public_dependency },
            |m: &mut FileDescriptorProto| { &mut m.public_dependency },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "weak_dependency",
            |m: &FileDescriptorProto| { &m.weak_dependency },
            |m: &mut FileDescriptorProto| { &mut m.weak_dependency },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "message_type",
            |m: &FileDescriptorProto| { &m.message_type },
            |m: &mut FileDescriptorProto| { &mut m.message_type },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enum_type",
            |m: &FileDescriptorProto| { &m.enum_type },
            |m: &mut FileDescriptorProto| { &mut m.enum_type },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "service",
            |m: &FileDescriptorProto| { &m.service },
            |m: &mut FileDescriptorProto| { &mut m.service },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "extension",
            |m: &FileDescriptorProto| { &m.extension },
            |m: &mut FileDescriptorProto| { &mut m.extension },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, FileOptions>(
            "options",
            |m: &FileDescriptorProto| { &m.options },
            |m: &mut FileDescriptorProto| { &mut m.options },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, SourceCodeInfo>(
            "source_code_info",
            |m: &FileDescriptorProto| { &m.source_code_info },
            |m: &mut FileDescriptorProto| { &mut m.source_code_info },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "syntax",
            |m: &FileDescriptorProto| { &m.syntax },
            |m: &mut FileDescriptorProto| { &mut m.syntax },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<FileDescriptorProto>(
            "FileDescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for FileDescriptorProto {
    const NAME: &'static str = "FileDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.message_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.enum_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source_code_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.package = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.dependency.push(is.read_string()?);
                },
                82 => {
                    is.read_repeated_packed_int32_into(&mut self.public_dependency)?;
                },
                80 => {
                    self.public_dependency.push(is.read_int32()?);
                },
                90 => {
                    is.read_repeated_packed_int32_into(&mut self.weak_dependency)?;
                },
                88 => {
                    self.weak_dependency.push(is.read_int32()?);
                },
                34 => {
                    self.message_type.push(is.read_message()?);
                },
                42 => {
                    self.enum_type.push(is.read_message()?);
                },
                50 => {
                    self.service.push(is.read_message()?);
                },
                58 => {
                    self.extension.push(is.read_message()?);
                },
                66 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                74 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.source_code_info)?;
                },
                98 => {
                    self.syntax = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.package.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        for value in &self.dependency {
            my_size += crate::rt::string_size(3, &value);
        };
        for value in &self.public_dependency {
            my_size += crate::rt::int32_size(10, *value);
        };
        for value in &self.weak_dependency {
            my_size += crate::rt::int32_size(11, *value);
        };
        for value in &self.message_type {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.enum_type {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.service {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.source_code_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.syntax.as_ref() {
            my_size += crate::rt::string_size(12, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.package.as_ref() {
            os.write_string(2, v)?;
        }
        for v in &self.dependency {
            os.write_string(3, &v)?;
        };
        for v in &self.public_dependency {
            os.write_int32(10, *v)?;
        };
        for v in &self.weak_dependency {
            os.write_int32(11, *v)?;
        };
        for v in &self.message_type {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.enum_type {
            crate::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.service {
            crate::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.extension {
            crate::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        if let Some(v) = self.options.as_ref() {
            crate::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.source_code_info.as_ref() {
            crate::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.syntax.as_ref() {
            os.write_string(12, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileDescriptorProto {
        FileDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.package = ::std::option::Option::None;
        self.dependency.clear();
        self.public_dependency.clear();
        self.weak_dependency.clear();
        self.message_type.clear();
        self.enum_type.clear();
        self.service.clear();
        self.extension.clear();
        self.options.clear();
        self.source_code_info.clear();
        self.syntax = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileDescriptorProto {
        static instance: FileDescriptorProto = FileDescriptorProto {
            name: ::std::option::Option::None,
            package: ::std::option::Option::None,
            dependency: ::std::vec::Vec::new(),
            public_dependency: ::std::vec::Vec::new(),
            weak_dependency: ::std::vec::Vec::new(),
            message_type: ::std::vec::Vec::new(),
            enum_type: ::std::vec::Vec::new(),
            service: ::std::vec::Vec::new(),
            extension: ::std::vec::Vec::new(),
            options: crate::MessageField::none(),
            source_code_info: crate::MessageField::none(),
            syntax: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for FileDescriptorProto {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileDescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileDescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for FileDescriptorProto {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Describes a message type.
// @@protoc_insertion_point(message:google.protobuf.DescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.field)
    pub field: ::std::vec::Vec<FieldDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.extension)
    pub extension: ::std::vec::Vec<FieldDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.nested_type)
    pub nested_type: ::std::vec::Vec<DescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.enum_type)
    pub enum_type: ::std::vec::Vec<EnumDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.extension_range)
    pub extension_range: ::std::vec::Vec<descriptor_proto::ExtensionRange>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.oneof_decl)
    pub oneof_decl: ::std::vec::Vec<OneofDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.options)
    pub options: crate::MessageField<MessageOptions>,
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.reserved_range)
    pub reserved_range: ::std::vec::Vec<descriptor_proto::ReservedRange>,
    ///  Reserved field names, which may not be used by fields in the same message.
    ///  A given name may only be reserved once.
    // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.reserved_name)
    pub reserved_name: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.DescriptorProto.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DescriptorProto {
    fn default() -> &'a DescriptorProto {
        <DescriptorProto as crate::Message>::default_instance()
    }
}

impl DescriptorProto {
    pub fn new() -> DescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &DescriptorProto| { &m.name },
            |m: &mut DescriptorProto| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "field",
            |m: &DescriptorProto| { &m.field },
            |m: &mut DescriptorProto| { &mut m.field },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "extension",
            |m: &DescriptorProto| { &m.extension },
            |m: &mut DescriptorProto| { &mut m.extension },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "nested_type",
            |m: &DescriptorProto| { &m.nested_type },
            |m: &mut DescriptorProto| { &mut m.nested_type },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "enum_type",
            |m: &DescriptorProto| { &m.enum_type },
            |m: &mut DescriptorProto| { &mut m.enum_type },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "extension_range",
            |m: &DescriptorProto| { &m.extension_range },
            |m: &mut DescriptorProto| { &mut m.extension_range },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "oneof_decl",
            |m: &DescriptorProto| { &m.oneof_decl },
            |m: &mut DescriptorProto| { &mut m.oneof_decl },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, MessageOptions>(
            "options",
            |m: &DescriptorProto| { &m.options },
            |m: &mut DescriptorProto| { &mut m.options },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reserved_range",
            |m: &DescriptorProto| { &m.reserved_range },
            |m: &mut DescriptorProto| { &mut m.reserved_range },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reserved_name",
            |m: &DescriptorProto| { &m.reserved_name },
            |m: &mut DescriptorProto| { &mut m.reserved_name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<DescriptorProto>(
            "DescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for DescriptorProto {
    const NAME: &'static str = "DescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.field {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nested_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.enum_type {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.extension_range {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.oneof_decl {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reserved_range {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.field.push(is.read_message()?);
                },
                50 => {
                    self.extension.push(is.read_message()?);
                },
                26 => {
                    self.nested_type.push(is.read_message()?);
                },
                34 => {
                    self.enum_type.push(is.read_message()?);
                },
                42 => {
                    self.extension_range.push(is.read_message()?);
                },
                66 => {
                    self.oneof_decl.push(is.read_message()?);
                },
                58 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                74 => {
                    self.reserved_range.push(is.read_message()?);
                },
                82 => {
                    self.reserved_name.push(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        for value in &self.field {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.extension {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.nested_type {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.enum_type {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.extension_range {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.oneof_decl {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.reserved_range {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.reserved_name {
            my_size += crate::rt::string_size(10, &value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.field {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.extension {
            crate::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.nested_type {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.enum_type {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.extension_range {
            crate::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.oneof_decl {
            crate::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.options.as_ref() {
            crate::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        for v in &self.reserved_range {
            crate::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        for v in &self.reserved_name {
            os.write_string(10, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DescriptorProto {
        DescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.field.clear();
        self.extension.clear();
        self.nested_type.clear();
        self.enum_type.clear();
        self.extension_range.clear();
        self.oneof_decl.clear();
        self.options.clear();
        self.reserved_range.clear();
        self.reserved_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DescriptorProto {
        static instance: DescriptorProto = DescriptorProto {
            name: ::std::option::Option::None,
            field: ::std::vec::Vec::new(),
            extension: ::std::vec::Vec::new(),
            nested_type: ::std::vec::Vec::new(),
            enum_type: ::std::vec::Vec::new(),
            extension_range: ::std::vec::Vec::new(),
            oneof_decl: ::std::vec::Vec::new(),
            options: crate::MessageField::none(),
            reserved_range: ::std::vec::Vec::new(),
            reserved_name: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for DescriptorProto {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for DescriptorProto {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `DescriptorProto`
pub mod descriptor_proto {
    // @@protoc_insertion_point(message:google.protobuf.DescriptorProto.ExtensionRange)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ExtensionRange {
        // message fields
        // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.ExtensionRange.start)
        pub start: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.ExtensionRange.end)
        pub end: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.ExtensionRange.options)
        pub options: crate::MessageField<super::ExtensionRangeOptions>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.DescriptorProto.ExtensionRange.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ExtensionRange {
        fn default() -> &'a ExtensionRange {
            <ExtensionRange as crate::Message>::default_instance()
        }
    }

    impl ExtensionRange {
        pub fn new() -> ExtensionRange {
            ::std::default::Default::default()
        }

        // optional int32 start = 1;

        pub fn start(&self) -> i32 {
            self.start.unwrap_or(0)
        }

        pub fn clear_start(&mut self) {
            self.start = ::std::option::Option::None;
        }

        pub fn has_start(&self) -> bool {
            self.start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start(&mut self, v: i32) {
            self.start = ::std::option::Option::Some(v);
        }

        // optional int32 end = 2;

        pub fn end(&self) -> i32 {
            self.end.unwrap_or(0)
        }

        pub fn clear_end(&mut self) {
            self.end = ::std::option::Option::None;
        }

        pub fn has_end(&self) -> bool {
            self.end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end(&mut self, v: i32) {
            self.end = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(3);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "start",
                |m: &ExtensionRange| { &m.start },
                |m: &mut ExtensionRange| { &mut m.start },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "end",
                |m: &ExtensionRange| { &m.end },
                |m: &mut ExtensionRange| { &mut m.end },
            ));
            fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, super::ExtensionRangeOptions>(
                "options",
                |m: &ExtensionRange| { &m.options },
                |m: &mut ExtensionRange| { &mut m.options },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<ExtensionRange>(
                "DescriptorProto.ExtensionRange",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for ExtensionRange {
        const NAME: &'static str = "ExtensionRange";

        fn is_initialized(&self) -> bool {
            for v in &self.options {
                if !v.is_initialized() {
                    return false;
                }
            };
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.start = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.end = ::std::option::Option::Some(is.read_int32()?);
                    },
                    26 => {
                        crate::rt::read_singular_message_into_field(is, &mut self.options)?;
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.start {
                my_size += crate::rt::int32_size(1, v);
            }
            if let Some(v) = self.end {
                my_size += crate::rt::int32_size(2, v);
            }
            if let Some(v) = self.options.as_ref() {
                let len = v.compute_size();
                my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.start {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.end {
                os.write_int32(2, v)?;
            }
            if let Some(v) = self.options.as_ref() {
                crate::rt::write_message_field_with_cached_size(3, v, os)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ExtensionRange {
            ExtensionRange::new()
        }

        fn clear(&mut self) {
            self.start = ::std::option::Option::None;
            self.end = ::std::option::Option::None;
            self.options.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ExtensionRange {
            static instance: ExtensionRange = ExtensionRange {
                start: ::std::option::Option::None,
                end: ::std::option::Option::None,
                options: crate::MessageField::none(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for ExtensionRange {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DescriptorProto.ExtensionRange").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ExtensionRange {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for ExtensionRange {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }

    ///  Range of reserved tag numbers. Reserved tag numbers may not be used by
    ///  fields or extension ranges in the same message. Reserved ranges may
    ///  not overlap.
    // @@protoc_insertion_point(message:google.protobuf.DescriptorProto.ReservedRange)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct ReservedRange {
        // message fields
        // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.ReservedRange.start)
        pub start: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:google.protobuf.DescriptorProto.ReservedRange.end)
        pub end: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.DescriptorProto.ReservedRange.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a ReservedRange {
        fn default() -> &'a ReservedRange {
            <ReservedRange as crate::Message>::default_instance()
        }
    }

    impl ReservedRange {
        pub fn new() -> ReservedRange {
            ::std::default::Default::default()
        }

        // optional int32 start = 1;

        pub fn start(&self) -> i32 {
            self.start.unwrap_or(0)
        }

        pub fn clear_start(&mut self) {
            self.start = ::std::option::Option::None;
        }

        pub fn has_start(&self) -> bool {
            self.start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start(&mut self, v: i32) {
            self.start = ::std::option::Option::Some(v);
        }

        // optional int32 end = 2;

        pub fn end(&self) -> i32 {
            self.end.unwrap_or(0)
        }

        pub fn clear_end(&mut self) {
            self.end = ::std::option::Option::None;
        }

        pub fn has_end(&self) -> bool {
            self.end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end(&mut self, v: i32) {
            self.end = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "start",
                |m: &ReservedRange| { &m.start },
                |m: &mut ReservedRange| { &mut m.start },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "end",
                |m: &ReservedRange| { &m.end },
                |m: &mut ReservedRange| { &mut m.end },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<ReservedRange>(
                "DescriptorProto.ReservedRange",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for ReservedRange {
        const NAME: &'static str = "ReservedRange";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.start = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.end = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.start {
                my_size += crate::rt::int32_size(1, v);
            }
            if let Some(v) = self.end {
                my_size += crate::rt::int32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.start {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.end {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> ReservedRange {
            ReservedRange::new()
        }

        fn clear(&mut self) {
            self.start = ::std::option::Option::None;
            self.end = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static ReservedRange {
            static instance: ReservedRange = ReservedRange {
                start: ::std::option::Option::None,
                end: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for ReservedRange {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("DescriptorProto.ReservedRange").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for ReservedRange {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for ReservedRange {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

// @@protoc_insertion_point(message:google.protobuf.ExtensionRangeOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExtensionRangeOptions {
    // message fields
    ///  The parser stores options it doesn't recognize here. See above.
    // @@protoc_insertion_point(field:google.protobuf.ExtensionRangeOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.ExtensionRangeOptions.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExtensionRangeOptions {
    fn default() -> &'a ExtensionRangeOptions {
        <ExtensionRangeOptions as crate::Message>::default_instance()
    }
}

impl ExtensionRangeOptions {
    pub fn new() -> ExtensionRangeOptions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &ExtensionRangeOptions| { &m.uninterpreted_option },
            |m: &mut ExtensionRangeOptions| { &mut m.uninterpreted_option },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<ExtensionRangeOptions>(
            "ExtensionRangeOptions",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for ExtensionRangeOptions {
    const NAME: &'static str = "ExtensionRangeOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.uninterpreted_option {
            crate::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExtensionRangeOptions {
        ExtensionRangeOptions::new()
    }

    fn clear(&mut self) {
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExtensionRangeOptions {
        static instance: ExtensionRangeOptions = ExtensionRangeOptions {
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for ExtensionRangeOptions {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExtensionRangeOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExtensionRangeOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for ExtensionRangeOptions {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Describes a field within a message.
// @@protoc_insertion_point(message:google.protobuf.FieldDescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FieldDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.number)
    pub number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.label)
    pub label: ::std::option::Option<crate::EnumOrUnknown<field_descriptor_proto::Label>>,
    ///  If type_name is set, this need not be set.  If both this and type_name
    ///  are set, this must be one of TYPE_ENUM, TYPE_MESSAGE or TYPE_GROUP.
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.type)
    pub type_: ::std::option::Option<crate::EnumOrUnknown<field_descriptor_proto::Type>>,
    ///  For message and enum types, this is the name of the type.  If the name
    ///  starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping
    ///  rules are used to find the type (i.e. first the nested types within this
    ///  message are searched, then within the parent, on up to the root
    ///  namespace).
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.type_name)
    pub type_name: ::std::option::Option<::std::string::String>,
    ///  For extensions, this is the name of the type being extended.  It is
    ///  resolved in the same manner as type_name.
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.extendee)
    pub extendee: ::std::option::Option<::std::string::String>,
    ///  For numeric types, contains the original text representation of the value.
    ///  For booleans, "true" or "false".
    ///  For strings, contains the default text contents (not escaped in any way).
    ///  For bytes, contains the C escaped value.  All bytes >= 128 are escaped.
    ///  TODO(kenton):  Base-64 encode?
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.default_value)
    pub default_value: ::std::option::Option<::std::string::String>,
    ///  If set, gives the index of a oneof in the containing type's oneof_decl
    ///  list.  This field is a member of that oneof.
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.oneof_index)
    pub oneof_index: ::std::option::Option<i32>,
    ///  JSON name of this field. The value is set by protocol compiler. If the
    ///  user has set a "json_name" option on this field, that option's value
    ///  will be used. Otherwise, it's deduced from the field's name by converting
    ///  it to camelCase.
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.json_name)
    pub json_name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.options)
    pub options: crate::MessageField<FieldOptions>,
    ///  If true, this is a proto3 "optional". When a proto3 field is optional, it
    ///  tracks presence regardless of field type.
    ///
    ///  When proto3_optional is true, this field must be belong to a oneof to
    ///  signal to old proto3 clients that presence is tracked for this field. This
    ///  oneof is known as a "synthetic" oneof, and this field must be its sole
    ///  member (each proto3 optional field gets its own synthetic oneof). Synthetic
    ///  oneofs exist in the descriptor only, and do not generate any API. Synthetic
    ///  oneofs must be ordered after all "real" oneofs.
    ///
    ///  For message fields, proto3_optional doesn't create any semantic change,
    ///  since non-repeated message fields always track presence. However it still
    ///  indicates the semantic detail of whether the user wrote "optional" or not.
    ///  This can be useful for round-tripping the .proto file. For consistency we
    ///  give message fields a synthetic oneof also, even though it is not required
    ///  to track presence. This is especially important because the parser can't
    ///  tell if a field is a message or an enum, so it must always create a
    ///  synthetic oneof.
    ///
    ///  Proto2 optional fields do not set this flag, because they already indicate
    ///  optional with `LABEL_OPTIONAL`.
    // @@protoc_insertion_point(field:google.protobuf.FieldDescriptorProto.proto3_optional)
    pub proto3_optional: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FieldDescriptorProto.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FieldDescriptorProto {
    fn default() -> &'a FieldDescriptorProto {
        <FieldDescriptorProto as crate::Message>::default_instance()
    }
}

impl FieldDescriptorProto {
    pub fn new() -> FieldDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 number = 3;

    pub fn number(&self) -> i32 {
        self.number.unwrap_or(0)
    }

    pub fn clear_number(&mut self) {
        self.number = ::std::option::Option::None;
    }

    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i32) {
        self.number = ::std::option::Option::Some(v);
    }

    // optional .google.protobuf.FieldDescriptorProto.Label label = 4;

    pub fn label(&self) -> field_descriptor_proto::Label {
        match self.label {
            Some(e) => e.enum_value_or(field_descriptor_proto::Label::LABEL_OPTIONAL),
            None => field_descriptor_proto::Label::LABEL_OPTIONAL,
        }
    }

    pub fn clear_label(&mut self) {
        self.label = ::std::option::Option::None;
    }

    pub fn has_label(&self) -> bool {
        self.label.is_some()
    }

    // Param is passed by value, moved
    pub fn set_label(&mut self, v: field_descriptor_proto::Label) {
        self.label = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional .google.protobuf.FieldDescriptorProto.Type type = 5;

    pub fn type_(&self) -> field_descriptor_proto::Type {
        match self.type_ {
            Some(e) => e.enum_value_or(field_descriptor_proto::Type::TYPE_DOUBLE),
            None => field_descriptor_proto::Type::TYPE_DOUBLE,
        }
    }

    pub fn clear_type_(&mut self) {
        self.type_ = ::std::option::Option::None;
    }

    pub fn has_type(&self) -> bool {
        self.type_.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type(&mut self, v: field_descriptor_proto::Type) {
        self.type_ = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional string type_name = 6;

    pub fn type_name(&self) -> &str {
        match self.type_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_type_name(&mut self) {
        self.type_name = ::std::option::Option::None;
    }

    pub fn has_type_name(&self) -> bool {
        self.type_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_type_name(&mut self, v: ::std::string::String) {
        self.type_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type_name(&mut self) -> &mut ::std::string::String {
        if self.type_name.is_none() {
            self.type_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.type_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_type_name(&mut self) -> ::std::string::String {
        self.type_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string extendee = 2;

    pub fn extendee(&self) -> &str {
        match self.extendee.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_extendee(&mut self) {
        self.extendee = ::std::option::Option::None;
    }

    pub fn has_extendee(&self) -> bool {
        self.extendee.is_some()
    }

    // Param is passed by value, moved
    pub fn set_extendee(&mut self, v: ::std::string::String) {
        self.extendee = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_extendee(&mut self) -> &mut ::std::string::String {
        if self.extendee.is_none() {
            self.extendee = ::std::option::Option::Some(::std::string::String::new());
        }
        self.extendee.as_mut().unwrap()
    }

    // Take field
    pub fn take_extendee(&mut self) -> ::std::string::String {
        self.extendee.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string default_value = 7;

    pub fn default_value(&self) -> &str {
        match self.default_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_default_value(&mut self) {
        self.default_value = ::std::option::Option::None;
    }

    pub fn has_default_value(&self) -> bool {
        self.default_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_value(&mut self, v: ::std::string::String) {
        self.default_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_value(&mut self) -> &mut ::std::string::String {
        if self.default_value.is_none() {
            self.default_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.default_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_value(&mut self) -> ::std::string::String {
        self.default_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 oneof_index = 9;

    pub fn oneof_index(&self) -> i32 {
        self.oneof_index.unwrap_or(0)
    }

    pub fn clear_oneof_index(&mut self) {
        self.oneof_index = ::std::option::Option::None;
    }

    pub fn has_oneof_index(&self) -> bool {
        self.oneof_index.is_some()
    }

    // Param is passed by value, moved
    pub fn set_oneof_index(&mut self, v: i32) {
        self.oneof_index = ::std::option::Option::Some(v);
    }

    // optional string json_name = 10;

    pub fn json_name(&self) -> &str {
        match self.json_name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_json_name(&mut self) {
        self.json_name = ::std::option::Option::None;
    }

    pub fn has_json_name(&self) -> bool {
        self.json_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_json_name(&mut self, v: ::std::string::String) {
        self.json_name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_json_name(&mut self) -> &mut ::std::string::String {
        if self.json_name.is_none() {
            self.json_name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.json_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_json_name(&mut self) -> ::std::string::String {
        self.json_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool proto3_optional = 17;

    pub fn proto3_optional(&self) -> bool {
        self.proto3_optional.unwrap_or(false)
    }

    pub fn clear_proto3_optional(&mut self) {
        self.proto3_optional = ::std::option::Option::None;
    }

    pub fn has_proto3_optional(&self) -> bool {
        self.proto3_optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_proto3_optional(&mut self, v: bool) {
        self.proto3_optional = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &FieldDescriptorProto| { &m.name },
            |m: &mut FieldDescriptorProto| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "number",
            |m: &FieldDescriptorProto| { &m.number },
            |m: &mut FieldDescriptorProto| { &mut m.number },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "label",
            |m: &FieldDescriptorProto| { &m.label },
            |m: &mut FieldDescriptorProto| { &mut m.label },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "type",
            |m: &FieldDescriptorProto| { &m.type_ },
            |m: &mut FieldDescriptorProto| { &mut m.type_ },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "type_name",
            |m: &FieldDescriptorProto| { &m.type_name },
            |m: &mut FieldDescriptorProto| { &mut m.type_name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "extendee",
            |m: &FieldDescriptorProto| { &m.extendee },
            |m: &mut FieldDescriptorProto| { &mut m.extendee },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "default_value",
            |m: &FieldDescriptorProto| { &m.default_value },
            |m: &mut FieldDescriptorProto| { &mut m.default_value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "oneof_index",
            |m: &FieldDescriptorProto| { &m.oneof_index },
            |m: &mut FieldDescriptorProto| { &mut m.oneof_index },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "json_name",
            |m: &FieldDescriptorProto| { &m.json_name },
            |m: &mut FieldDescriptorProto| { &mut m.json_name },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, FieldOptions>(
            "options",
            |m: &FieldDescriptorProto| { &m.options },
            |m: &mut FieldDescriptorProto| { &mut m.options },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "proto3_optional",
            |m: &FieldDescriptorProto| { &m.proto3_optional },
            |m: &mut FieldDescriptorProto| { &mut m.proto3_optional },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<FieldDescriptorProto>(
            "FieldDescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for FieldDescriptorProto {
    const NAME: &'static str = "FieldDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                24 => {
                    self.number = ::std::option::Option::Some(is.read_int32()?);
                },
                32 => {
                    self.label = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.type_ = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                50 => {
                    self.type_name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.extendee = ::std::option::Option::Some(is.read_string()?);
                },
                58 => {
                    self.default_value = ::std::option::Option::Some(is.read_string()?);
                },
                72 => {
                    self.oneof_index = ::std::option::Option::Some(is.read_int32()?);
                },
                82 => {
                    self.json_name = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                136 => {
                    self.proto3_optional = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.number {
            my_size += crate::rt::int32_size(3, v);
        }
        if let Some(v) = self.label {
            my_size += crate::rt::int32_size(4, v.value());
        }
        if let Some(v) = self.type_ {
            my_size += crate::rt::int32_size(5, v.value());
        }
        if let Some(v) = self.type_name.as_ref() {
            my_size += crate::rt::string_size(6, &v);
        }
        if let Some(v) = self.extendee.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.default_value.as_ref() {
            my_size += crate::rt::string_size(7, &v);
        }
        if let Some(v) = self.oneof_index {
            my_size += crate::rt::int32_size(9, v);
        }
        if let Some(v) = self.json_name.as_ref() {
            my_size += crate::rt::string_size(10, &v);
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.proto3_optional {
            my_size += 2 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.number {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.label {
            os.write_enum(4, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.type_ {
            os.write_enum(5, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.type_name.as_ref() {
            os.write_string(6, v)?;
        }
        if let Some(v) = self.extendee.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.default_value.as_ref() {
            os.write_string(7, v)?;
        }
        if let Some(v) = self.oneof_index {
            os.write_int32(9, v)?;
        }
        if let Some(v) = self.json_name.as_ref() {
            os.write_string(10, v)?;
        }
        if let Some(v) = self.options.as_ref() {
            crate::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.proto3_optional {
            os.write_bool(17, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FieldDescriptorProto {
        FieldDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.number = ::std::option::Option::None;
        self.label = ::std::option::Option::None;
        self.type_ = ::std::option::Option::None;
        self.type_name = ::std::option::Option::None;
        self.extendee = ::std::option::Option::None;
        self.default_value = ::std::option::Option::None;
        self.oneof_index = ::std::option::Option::None;
        self.json_name = ::std::option::Option::None;
        self.options.clear();
        self.proto3_optional = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FieldDescriptorProto {
        static instance: FieldDescriptorProto = FieldDescriptorProto {
            name: ::std::option::Option::None,
            number: ::std::option::Option::None,
            label: ::std::option::Option::None,
            type_: ::std::option::Option::None,
            type_name: ::std::option::Option::None,
            extendee: ::std::option::Option::None,
            default_value: ::std::option::Option::None,
            oneof_index: ::std::option::Option::None,
            json_name: ::std::option::Option::None,
            options: crate::MessageField::none(),
            proto3_optional: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for FieldDescriptorProto {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FieldDescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FieldDescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for FieldDescriptorProto {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FieldDescriptorProto`
pub mod field_descriptor_proto {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.FieldDescriptorProto.Type)
    pub enum Type {
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_DOUBLE)
        TYPE_DOUBLE = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_FLOAT)
        TYPE_FLOAT = 2,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_INT64)
        TYPE_INT64 = 3,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_UINT64)
        TYPE_UINT64 = 4,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_INT32)
        TYPE_INT32 = 5,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_FIXED64)
        TYPE_FIXED64 = 6,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_FIXED32)
        TYPE_FIXED32 = 7,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_BOOL)
        TYPE_BOOL = 8,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_STRING)
        TYPE_STRING = 9,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_GROUP)
        TYPE_GROUP = 10,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_MESSAGE)
        TYPE_MESSAGE = 11,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_BYTES)
        TYPE_BYTES = 12,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_UINT32)
        TYPE_UINT32 = 13,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_ENUM)
        TYPE_ENUM = 14,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_SFIXED32)
        TYPE_SFIXED32 = 15,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_SFIXED64)
        TYPE_SFIXED64 = 16,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_SINT32)
        TYPE_SINT32 = 17,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Type.TYPE_SINT64)
        TYPE_SINT64 = 18,
    }

    impl crate::Enum for Type {
        const NAME: &'static str = "Type";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Type> {
            match value {
                1 => ::std::option::Option::Some(Type::TYPE_DOUBLE),
                2 => ::std::option::Option::Some(Type::TYPE_FLOAT),
                3 => ::std::option::Option::Some(Type::TYPE_INT64),
                4 => ::std::option::Option::Some(Type::TYPE_UINT64),
                5 => ::std::option::Option::Some(Type::TYPE_INT32),
                6 => ::std::option::Option::Some(Type::TYPE_FIXED64),
                7 => ::std::option::Option::Some(Type::TYPE_FIXED32),
                8 => ::std::option::Option::Some(Type::TYPE_BOOL),
                9 => ::std::option::Option::Some(Type::TYPE_STRING),
                10 => ::std::option::Option::Some(Type::TYPE_GROUP),
                11 => ::std::option::Option::Some(Type::TYPE_MESSAGE),
                12 => ::std::option::Option::Some(Type::TYPE_BYTES),
                13 => ::std::option::Option::Some(Type::TYPE_UINT32),
                14 => ::std::option::Option::Some(Type::TYPE_ENUM),
                15 => ::std::option::Option::Some(Type::TYPE_SFIXED32),
                16 => ::std::option::Option::Some(Type::TYPE_SFIXED64),
                17 => ::std::option::Option::Some(Type::TYPE_SINT32),
                18 => ::std::option::Option::Some(Type::TYPE_SINT64),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Type> {
            match str {
                "TYPE_DOUBLE" => ::std::option::Option::Some(Type::TYPE_DOUBLE),
                "TYPE_FLOAT" => ::std::option::Option::Some(Type::TYPE_FLOAT),
                "TYPE_INT64" => ::std::option::Option::Some(Type::TYPE_INT64),
                "TYPE_UINT64" => ::std::option::Option::Some(Type::TYPE_UINT64),
                "TYPE_INT32" => ::std::option::Option::Some(Type::TYPE_INT32),
                "TYPE_FIXED64" => ::std::option::Option::Some(Type::TYPE_FIXED64),
                "TYPE_FIXED32" => ::std::option::Option::Some(Type::TYPE_FIXED32),
                "TYPE_BOOL" => ::std::option::Option::Some(Type::TYPE_BOOL),
                "TYPE_STRING" => ::std::option::Option::Some(Type::TYPE_STRING),
                "TYPE_GROUP" => ::std::option::Option::Some(Type::TYPE_GROUP),
                "TYPE_MESSAGE" => ::std::option::Option::Some(Type::TYPE_MESSAGE),
                "TYPE_BYTES" => ::std::option::Option::Some(Type::TYPE_BYTES),
                "TYPE_UINT32" => ::std::option::Option::Some(Type::TYPE_UINT32),
                "TYPE_ENUM" => ::std::option::Option::Some(Type::TYPE_ENUM),
                "TYPE_SFIXED32" => ::std::option::Option::Some(Type::TYPE_SFIXED32),
                "TYPE_SFIXED64" => ::std::option::Option::Some(Type::TYPE_SFIXED64),
                "TYPE_SINT32" => ::std::option::Option::Some(Type::TYPE_SINT32),
                "TYPE_SINT64" => ::std::option::Option::Some(Type::TYPE_SINT64),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Type] = &[
            Type::TYPE_DOUBLE,
            Type::TYPE_FLOAT,
            Type::TYPE_INT64,
            Type::TYPE_UINT64,
            Type::TYPE_INT32,
            Type::TYPE_FIXED64,
            Type::TYPE_FIXED32,
            Type::TYPE_BOOL,
            Type::TYPE_STRING,
            Type::TYPE_GROUP,
            Type::TYPE_MESSAGE,
            Type::TYPE_BYTES,
            Type::TYPE_UINT32,
            Type::TYPE_ENUM,
            Type::TYPE_SFIXED32,
            Type::TYPE_SFIXED64,
            Type::TYPE_SINT32,
            Type::TYPE_SINT64,
        ];
    }

    impl crate::EnumFull for Type {
        fn enum_descriptor() -> crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("FieldDescriptorProto.Type").unwrap()).clone()
        }

        fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
            let index = match self {
                Type::TYPE_DOUBLE => 0,
                Type::TYPE_FLOAT => 1,
                Type::TYPE_INT64 => 2,
                Type::TYPE_UINT64 => 3,
                Type::TYPE_INT32 => 4,
                Type::TYPE_FIXED64 => 5,
                Type::TYPE_FIXED32 => 6,
                Type::TYPE_BOOL => 7,
                Type::TYPE_STRING => 8,
                Type::TYPE_GROUP => 9,
                Type::TYPE_MESSAGE => 10,
                Type::TYPE_BYTES => 11,
                Type::TYPE_UINT32 => 12,
                Type::TYPE_ENUM => 13,
                Type::TYPE_SFIXED32 => 14,
                Type::TYPE_SFIXED64 => 15,
                Type::TYPE_SINT32 => 16,
                Type::TYPE_SINT64 => 17,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Type {
        fn default() -> Self {
            Type::TYPE_DOUBLE
        }
    }

    impl Type {
        pub(in super) fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
            crate::reflect::GeneratedEnumDescriptorData::new::<Type>("FieldDescriptorProto.Type")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.FieldDescriptorProto.Label)
    pub enum Label {
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Label.LABEL_OPTIONAL)
        LABEL_OPTIONAL = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Label.LABEL_REQUIRED)
        LABEL_REQUIRED = 2,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldDescriptorProto.Label.LABEL_REPEATED)
        LABEL_REPEATED = 3,
    }

    impl crate::Enum for Label {
        const NAME: &'static str = "Label";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Label> {
            match value {
                1 => ::std::option::Option::Some(Label::LABEL_OPTIONAL),
                2 => ::std::option::Option::Some(Label::LABEL_REQUIRED),
                3 => ::std::option::Option::Some(Label::LABEL_REPEATED),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<Label> {
            match str {
                "LABEL_OPTIONAL" => ::std::option::Option::Some(Label::LABEL_OPTIONAL),
                "LABEL_REQUIRED" => ::std::option::Option::Some(Label::LABEL_REQUIRED),
                "LABEL_REPEATED" => ::std::option::Option::Some(Label::LABEL_REPEATED),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [Label] = &[
            Label::LABEL_OPTIONAL,
            Label::LABEL_REQUIRED,
            Label::LABEL_REPEATED,
        ];
    }

    impl crate::EnumFull for Label {
        fn enum_descriptor() -> crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("FieldDescriptorProto.Label").unwrap()).clone()
        }

        fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
            let index = match self {
                Label::LABEL_OPTIONAL => 0,
                Label::LABEL_REQUIRED => 1,
                Label::LABEL_REPEATED => 2,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for Label {
        fn default() -> Self {
            Label::LABEL_OPTIONAL
        }
    }

    impl Label {
        pub(in super) fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
            crate::reflect::GeneratedEnumDescriptorData::new::<Label>("FieldDescriptorProto.Label")
        }
    }
}

///  Describes a oneof.
// @@protoc_insertion_point(message:google.protobuf.OneofDescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OneofDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.OneofDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.OneofDescriptorProto.options)
    pub options: crate::MessageField<OneofOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.OneofDescriptorProto.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OneofDescriptorProto {
    fn default() -> &'a OneofDescriptorProto {
        <OneofDescriptorProto as crate::Message>::default_instance()
    }
}

impl OneofDescriptorProto {
    pub fn new() -> OneofDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &OneofDescriptorProto| { &m.name },
            |m: &mut OneofDescriptorProto| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, OneofOptions>(
            "options",
            |m: &OneofDescriptorProto| { &m.options },
            |m: &mut OneofDescriptorProto| { &mut m.options },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<OneofDescriptorProto>(
            "OneofDescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for OneofDescriptorProto {
    const NAME: &'static str = "OneofDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.options.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OneofDescriptorProto {
        OneofDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OneofDescriptorProto {
        static instance: OneofDescriptorProto = OneofDescriptorProto {
            name: ::std::option::Option::None,
            options: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for OneofDescriptorProto {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OneofDescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OneofDescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for OneofDescriptorProto {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Describes an enum type.
// @@protoc_insertion_point(message:google.protobuf.EnumDescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnumDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.value)
    pub value: ::std::vec::Vec<EnumValueDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.options)
    pub options: crate::MessageField<EnumOptions>,
    ///  Range of reserved numeric values. Reserved numeric values may not be used
    ///  by enum values in the same enum declaration. Reserved ranges may not
    ///  overlap.
    // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.reserved_range)
    pub reserved_range: ::std::vec::Vec<enum_descriptor_proto::EnumReservedRange>,
    ///  Reserved enum value names, which may not be reused. A given name may only
    ///  be reserved once.
    // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.reserved_name)
    pub reserved_name: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.EnumDescriptorProto.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnumDescriptorProto {
    fn default() -> &'a EnumDescriptorProto {
        <EnumDescriptorProto as crate::Message>::default_instance()
    }
}

impl EnumDescriptorProto {
    pub fn new() -> EnumDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &EnumDescriptorProto| { &m.name },
            |m: &mut EnumDescriptorProto| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "value",
            |m: &EnumDescriptorProto| { &m.value },
            |m: &mut EnumDescriptorProto| { &mut m.value },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, EnumOptions>(
            "options",
            |m: &EnumDescriptorProto| { &m.options },
            |m: &mut EnumDescriptorProto| { &mut m.options },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reserved_range",
            |m: &EnumDescriptorProto| { &m.reserved_range },
            |m: &mut EnumDescriptorProto| { &mut m.reserved_range },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "reserved_name",
            |m: &EnumDescriptorProto| { &m.reserved_name },
            |m: &mut EnumDescriptorProto| { &mut m.reserved_name },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<EnumDescriptorProto>(
            "EnumDescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for EnumDescriptorProto {
    const NAME: &'static str = "EnumDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.reserved_range {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.value.push(is.read_message()?);
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                34 => {
                    self.reserved_range.push(is.read_message()?);
                },
                42 => {
                    self.reserved_name.push(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        for value in &self.value {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.reserved_range {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.reserved_name {
            my_size += crate::rt::string_size(5, &value);
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.value {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.options.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        for v in &self.reserved_range {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        for v in &self.reserved_name {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnumDescriptorProto {
        EnumDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.value.clear();
        self.options.clear();
        self.reserved_range.clear();
        self.reserved_name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnumDescriptorProto {
        static instance: EnumDescriptorProto = EnumDescriptorProto {
            name: ::std::option::Option::None,
            value: ::std::vec::Vec::new(),
            options: crate::MessageField::none(),
            reserved_range: ::std::vec::Vec::new(),
            reserved_name: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for EnumDescriptorProto {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnumDescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnumDescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for EnumDescriptorProto {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `EnumDescriptorProto`
pub mod enum_descriptor_proto {
    ///  Range of reserved numeric values. Reserved values may not be used by
    ///  entries in the same enum. Reserved ranges may not overlap.
    ///
    ///  Note that this is distinct from DescriptorProto.ReservedRange in that it
    ///  is inclusive such that it can appropriately represent the entire int32
    ///  domain.
    // @@protoc_insertion_point(message:google.protobuf.EnumDescriptorProto.EnumReservedRange)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct EnumReservedRange {
        // message fields
        // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.EnumReservedRange.start)
        pub start: ::std::option::Option<i32>,
        // @@protoc_insertion_point(field:google.protobuf.EnumDescriptorProto.EnumReservedRange.end)
        pub end: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.EnumDescriptorProto.EnumReservedRange.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a EnumReservedRange {
        fn default() -> &'a EnumReservedRange {
            <EnumReservedRange as crate::Message>::default_instance()
        }
    }

    impl EnumReservedRange {
        pub fn new() -> EnumReservedRange {
            ::std::default::Default::default()
        }

        // optional int32 start = 1;

        pub fn start(&self) -> i32 {
            self.start.unwrap_or(0)
        }

        pub fn clear_start(&mut self) {
            self.start = ::std::option::Option::None;
        }

        pub fn has_start(&self) -> bool {
            self.start.is_some()
        }

        // Param is passed by value, moved
        pub fn set_start(&mut self, v: i32) {
            self.start = ::std::option::Option::Some(v);
        }

        // optional int32 end = 2;

        pub fn end(&self) -> i32 {
            self.end.unwrap_or(0)
        }

        pub fn clear_end(&mut self) {
            self.end = ::std::option::Option::None;
        }

        pub fn has_end(&self) -> bool {
            self.end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end(&mut self, v: i32) {
            self.end = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "start",
                |m: &EnumReservedRange| { &m.start },
                |m: &mut EnumReservedRange| { &mut m.start },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "end",
                |m: &EnumReservedRange| { &m.end },
                |m: &mut EnumReservedRange| { &mut m.end },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<EnumReservedRange>(
                "EnumDescriptorProto.EnumReservedRange",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for EnumReservedRange {
        const NAME: &'static str = "EnumReservedRange";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    8 => {
                        self.start = ::std::option::Option::Some(is.read_int32()?);
                    },
                    16 => {
                        self.end = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.start {
                my_size += crate::rt::int32_size(1, v);
            }
            if let Some(v) = self.end {
                my_size += crate::rt::int32_size(2, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.start {
                os.write_int32(1, v)?;
            }
            if let Some(v) = self.end {
                os.write_int32(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> EnumReservedRange {
            EnumReservedRange::new()
        }

        fn clear(&mut self) {
            self.start = ::std::option::Option::None;
            self.end = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static EnumReservedRange {
            static instance: EnumReservedRange = EnumReservedRange {
                start: ::std::option::Option::None,
                end: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for EnumReservedRange {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("EnumDescriptorProto.EnumReservedRange").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for EnumReservedRange {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for EnumReservedRange {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

///  Describes a value within an enum.
// @@protoc_insertion_point(message:google.protobuf.EnumValueDescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnumValueDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.EnumValueDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.EnumValueDescriptorProto.number)
    pub number: ::std::option::Option<i32>,
    // @@protoc_insertion_point(field:google.protobuf.EnumValueDescriptorProto.options)
    pub options: crate::MessageField<EnumValueOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.EnumValueDescriptorProto.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnumValueDescriptorProto {
    fn default() -> &'a EnumValueDescriptorProto {
        <EnumValueDescriptorProto as crate::Message>::default_instance()
    }
}

impl EnumValueDescriptorProto {
    pub fn new() -> EnumValueDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 number = 2;

    pub fn number(&self) -> i32 {
        self.number.unwrap_or(0)
    }

    pub fn clear_number(&mut self) {
        self.number = ::std::option::Option::None;
    }

    pub fn has_number(&self) -> bool {
        self.number.is_some()
    }

    // Param is passed by value, moved
    pub fn set_number(&mut self, v: i32) {
        self.number = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &EnumValueDescriptorProto| { &m.name },
            |m: &mut EnumValueDescriptorProto| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "number",
            |m: &EnumValueDescriptorProto| { &m.number },
            |m: &mut EnumValueDescriptorProto| { &mut m.number },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, EnumValueOptions>(
            "options",
            |m: &EnumValueDescriptorProto| { &m.options },
            |m: &mut EnumValueDescriptorProto| { &mut m.options },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<EnumValueDescriptorProto>(
            "EnumValueDescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for EnumValueDescriptorProto {
    const NAME: &'static str = "EnumValueDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                16 => {
                    self.number = ::std::option::Option::Some(is.read_int32()?);
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.number {
            my_size += crate::rt::int32_size(2, v);
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.number {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.options.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnumValueDescriptorProto {
        EnumValueDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.number = ::std::option::Option::None;
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnumValueDescriptorProto {
        static instance: EnumValueDescriptorProto = EnumValueDescriptorProto {
            name: ::std::option::Option::None,
            number: ::std::option::Option::None,
            options: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for EnumValueDescriptorProto {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnumValueDescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnumValueDescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for EnumValueDescriptorProto {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Describes a service.
// @@protoc_insertion_point(message:google.protobuf.ServiceDescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.ServiceDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.ServiceDescriptorProto.method)
    pub method: ::std::vec::Vec<MethodDescriptorProto>,
    // @@protoc_insertion_point(field:google.protobuf.ServiceDescriptorProto.options)
    pub options: crate::MessageField<ServiceOptions>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.ServiceDescriptorProto.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceDescriptorProto {
    fn default() -> &'a ServiceDescriptorProto {
        <ServiceDescriptorProto as crate::Message>::default_instance()
    }
}

impl ServiceDescriptorProto {
    pub fn new() -> ServiceDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &ServiceDescriptorProto| { &m.name },
            |m: &mut ServiceDescriptorProto| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "method",
            |m: &ServiceDescriptorProto| { &m.method },
            |m: &mut ServiceDescriptorProto| { &mut m.method },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, ServiceOptions>(
            "options",
            |m: &ServiceDescriptorProto| { &m.options },
            |m: &mut ServiceDescriptorProto| { &mut m.options },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<ServiceDescriptorProto>(
            "ServiceDescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for ServiceDescriptorProto {
    const NAME: &'static str = "ServiceDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.method {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.method.push(is.read_message()?);
                },
                26 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        for value in &self.method {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        for v in &self.method {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.options.as_ref() {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceDescriptorProto {
        ServiceDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.method.clear();
        self.options.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceDescriptorProto {
        static instance: ServiceDescriptorProto = ServiceDescriptorProto {
            name: ::std::option::Option::None,
            method: ::std::vec::Vec::new(),
            options: crate::MessageField::none(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for ServiceDescriptorProto {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceDescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceDescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for ServiceDescriptorProto {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

///  Describes a method of a service.
// @@protoc_insertion_point(message:google.protobuf.MethodDescriptorProto)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MethodDescriptorProto {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.name)
    pub name: ::std::option::Option<::std::string::String>,
    ///  Input and output type names.  These are resolved in the same way as
    ///  FieldDescriptorProto.type_name, but must refer to a message type.
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.input_type)
    pub input_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.output_type)
    pub output_type: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.options)
    pub options: crate::MessageField<MethodOptions>,
    ///  Identifies if client streams multiple client messages
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.client_streaming)
    pub client_streaming: ::std::option::Option<bool>,
    ///  Identifies if server streams multiple server messages
    // @@protoc_insertion_point(field:google.protobuf.MethodDescriptorProto.server_streaming)
    pub server_streaming: ::std::option::Option<bool>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.MethodDescriptorProto.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MethodDescriptorProto {
    fn default() -> &'a MethodDescriptorProto {
        <MethodDescriptorProto as crate::Message>::default_instance()
    }
}

impl MethodDescriptorProto {
    pub fn new() -> MethodDescriptorProto {
        ::std::default::Default::default()
    }

    // optional string name = 1;

    pub fn name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_name(&mut self) {
        self.name = ::std::option::Option::None;
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name = ::std::option::Option::Some(::std::string::String::new());
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string input_type = 2;

    pub fn input_type(&self) -> &str {
        match self.input_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_input_type(&mut self) {
        self.input_type = ::std::option::Option::None;
    }

    pub fn has_input_type(&self) -> bool {
        self.input_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_type(&mut self, v: ::std::string::String) {
        self.input_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_type(&mut self) -> &mut ::std::string::String {
        if self.input_type.is_none() {
            self.input_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.input_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_type(&mut self) -> ::std::string::String {
        self.input_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string output_type = 3;

    pub fn output_type(&self) -> &str {
        match self.output_type.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_output_type(&mut self) {
        self.output_type = ::std::option::Option::None;
    }

    pub fn has_output_type(&self) -> bool {
        self.output_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_type(&mut self, v: ::std::string::String) {
        self.output_type = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_type(&mut self) -> &mut ::std::string::String {
        if self.output_type.is_none() {
            self.output_type = ::std::option::Option::Some(::std::string::String::new());
        }
        self.output_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_type(&mut self) -> ::std::string::String {
        self.output_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool client_streaming = 5;

    pub fn client_streaming(&self) -> bool {
        self.client_streaming.unwrap_or(false)
    }

    pub fn clear_client_streaming(&mut self) {
        self.client_streaming = ::std::option::Option::None;
    }

    pub fn has_client_streaming(&self) -> bool {
        self.client_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_streaming(&mut self, v: bool) {
        self.client_streaming = ::std::option::Option::Some(v);
    }

    // optional bool server_streaming = 6;

    pub fn server_streaming(&self) -> bool {
        self.server_streaming.unwrap_or(false)
    }

    pub fn clear_server_streaming(&mut self) {
        self.server_streaming = ::std::option::Option::None;
    }

    pub fn has_server_streaming(&self) -> bool {
        self.server_streaming.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_streaming(&mut self, v: bool) {
        self.server_streaming = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "name",
            |m: &MethodDescriptorProto| { &m.name },
            |m: &mut MethodDescriptorProto| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "input_type",
            |m: &MethodDescriptorProto| { &m.input_type },
            |m: &mut MethodDescriptorProto| { &mut m.input_type },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "output_type",
            |m: &MethodDescriptorProto| { &m.output_type },
            |m: &mut MethodDescriptorProto| { &mut m.output_type },
        ));
        fields.push(crate::reflect::rt::v2::make_message_field_accessor::<_, MethodOptions>(
            "options",
            |m: &MethodDescriptorProto| { &m.options },
            |m: &mut MethodDescriptorProto| { &mut m.options },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "client_streaming",
            |m: &MethodDescriptorProto| { &m.client_streaming },
            |m: &mut MethodDescriptorProto| { &mut m.client_streaming },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "server_streaming",
            |m: &MethodDescriptorProto| { &m.server_streaming },
            |m: &mut MethodDescriptorProto| { &mut m.server_streaming },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<MethodDescriptorProto>(
            "MethodDescriptorProto",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for MethodDescriptorProto {
    const NAME: &'static str = "MethodDescriptorProto";

    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = ::std::option::Option::Some(is.read_string()?);
                },
                18 => {
                    self.input_type = ::std::option::Option::Some(is.read_string()?);
                },
                26 => {
                    self.output_type = ::std::option::Option::Some(is.read_string()?);
                },
                34 => {
                    crate::rt::read_singular_message_into_field(is, &mut self.options)?;
                },
                40 => {
                    self.client_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.server_streaming = ::std::option::Option::Some(is.read_bool()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.name.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.input_type.as_ref() {
            my_size += crate::rt::string_size(2, &v);
        }
        if let Some(v) = self.output_type.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.client_streaming {
            my_size += 1 + 1;
        }
        if let Some(v) = self.server_streaming {
            my_size += 1 + 1;
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.name.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.input_type.as_ref() {
            os.write_string(2, v)?;
        }
        if let Some(v) = self.output_type.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.options.as_ref() {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.client_streaming {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.server_streaming {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MethodDescriptorProto {
        MethodDescriptorProto::new()
    }

    fn clear(&mut self) {
        self.name = ::std::option::Option::None;
        self.input_type = ::std::option::Option::None;
        self.output_type = ::std::option::Option::None;
        self.options.clear();
        self.client_streaming = ::std::option::Option::None;
        self.server_streaming = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MethodDescriptorProto {
        static instance: MethodDescriptorProto = MethodDescriptorProto {
            name: ::std::option::Option::None,
            input_type: ::std::option::Option::None,
            output_type: ::std::option::Option::None,
            options: crate::MessageField::none(),
            client_streaming: ::std::option::Option::None,
            server_streaming: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for MethodDescriptorProto {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MethodDescriptorProto").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MethodDescriptorProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for MethodDescriptorProto {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.FileOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FileOptions {
    // message fields
    ///  Sets the Java package where classes generated from this .proto will be
    ///  placed.  By default, the proto package is used, but this is often
    ///  inappropriate because proto packages do not normally start with backwards
    ///  domain names.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_package)
    pub java_package: ::std::option::Option<::std::string::String>,
    ///  Controls the name of the wrapper Java class generated for the .proto file.
    ///  That class will always contain the .proto file's getDescriptor() method as
    ///  well as any top-level extensions defined in the .proto file.
    ///  If java_multiple_files is disabled, then all the other classes from the
    ///  .proto file will be nested inside the single wrapper outer class.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_outer_classname)
    pub java_outer_classname: ::std::option::Option<::std::string::String>,
    ///  If enabled, then the Java code generator will generate a separate .java
    ///  file for each top-level message, enum, and service defined in the .proto
    ///  file.  Thus, these types will *not* be nested inside the wrapper class
    ///  named by java_outer_classname.  However, the wrapper class will still be
    ///  generated to contain the file's getDescriptor() method as well as any
    ///  top-level extensions defined in the file.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_multiple_files)
    pub java_multiple_files: ::std::option::Option<bool>,
    ///  This option does nothing.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_generate_equals_and_hash)
    pub java_generate_equals_and_hash: ::std::option::Option<bool>,
    ///  If set true, then the Java2 code generator will generate code that
    ///  throws an exception whenever an attempt is made to assign a non-UTF-8
    ///  byte sequence to a string field.
    ///  Message reflection will do the same.
    ///  However, an extension field still accepts non-UTF-8 byte sequences.
    ///  This option has no effect on when used with the lite runtime.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_string_check_utf8)
    pub java_string_check_utf8: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.optimize_for)
    pub optimize_for: ::std::option::Option<crate::EnumOrUnknown<file_options::OptimizeMode>>,
    ///  Sets the Go package where structs generated from this .proto will be
    ///  placed. If omitted, the Go package will be derived from the following:
    ///    - The basename of the package import path, if provided.
    ///    - Otherwise, the package statement in the .proto file, if present.
    ///    - Otherwise, the basename of the .proto file, without extension.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.go_package)
    pub go_package: ::std::option::Option<::std::string::String>,
    ///  Should generic services be generated in each language?  "Generic" services
    ///  are not specific to any particular RPC system.  They are generated by the
    ///  main code generators in each language (without additional plugins).
    ///  Generic services were the only kind of service generation supported by
    ///  early versions of google.protobuf.
    ///
    ///  Generic services are now considered deprecated in favor of using plugins
    ///  that generate code specific to your particular RPC system.  Therefore,
    ///  these default to false.  Old code which depends on generic services should
    ///  explicitly set them to true.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.cc_generic_services)
    pub cc_generic_services: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.java_generic_services)
    pub java_generic_services: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.py_generic_services)
    pub py_generic_services: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.php_generic_services)
    pub php_generic_services: ::std::option::Option<bool>,
    ///  Is this file deprecated?
    ///  Depending on the target platform, this can emit Deprecated annotations
    ///  for everything in the file, or it will be completely ignored; in the very
    ///  least, this is a formalization for deprecating files.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    ///  Enables the use of arenas for the proto messages in this file. This applies
    ///  only to generated classes for C++.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.cc_enable_arenas)
    pub cc_enable_arenas: ::std::option::Option<bool>,
    ///  Sets the objective c class prefix which is prepended to all objective c
    ///  generated classes from this .proto. There is no default.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.objc_class_prefix)
    pub objc_class_prefix: ::std::option::Option<::std::string::String>,
    ///  Namespace for generated classes; defaults to the package.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.csharp_namespace)
    pub csharp_namespace: ::std::option::Option<::std::string::String>,
    ///  By default Swift generators will take the proto package and CamelCase it
    ///  replacing '.' with underscore and use that to prefix the types/symbols
    ///  defined. When this options is provided, they will use this value instead
    ///  to prefix the types/symbols defined.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.swift_prefix)
    pub swift_prefix: ::std::option::Option<::std::string::String>,
    ///  Sets the php class prefix which is prepended to all php generated classes
    ///  from this .proto. Default is empty.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.php_class_prefix)
    pub php_class_prefix: ::std::option::Option<::std::string::String>,
    ///  Use this option to change the namespace of php generated classes. Default
    ///  is empty. When this option is empty, the package name will be used for
    ///  determining the namespace.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.php_namespace)
    pub php_namespace: ::std::option::Option<::std::string::String>,
    ///  Use this option to change the namespace of php generated metadata classes.
    ///  Default is empty. When this option is empty, the proto file name will be
    ///  used for determining the namespace.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.php_metadata_namespace)
    pub php_metadata_namespace: ::std::option::Option<::std::string::String>,
    ///  Use this option to change the package of ruby generated classes. Default
    ///  is empty. When this option is not set, the package name will be used for
    ///  determining the ruby package.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.ruby_package)
    pub ruby_package: ::std::option::Option<::std::string::String>,
    ///  The parser stores options it doesn't recognize here.
    ///  See the documentation for the "Options" section above.
    // @@protoc_insertion_point(field:google.protobuf.FileOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FileOptions.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FileOptions {
    fn default() -> &'a FileOptions {
        <FileOptions as crate::Message>::default_instance()
    }
}

impl FileOptions {
    pub fn new() -> FileOptions {
        ::std::default::Default::default()
    }

    // optional string java_package = 1;

    pub fn java_package(&self) -> &str {
        match self.java_package.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_java_package(&mut self) {
        self.java_package = ::std::option::Option::None;
    }

    pub fn has_java_package(&self) -> bool {
        self.java_package.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_package(&mut self, v: ::std::string::String) {
        self.java_package = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_java_package(&mut self) -> &mut ::std::string::String {
        if self.java_package.is_none() {
            self.java_package = ::std::option::Option::Some(::std::string::String::new());
        }
        self.java_package.as_mut().unwrap()
    }

    // Take field
    pub fn take_java_package(&mut self) -> ::std::string::String {
        self.java_package.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string java_outer_classname = 8;

    pub fn java_outer_classname(&self) -> &str {
        match self.java_outer_classname.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_java_outer_classname(&mut self) {
        self.java_outer_classname = ::std::option::Option::None;
    }

    pub fn has_java_outer_classname(&self) -> bool {
        self.java_outer_classname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_outer_classname(&mut self, v: ::std::string::String) {
        self.java_outer_classname = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_java_outer_classname(&mut self) -> &mut ::std::string::String {
        if self.java_outer_classname.is_none() {
            self.java_outer_classname = ::std::option::Option::Some(::std::string::String::new());
        }
        self.java_outer_classname.as_mut().unwrap()
    }

    // Take field
    pub fn take_java_outer_classname(&mut self) -> ::std::string::String {
        self.java_outer_classname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool java_multiple_files = 10;

    pub fn java_multiple_files(&self) -> bool {
        self.java_multiple_files.unwrap_or(false)
    }

    pub fn clear_java_multiple_files(&mut self) {
        self.java_multiple_files = ::std::option::Option::None;
    }

    pub fn has_java_multiple_files(&self) -> bool {
        self.java_multiple_files.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_multiple_files(&mut self, v: bool) {
        self.java_multiple_files = ::std::option::Option::Some(v);
    }

    // optional bool java_generate_equals_and_hash = 20;

    pub fn java_generate_equals_and_hash(&self) -> bool {
        self.java_generate_equals_and_hash.unwrap_or(false)
    }

    pub fn clear_java_generate_equals_and_hash(&mut self) {
        self.java_generate_equals_and_hash = ::std::option::Option::None;
    }

    pub fn has_java_generate_equals_and_hash(&self) -> bool {
        self.java_generate_equals_and_hash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_generate_equals_and_hash(&mut self, v: bool) {
        self.java_generate_equals_and_hash = ::std::option::Option::Some(v);
    }

    // optional bool java_string_check_utf8 = 27;

    pub fn java_string_check_utf8(&self) -> bool {
        self.java_string_check_utf8.unwrap_or(false)
    }

    pub fn clear_java_string_check_utf8(&mut self) {
        self.java_string_check_utf8 = ::std::option::Option::None;
    }

    pub fn has_java_string_check_utf8(&self) -> bool {
        self.java_string_check_utf8.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_string_check_utf8(&mut self, v: bool) {
        self.java_string_check_utf8 = ::std::option::Option::Some(v);
    }

    // optional .google.protobuf.FileOptions.OptimizeMode optimize_for = 9;

    pub fn optimize_for(&self) -> file_options::OptimizeMode {
        match self.optimize_for {
            Some(e) => e.enum_value_or(file_options::OptimizeMode::SPEED),
            None => file_options::OptimizeMode::SPEED,
        }
    }

    pub fn clear_optimize_for(&mut self) {
        self.optimize_for = ::std::option::Option::None;
    }

    pub fn has_optimize_for(&self) -> bool {
        self.optimize_for.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optimize_for(&mut self, v: file_options::OptimizeMode) {
        self.optimize_for = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional string go_package = 11;

    pub fn go_package(&self) -> &str {
        match self.go_package.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_go_package(&mut self) {
        self.go_package = ::std::option::Option::None;
    }

    pub fn has_go_package(&self) -> bool {
        self.go_package.is_some()
    }

    // Param is passed by value, moved
    pub fn set_go_package(&mut self, v: ::std::string::String) {
        self.go_package = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_go_package(&mut self) -> &mut ::std::string::String {
        if self.go_package.is_none() {
            self.go_package = ::std::option::Option::Some(::std::string::String::new());
        }
        self.go_package.as_mut().unwrap()
    }

    // Take field
    pub fn take_go_package(&mut self) -> ::std::string::String {
        self.go_package.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool cc_generic_services = 16;

    pub fn cc_generic_services(&self) -> bool {
        self.cc_generic_services.unwrap_or(false)
    }

    pub fn clear_cc_generic_services(&mut self) {
        self.cc_generic_services = ::std::option::Option::None;
    }

    pub fn has_cc_generic_services(&self) -> bool {
        self.cc_generic_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cc_generic_services(&mut self, v: bool) {
        self.cc_generic_services = ::std::option::Option::Some(v);
    }

    // optional bool java_generic_services = 17;

    pub fn java_generic_services(&self) -> bool {
        self.java_generic_services.unwrap_or(false)
    }

    pub fn clear_java_generic_services(&mut self) {
        self.java_generic_services = ::std::option::Option::None;
    }

    pub fn has_java_generic_services(&self) -> bool {
        self.java_generic_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_java_generic_services(&mut self, v: bool) {
        self.java_generic_services = ::std::option::Option::Some(v);
    }

    // optional bool py_generic_services = 18;

    pub fn py_generic_services(&self) -> bool {
        self.py_generic_services.unwrap_or(false)
    }

    pub fn clear_py_generic_services(&mut self) {
        self.py_generic_services = ::std::option::Option::None;
    }

    pub fn has_py_generic_services(&self) -> bool {
        self.py_generic_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_py_generic_services(&mut self, v: bool) {
        self.py_generic_services = ::std::option::Option::Some(v);
    }

    // optional bool php_generic_services = 42;

    pub fn php_generic_services(&self) -> bool {
        self.php_generic_services.unwrap_or(false)
    }

    pub fn clear_php_generic_services(&mut self) {
        self.php_generic_services = ::std::option::Option::None;
    }

    pub fn has_php_generic_services(&self) -> bool {
        self.php_generic_services.is_some()
    }

    // Param is passed by value, moved
    pub fn set_php_generic_services(&mut self, v: bool) {
        self.php_generic_services = ::std::option::Option::Some(v);
    }

    // optional bool deprecated = 23;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    // optional bool cc_enable_arenas = 31;

    pub fn cc_enable_arenas(&self) -> bool {
        self.cc_enable_arenas.unwrap_or(true)
    }

    pub fn clear_cc_enable_arenas(&mut self) {
        self.cc_enable_arenas = ::std::option::Option::None;
    }

    pub fn has_cc_enable_arenas(&self) -> bool {
        self.cc_enable_arenas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cc_enable_arenas(&mut self, v: bool) {
        self.cc_enable_arenas = ::std::option::Option::Some(v);
    }

    // optional string objc_class_prefix = 36;

    pub fn objc_class_prefix(&self) -> &str {
        match self.objc_class_prefix.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_objc_class_prefix(&mut self) {
        self.objc_class_prefix = ::std::option::Option::None;
    }

    pub fn has_objc_class_prefix(&self) -> bool {
        self.objc_class_prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_objc_class_prefix(&mut self, v: ::std::string::String) {
        self.objc_class_prefix = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_objc_class_prefix(&mut self) -> &mut ::std::string::String {
        if self.objc_class_prefix.is_none() {
            self.objc_class_prefix = ::std::option::Option::Some(::std::string::String::new());
        }
        self.objc_class_prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_objc_class_prefix(&mut self) -> ::std::string::String {
        self.objc_class_prefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string csharp_namespace = 37;

    pub fn csharp_namespace(&self) -> &str {
        match self.csharp_namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_csharp_namespace(&mut self) {
        self.csharp_namespace = ::std::option::Option::None;
    }

    pub fn has_csharp_namespace(&self) -> bool {
        self.csharp_namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_csharp_namespace(&mut self, v: ::std::string::String) {
        self.csharp_namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_csharp_namespace(&mut self) -> &mut ::std::string::String {
        if self.csharp_namespace.is_none() {
            self.csharp_namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.csharp_namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_csharp_namespace(&mut self) -> ::std::string::String {
        self.csharp_namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string swift_prefix = 39;

    pub fn swift_prefix(&self) -> &str {
        match self.swift_prefix.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_swift_prefix(&mut self) {
        self.swift_prefix = ::std::option::Option::None;
    }

    pub fn has_swift_prefix(&self) -> bool {
        self.swift_prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_swift_prefix(&mut self, v: ::std::string::String) {
        self.swift_prefix = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_swift_prefix(&mut self) -> &mut ::std::string::String {
        if self.swift_prefix.is_none() {
            self.swift_prefix = ::std::option::Option::Some(::std::string::String::new());
        }
        self.swift_prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_swift_prefix(&mut self) -> ::std::string::String {
        self.swift_prefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string php_class_prefix = 40;

    pub fn php_class_prefix(&self) -> &str {
        match self.php_class_prefix.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_php_class_prefix(&mut self) {
        self.php_class_prefix = ::std::option::Option::None;
    }

    pub fn has_php_class_prefix(&self) -> bool {
        self.php_class_prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_php_class_prefix(&mut self, v: ::std::string::String) {
        self.php_class_prefix = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_php_class_prefix(&mut self) -> &mut ::std::string::String {
        if self.php_class_prefix.is_none() {
            self.php_class_prefix = ::std::option::Option::Some(::std::string::String::new());
        }
        self.php_class_prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_php_class_prefix(&mut self) -> ::std::string::String {
        self.php_class_prefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string php_namespace = 41;

    pub fn php_namespace(&self) -> &str {
        match self.php_namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_php_namespace(&mut self) {
        self.php_namespace = ::std::option::Option::None;
    }

    pub fn has_php_namespace(&self) -> bool {
        self.php_namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_php_namespace(&mut self, v: ::std::string::String) {
        self.php_namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_php_namespace(&mut self) -> &mut ::std::string::String {
        if self.php_namespace.is_none() {
            self.php_namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.php_namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_php_namespace(&mut self) -> ::std::string::String {
        self.php_namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string php_metadata_namespace = 44;

    pub fn php_metadata_namespace(&self) -> &str {
        match self.php_metadata_namespace.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_php_metadata_namespace(&mut self) {
        self.php_metadata_namespace = ::std::option::Option::None;
    }

    pub fn has_php_metadata_namespace(&self) -> bool {
        self.php_metadata_namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_php_metadata_namespace(&mut self, v: ::std::string::String) {
        self.php_metadata_namespace = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_php_metadata_namespace(&mut self) -> &mut ::std::string::String {
        if self.php_metadata_namespace.is_none() {
            self.php_metadata_namespace = ::std::option::Option::Some(::std::string::String::new());
        }
        self.php_metadata_namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_php_metadata_namespace(&mut self) -> ::std::string::String {
        self.php_metadata_namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ruby_package = 45;

    pub fn ruby_package(&self) -> &str {
        match self.ruby_package.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_ruby_package(&mut self) {
        self.ruby_package = ::std::option::Option::None;
    }

    pub fn has_ruby_package(&self) -> bool {
        self.ruby_package.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ruby_package(&mut self, v: ::std::string::String) {
        self.ruby_package = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ruby_package(&mut self) -> &mut ::std::string::String {
        if self.ruby_package.is_none() {
            self.ruby_package = ::std::option::Option::Some(::std::string::String::new());
        }
        self.ruby_package.as_mut().unwrap()
    }

    // Take field
    pub fn take_ruby_package(&mut self) -> ::std::string::String {
        self.ruby_package.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(21);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "java_package",
            |m: &FileOptions| { &m.java_package },
            |m: &mut FileOptions| { &mut m.java_package },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "java_outer_classname",
            |m: &FileOptions| { &m.java_outer_classname },
            |m: &mut FileOptions| { &mut m.java_outer_classname },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "java_multiple_files",
            |m: &FileOptions| { &m.java_multiple_files },
            |m: &mut FileOptions| { &mut m.java_multiple_files },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "java_generate_equals_and_hash",
            |m: &FileOptions| { &m.java_generate_equals_and_hash },
            |m: &mut FileOptions| { &mut m.java_generate_equals_and_hash },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "java_string_check_utf8",
            |m: &FileOptions| { &m.java_string_check_utf8 },
            |m: &mut FileOptions| { &mut m.java_string_check_utf8 },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "optimize_for",
            |m: &FileOptions| { &m.optimize_for },
            |m: &mut FileOptions| { &mut m.optimize_for },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "go_package",
            |m: &FileOptions| { &m.go_package },
            |m: &mut FileOptions| { &mut m.go_package },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cc_generic_services",
            |m: &FileOptions| { &m.cc_generic_services },
            |m: &mut FileOptions| { &mut m.cc_generic_services },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "java_generic_services",
            |m: &FileOptions| { &m.java_generic_services },
            |m: &mut FileOptions| { &mut m.java_generic_services },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "py_generic_services",
            |m: &FileOptions| { &m.py_generic_services },
            |m: &mut FileOptions| { &mut m.py_generic_services },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "php_generic_services",
            |m: &FileOptions| { &m.php_generic_services },
            |m: &mut FileOptions| { &mut m.php_generic_services },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &FileOptions| { &m.deprecated },
            |m: &mut FileOptions| { &mut m.deprecated },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "cc_enable_arenas",
            |m: &FileOptions| { &m.cc_enable_arenas },
            |m: &mut FileOptions| { &mut m.cc_enable_arenas },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "objc_class_prefix",
            |m: &FileOptions| { &m.objc_class_prefix },
            |m: &mut FileOptions| { &mut m.objc_class_prefix },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "csharp_namespace",
            |m: &FileOptions| { &m.csharp_namespace },
            |m: &mut FileOptions| { &mut m.csharp_namespace },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "swift_prefix",
            |m: &FileOptions| { &m.swift_prefix },
            |m: &mut FileOptions| { &mut m.swift_prefix },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "php_class_prefix",
            |m: &FileOptions| { &m.php_class_prefix },
            |m: &mut FileOptions| { &mut m.php_class_prefix },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "php_namespace",
            |m: &FileOptions| { &m.php_namespace },
            |m: &mut FileOptions| { &mut m.php_namespace },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "php_metadata_namespace",
            |m: &FileOptions| { &m.php_metadata_namespace },
            |m: &mut FileOptions| { &mut m.php_metadata_namespace },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ruby_package",
            |m: &FileOptions| { &m.ruby_package },
            |m: &mut FileOptions| { &mut m.ruby_package },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &FileOptions| { &m.uninterpreted_option },
            |m: &mut FileOptions| { &mut m.uninterpreted_option },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<FileOptions>(
            "FileOptions",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for FileOptions {
    const NAME: &'static str = "FileOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.java_package = ::std::option::Option::Some(is.read_string()?);
                },
                66 => {
                    self.java_outer_classname = ::std::option::Option::Some(is.read_string()?);
                },
                80 => {
                    self.java_multiple_files = ::std::option::Option::Some(is.read_bool()?);
                },
                160 => {
                    self.java_generate_equals_and_hash = ::std::option::Option::Some(is.read_bool()?);
                },
                216 => {
                    self.java_string_check_utf8 = ::std::option::Option::Some(is.read_bool()?);
                },
                72 => {
                    self.optimize_for = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                90 => {
                    self.go_package = ::std::option::Option::Some(is.read_string()?);
                },
                128 => {
                    self.cc_generic_services = ::std::option::Option::Some(is.read_bool()?);
                },
                136 => {
                    self.java_generic_services = ::std::option::Option::Some(is.read_bool()?);
                },
                144 => {
                    self.py_generic_services = ::std::option::Option::Some(is.read_bool()?);
                },
                336 => {
                    self.php_generic_services = ::std::option::Option::Some(is.read_bool()?);
                },
                184 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                248 => {
                    self.cc_enable_arenas = ::std::option::Option::Some(is.read_bool()?);
                },
                290 => {
                    self.objc_class_prefix = ::std::option::Option::Some(is.read_string()?);
                },
                298 => {
                    self.csharp_namespace = ::std::option::Option::Some(is.read_string()?);
                },
                314 => {
                    self.swift_prefix = ::std::option::Option::Some(is.read_string()?);
                },
                322 => {
                    self.php_class_prefix = ::std::option::Option::Some(is.read_string()?);
                },
                330 => {
                    self.php_namespace = ::std::option::Option::Some(is.read_string()?);
                },
                354 => {
                    self.php_metadata_namespace = ::std::option::Option::Some(is.read_string()?);
                },
                362 => {
                    self.ruby_package = ::std::option::Option::Some(is.read_string()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.java_package.as_ref() {
            my_size += crate::rt::string_size(1, &v);
        }
        if let Some(v) = self.java_outer_classname.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        if let Some(v) = self.java_multiple_files {
            my_size += 1 + 1;
        }
        if let Some(v) = self.java_generate_equals_and_hash {
            my_size += 2 + 1;
        }
        if let Some(v) = self.java_string_check_utf8 {
            my_size += 2 + 1;
        }
        if let Some(v) = self.optimize_for {
            my_size += crate::rt::int32_size(9, v.value());
        }
        if let Some(v) = self.go_package.as_ref() {
            my_size += crate::rt::string_size(11, &v);
        }
        if let Some(v) = self.cc_generic_services {
            my_size += 2 + 1;
        }
        if let Some(v) = self.java_generic_services {
            my_size += 2 + 1;
        }
        if let Some(v) = self.py_generic_services {
            my_size += 2 + 1;
        }
        if let Some(v) = self.php_generic_services {
            my_size += 2 + 1;
        }
        if let Some(v) = self.deprecated {
            my_size += 2 + 1;
        }
        if let Some(v) = self.cc_enable_arenas {
            my_size += 2 + 1;
        }
        if let Some(v) = self.objc_class_prefix.as_ref() {
            my_size += crate::rt::string_size(36, &v);
        }
        if let Some(v) = self.csharp_namespace.as_ref() {
            my_size += crate::rt::string_size(37, &v);
        }
        if let Some(v) = self.swift_prefix.as_ref() {
            my_size += crate::rt::string_size(39, &v);
        }
        if let Some(v) = self.php_class_prefix.as_ref() {
            my_size += crate::rt::string_size(40, &v);
        }
        if let Some(v) = self.php_namespace.as_ref() {
            my_size += crate::rt::string_size(41, &v);
        }
        if let Some(v) = self.php_metadata_namespace.as_ref() {
            my_size += crate::rt::string_size(44, &v);
        }
        if let Some(v) = self.ruby_package.as_ref() {
            my_size += crate::rt::string_size(45, &v);
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.java_package.as_ref() {
            os.write_string(1, v)?;
        }
        if let Some(v) = self.java_outer_classname.as_ref() {
            os.write_string(8, v)?;
        }
        if let Some(v) = self.java_multiple_files {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.java_generate_equals_and_hash {
            os.write_bool(20, v)?;
        }
        if let Some(v) = self.java_string_check_utf8 {
            os.write_bool(27, v)?;
        }
        if let Some(v) = self.optimize_for {
            os.write_enum(9, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.go_package.as_ref() {
            os.write_string(11, v)?;
        }
        if let Some(v) = self.cc_generic_services {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.java_generic_services {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.py_generic_services {
            os.write_bool(18, v)?;
        }
        if let Some(v) = self.php_generic_services {
            os.write_bool(42, v)?;
        }
        if let Some(v) = self.deprecated {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.cc_enable_arenas {
            os.write_bool(31, v)?;
        }
        if let Some(v) = self.objc_class_prefix.as_ref() {
            os.write_string(36, v)?;
        }
        if let Some(v) = self.csharp_namespace.as_ref() {
            os.write_string(37, v)?;
        }
        if let Some(v) = self.swift_prefix.as_ref() {
            os.write_string(39, v)?;
        }
        if let Some(v) = self.php_class_prefix.as_ref() {
            os.write_string(40, v)?;
        }
        if let Some(v) = self.php_namespace.as_ref() {
            os.write_string(41, v)?;
        }
        if let Some(v) = self.php_metadata_namespace.as_ref() {
            os.write_string(44, v)?;
        }
        if let Some(v) = self.ruby_package.as_ref() {
            os.write_string(45, v)?;
        }
        for v in &self.uninterpreted_option {
            crate::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FileOptions {
        FileOptions::new()
    }

    fn clear(&mut self) {
        self.java_package = ::std::option::Option::None;
        self.java_outer_classname = ::std::option::Option::None;
        self.java_multiple_files = ::std::option::Option::None;
        self.java_generate_equals_and_hash = ::std::option::Option::None;
        self.java_string_check_utf8 = ::std::option::Option::None;
        self.optimize_for = ::std::option::Option::None;
        self.go_package = ::std::option::Option::None;
        self.cc_generic_services = ::std::option::Option::None;
        self.java_generic_services = ::std::option::Option::None;
        self.py_generic_services = ::std::option::Option::None;
        self.php_generic_services = ::std::option::Option::None;
        self.deprecated = ::std::option::Option::None;
        self.cc_enable_arenas = ::std::option::Option::None;
        self.objc_class_prefix = ::std::option::Option::None;
        self.csharp_namespace = ::std::option::Option::None;
        self.swift_prefix = ::std::option::Option::None;
        self.php_class_prefix = ::std::option::Option::None;
        self.php_namespace = ::std::option::Option::None;
        self.php_metadata_namespace = ::std::option::Option::None;
        self.ruby_package = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FileOptions {
        static instance: FileOptions = FileOptions {
            java_package: ::std::option::Option::None,
            java_outer_classname: ::std::option::Option::None,
            java_multiple_files: ::std::option::Option::None,
            java_generate_equals_and_hash: ::std::option::Option::None,
            java_string_check_utf8: ::std::option::Option::None,
            optimize_for: ::std::option::Option::None,
            go_package: ::std::option::Option::None,
            cc_generic_services: ::std::option::Option::None,
            java_generic_services: ::std::option::Option::None,
            py_generic_services: ::std::option::Option::None,
            php_generic_services: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            cc_enable_arenas: ::std::option::Option::None,
            objc_class_prefix: ::std::option::Option::None,
            csharp_namespace: ::std::option::Option::None,
            swift_prefix: ::std::option::Option::None,
            php_class_prefix: ::std::option::Option::None,
            php_namespace: ::std::option::Option::None,
            php_metadata_namespace: ::std::option::Option::None,
            ruby_package: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for FileOptions {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FileOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FileOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for FileOptions {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FileOptions`
pub mod file_options {
    ///  Generated classes can be optimized for speed or code size.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.FileOptions.OptimizeMode)
    pub enum OptimizeMode {
        // @@protoc_insertion_point(enum_value:google.protobuf.FileOptions.OptimizeMode.SPEED)
        SPEED = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.FileOptions.OptimizeMode.CODE_SIZE)
        CODE_SIZE = 2,
        // @@protoc_insertion_point(enum_value:google.protobuf.FileOptions.OptimizeMode.LITE_RUNTIME)
        LITE_RUNTIME = 3,
    }

    impl crate::Enum for OptimizeMode {
        const NAME: &'static str = "OptimizeMode";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<OptimizeMode> {
            match value {
                1 => ::std::option::Option::Some(OptimizeMode::SPEED),
                2 => ::std::option::Option::Some(OptimizeMode::CODE_SIZE),
                3 => ::std::option::Option::Some(OptimizeMode::LITE_RUNTIME),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<OptimizeMode> {
            match str {
                "SPEED" => ::std::option::Option::Some(OptimizeMode::SPEED),
                "CODE_SIZE" => ::std::option::Option::Some(OptimizeMode::CODE_SIZE),
                "LITE_RUNTIME" => ::std::option::Option::Some(OptimizeMode::LITE_RUNTIME),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [OptimizeMode] = &[
            OptimizeMode::SPEED,
            OptimizeMode::CODE_SIZE,
            OptimizeMode::LITE_RUNTIME,
        ];
    }

    impl crate::EnumFull for OptimizeMode {
        fn enum_descriptor() -> crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("FileOptions.OptimizeMode").unwrap()).clone()
        }

        fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
            let index = match self {
                OptimizeMode::SPEED => 0,
                OptimizeMode::CODE_SIZE => 1,
                OptimizeMode::LITE_RUNTIME => 2,
            };
            Self::enum_descriptor().value_by_index(index)
        }
    }

    // Note, `Default` is implemented although default value is not 0
    impl ::std::default::Default for OptimizeMode {
        fn default() -> Self {
            OptimizeMode::SPEED
        }
    }

    impl OptimizeMode {
        pub(in super) fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
            crate::reflect::GeneratedEnumDescriptorData::new::<OptimizeMode>("FileOptions.OptimizeMode")
        }
    }
}

// @@protoc_insertion_point(message:google.protobuf.MessageOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MessageOptions {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.MessageOptions.message_set_wire_format)
    pub message_set_wire_format: ::std::option::Option<bool>,
    ///  Disables the generation of the standard "descriptor()" accessor, which can
    ///  conflict with a field of the same name.  This is meant to make migration
    ///  from proto1 easier; new code should avoid fields named "descriptor".
    // @@protoc_insertion_point(field:google.protobuf.MessageOptions.no_standard_descriptor_accessor)
    pub no_standard_descriptor_accessor: ::std::option::Option<bool>,
    ///  Is this message deprecated?
    ///  Depending on the target platform, this can emit Deprecated annotations
    ///  for the message, or it will be completely ignored; in the very least,
    ///  this is a formalization for deprecating messages.
    // @@protoc_insertion_point(field:google.protobuf.MessageOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.MessageOptions.map_entry)
    pub map_entry: ::std::option::Option<bool>,
    ///  The parser stores options it doesn't recognize here. See above.
    // @@protoc_insertion_point(field:google.protobuf.MessageOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.MessageOptions.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MessageOptions {
    fn default() -> &'a MessageOptions {
        <MessageOptions as crate::Message>::default_instance()
    }
}

impl MessageOptions {
    pub fn new() -> MessageOptions {
        ::std::default::Default::default()
    }

    // optional bool message_set_wire_format = 1;

    pub fn message_set_wire_format(&self) -> bool {
        self.message_set_wire_format.unwrap_or(false)
    }

    pub fn clear_message_set_wire_format(&mut self) {
        self.message_set_wire_format = ::std::option::Option::None;
    }

    pub fn has_message_set_wire_format(&self) -> bool {
        self.message_set_wire_format.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_set_wire_format(&mut self, v: bool) {
        self.message_set_wire_format = ::std::option::Option::Some(v);
    }

    // optional bool no_standard_descriptor_accessor = 2;

    pub fn no_standard_descriptor_accessor(&self) -> bool {
        self.no_standard_descriptor_accessor.unwrap_or(false)
    }

    pub fn clear_no_standard_descriptor_accessor(&mut self) {
        self.no_standard_descriptor_accessor = ::std::option::Option::None;
    }

    pub fn has_no_standard_descriptor_accessor(&self) -> bool {
        self.no_standard_descriptor_accessor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_no_standard_descriptor_accessor(&mut self, v: bool) {
        self.no_standard_descriptor_accessor = ::std::option::Option::Some(v);
    }

    // optional bool deprecated = 3;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    // optional bool map_entry = 7;

    pub fn map_entry(&self) -> bool {
        self.map_entry.unwrap_or(false)
    }

    pub fn clear_map_entry(&mut self) {
        self.map_entry = ::std::option::Option::None;
    }

    pub fn has_map_entry(&self) -> bool {
        self.map_entry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_map_entry(&mut self, v: bool) {
        self.map_entry = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "message_set_wire_format",
            |m: &MessageOptions| { &m.message_set_wire_format },
            |m: &mut MessageOptions| { &mut m.message_set_wire_format },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "no_standard_descriptor_accessor",
            |m: &MessageOptions| { &m.no_standard_descriptor_accessor },
            |m: &mut MessageOptions| { &mut m.no_standard_descriptor_accessor },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &MessageOptions| { &m.deprecated },
            |m: &mut MessageOptions| { &mut m.deprecated },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "map_entry",
            |m: &MessageOptions| { &m.map_entry },
            |m: &mut MessageOptions| { &mut m.map_entry },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &MessageOptions| { &m.uninterpreted_option },
            |m: &mut MessageOptions| { &mut m.uninterpreted_option },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<MessageOptions>(
            "MessageOptions",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for MessageOptions {
    const NAME: &'static str = "MessageOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.message_set_wire_format = ::std::option::Option::Some(is.read_bool()?);
                },
                16 => {
                    self.no_standard_descriptor_accessor = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                56 => {
                    self.map_entry = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.message_set_wire_format {
            my_size += 1 + 1;
        }
        if let Some(v) = self.no_standard_descriptor_accessor {
            my_size += 1 + 1;
        }
        if let Some(v) = self.deprecated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.map_entry {
            my_size += 1 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.message_set_wire_format {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.no_standard_descriptor_accessor {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.deprecated {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.map_entry {
            os.write_bool(7, v)?;
        }
        for v in &self.uninterpreted_option {
            crate::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MessageOptions {
        MessageOptions::new()
    }

    fn clear(&mut self) {
        self.message_set_wire_format = ::std::option::Option::None;
        self.no_standard_descriptor_accessor = ::std::option::Option::None;
        self.deprecated = ::std::option::Option::None;
        self.map_entry = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MessageOptions {
        static instance: MessageOptions = MessageOptions {
            message_set_wire_format: ::std::option::Option::None,
            no_standard_descriptor_accessor: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            map_entry: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for MessageOptions {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MessageOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MessageOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for MessageOptions {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.FieldOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FieldOptions {
    // message fields
    ///  The ctype option instructs the C++ code generator to use a different
    ///  representation of the field than it normally would.  See the specific
    ///  options below.  This option is not yet implemented in the open source
    ///  release -- sorry, we'll try to include it in a future version!
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.ctype)
    pub ctype: ::std::option::Option<crate::EnumOrUnknown<field_options::CType>>,
    ///  The packed option can be enabled for repeated primitive fields to enable
    ///  a more efficient representation on the wire. Rather than repeatedly
    ///  writing the tag and type for each element, the entire array is encoded as
    ///  a single length-delimited blob. In proto3, only explicit setting it to
    ///  false will avoid using packed encoding.
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.packed)
    pub packed: ::std::option::Option<bool>,
    ///  The jstype option determines the JavaScript type used for values of the
    ///  field.  The option is permitted only for 64 bit integral and fixed types
    ///  (int64, uint64, sint64, fixed64, sfixed64).  A field with jstype JS_STRING
    ///  is represented as JavaScript string, which avoids loss of precision that
    ///  can happen when a large value is converted to a floating point JavaScript.
    ///  Specifying JS_NUMBER for the jstype causes the generated JavaScript code to
    ///  use the JavaScript "number" type.  The behavior of the default option
    ///  JS_NORMAL is implementation dependent.
    ///
    ///  This option is an enum to permit additional types to be added, e.g.
    ///  goog.math.Integer.
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.jstype)
    pub jstype: ::std::option::Option<crate::EnumOrUnknown<field_options::JSType>>,
    ///  Should this field be parsed lazily?  Lazy applies only to message-type
    ///  fields.  It means that when the outer message is initially parsed, the
    ///  inner message's contents will not be parsed but instead stored in encoded
    ///  form.  The inner message will actually be parsed when it is first accessed.
    ///
    ///  This is only a hint.  Implementations are free to choose whether to use
    ///  eager or lazy parsing regardless of the value of this option.  However,
    ///  setting this option true suggests that the protocol author believes that
    ///  using lazy parsing on this field is worth the additional bookkeeping
    ///  overhead typically needed to implement it.
    ///
    ///  This option does not affect the public interface of any generated code;
    ///  all method signatures remain the same.  Furthermore, thread-safety of the
    ///  interface is not affected by this option; const methods remain safe to
    ///  call from multiple threads concurrently, while non-const methods continue
    ///  to require exclusive access.
    ///
    ///
    ///  Note that implementations may choose not to check required fields within
    ///  a lazy sub-message.  That is, calling IsInitialized() on the outer message
    ///  may return true even if the inner message has missing required fields.
    ///  This is necessary because otherwise the inner message would have to be
    ///  parsed in order to perform the check, defeating the purpose of lazy
    ///  parsing.  An implementation which chooses not to check required fields
    ///  must be consistent about it.  That is, for any particular sub-message, the
    ///  implementation must either *always* check its required fields, or *never*
    ///  check its required fields, regardless of whether or not the message has
    ///  been parsed.
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.lazy)
    pub lazy: ::std::option::Option<bool>,
    ///  Is this field deprecated?
    ///  Depending on the target platform, this can emit Deprecated annotations
    ///  for accessors, or it will be completely ignored; in the very least, this
    ///  is a formalization for deprecating fields.
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    ///  For Google-internal migration only. Do not use.
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.weak)
    pub weak: ::std::option::Option<bool>,
    ///  The parser stores options it doesn't recognize here. See above.
    // @@protoc_insertion_point(field:google.protobuf.FieldOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.FieldOptions.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FieldOptions {
    fn default() -> &'a FieldOptions {
        <FieldOptions as crate::Message>::default_instance()
    }
}

impl FieldOptions {
    pub fn new() -> FieldOptions {
        ::std::default::Default::default()
    }

    // optional .google.protobuf.FieldOptions.CType ctype = 1;

    pub fn ctype(&self) -> field_options::CType {
        match self.ctype {
            Some(e) => e.enum_value_or(field_options::CType::STRING),
            None => field_options::CType::STRING,
        }
    }

    pub fn clear_ctype(&mut self) {
        self.ctype = ::std::option::Option::None;
    }

    pub fn has_ctype(&self) -> bool {
        self.ctype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ctype(&mut self, v: field_options::CType) {
        self.ctype = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional bool packed = 2;

    pub fn packed(&self) -> bool {
        self.packed.unwrap_or(false)
    }

    pub fn clear_packed(&mut self) {
        self.packed = ::std::option::Option::None;
    }

    pub fn has_packed(&self) -> bool {
        self.packed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packed(&mut self, v: bool) {
        self.packed = ::std::option::Option::Some(v);
    }

    // optional .google.protobuf.FieldOptions.JSType jstype = 6;

    pub fn jstype(&self) -> field_options::JSType {
        match self.jstype {
            Some(e) => e.enum_value_or(field_options::JSType::JS_NORMAL),
            None => field_options::JSType::JS_NORMAL,
        }
    }

    pub fn clear_jstype(&mut self) {
        self.jstype = ::std::option::Option::None;
    }

    pub fn has_jstype(&self) -> bool {
        self.jstype.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jstype(&mut self, v: field_options::JSType) {
        self.jstype = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    // optional bool lazy = 5;

    pub fn lazy(&self) -> bool {
        self.lazy.unwrap_or(false)
    }

    pub fn clear_lazy(&mut self) {
        self.lazy = ::std::option::Option::None;
    }

    pub fn has_lazy(&self) -> bool {
        self.lazy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lazy(&mut self, v: bool) {
        self.lazy = ::std::option::Option::Some(v);
    }

    // optional bool deprecated = 3;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    // optional bool weak = 10;

    pub fn weak(&self) -> bool {
        self.weak.unwrap_or(false)
    }

    pub fn clear_weak(&mut self) {
        self.weak = ::std::option::Option::None;
    }

    pub fn has_weak(&self) -> bool {
        self.weak.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weak(&mut self, v: bool) {
        self.weak = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "ctype",
            |m: &FieldOptions| { &m.ctype },
            |m: &mut FieldOptions| { &mut m.ctype },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "packed",
            |m: &FieldOptions| { &m.packed },
            |m: &mut FieldOptions| { &mut m.packed },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "jstype",
            |m: &FieldOptions| { &m.jstype },
            |m: &mut FieldOptions| { &mut m.jstype },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "lazy",
            |m: &FieldOptions| { &m.lazy },
            |m: &mut FieldOptions| { &mut m.lazy },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &FieldOptions| { &m.deprecated },
            |m: &mut FieldOptions| { &mut m.deprecated },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "weak",
            |m: &FieldOptions| { &m.weak },
            |m: &mut FieldOptions| { &mut m.weak },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &FieldOptions| { &m.uninterpreted_option },
            |m: &mut FieldOptions| { &mut m.uninterpreted_option },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<FieldOptions>(
            "FieldOptions",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for FieldOptions {
    const NAME: &'static str = "FieldOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.ctype = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                16 => {
                    self.packed = ::std::option::Option::Some(is.read_bool()?);
                },
                48 => {
                    self.jstype = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                40 => {
                    self.lazy = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                80 => {
                    self.weak = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.ctype {
            my_size += crate::rt::int32_size(1, v.value());
        }
        if let Some(v) = self.packed {
            my_size += 1 + 1;
        }
        if let Some(v) = self.jstype {
            my_size += crate::rt::int32_size(6, v.value());
        }
        if let Some(v) = self.lazy {
            my_size += 1 + 1;
        }
        if let Some(v) = self.deprecated {
            my_size += 1 + 1;
        }
        if let Some(v) = self.weak {
            my_size += 1 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.ctype {
            os.write_enum(1, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.packed {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.jstype {
            os.write_enum(6, crate::EnumOrUnknown::value(&v))?;
        }
        if let Some(v) = self.lazy {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.deprecated {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.weak {
            os.write_bool(10, v)?;
        }
        for v in &self.uninterpreted_option {
            crate::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FieldOptions {
        FieldOptions::new()
    }

    fn clear(&mut self) {
        self.ctype = ::std::option::Option::None;
        self.packed = ::std::option::Option::None;
        self.jstype = ::std::option::Option::None;
        self.lazy = ::std::option::Option::None;
        self.deprecated = ::std::option::Option::None;
        self.weak = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FieldOptions {
        static instance: FieldOptions = FieldOptions {
            ctype: ::std::option::Option::None,
            packed: ::std::option::Option::None,
            jstype: ::std::option::Option::None,
            lazy: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            weak: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for FieldOptions {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FieldOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FieldOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for FieldOptions {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `FieldOptions`
pub mod field_options {
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.FieldOptions.CType)
    pub enum CType {
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldOptions.CType.STRING)
        STRING = 0,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldOptions.CType.CORD)
        CORD = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldOptions.CType.STRING_PIECE)
        STRING_PIECE = 2,
    }

    impl crate::Enum for CType {
        const NAME: &'static str = "CType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<CType> {
            match value {
                0 => ::std::option::Option::Some(CType::STRING),
                1 => ::std::option::Option::Some(CType::CORD),
                2 => ::std::option::Option::Some(CType::STRING_PIECE),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<CType> {
            match str {
                "STRING" => ::std::option::Option::Some(CType::STRING),
                "CORD" => ::std::option::Option::Some(CType::CORD),
                "STRING_PIECE" => ::std::option::Option::Some(CType::STRING_PIECE),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [CType] = &[
            CType::STRING,
            CType::CORD,
            CType::STRING_PIECE,
        ];
    }

    impl crate::EnumFull for CType {
        fn enum_descriptor() -> crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("FieldOptions.CType").unwrap()).clone()
        }

        fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for CType {
        fn default() -> Self {
            CType::STRING
        }
    }

    impl CType {
        pub(in super) fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
            crate::reflect::GeneratedEnumDescriptorData::new::<CType>("FieldOptions.CType")
        }
    }

    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.FieldOptions.JSType)
    pub enum JSType {
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldOptions.JSType.JS_NORMAL)
        JS_NORMAL = 0,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldOptions.JSType.JS_STRING)
        JS_STRING = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.FieldOptions.JSType.JS_NUMBER)
        JS_NUMBER = 2,
    }

    impl crate::Enum for JSType {
        const NAME: &'static str = "JSType";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<JSType> {
            match value {
                0 => ::std::option::Option::Some(JSType::JS_NORMAL),
                1 => ::std::option::Option::Some(JSType::JS_STRING),
                2 => ::std::option::Option::Some(JSType::JS_NUMBER),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<JSType> {
            match str {
                "JS_NORMAL" => ::std::option::Option::Some(JSType::JS_NORMAL),
                "JS_STRING" => ::std::option::Option::Some(JSType::JS_STRING),
                "JS_NUMBER" => ::std::option::Option::Some(JSType::JS_NUMBER),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [JSType] = &[
            JSType::JS_NORMAL,
            JSType::JS_STRING,
            JSType::JS_NUMBER,
        ];
    }

    impl crate::EnumFull for JSType {
        fn enum_descriptor() -> crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("FieldOptions.JSType").unwrap()).clone()
        }

        fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for JSType {
        fn default() -> Self {
            JSType::JS_NORMAL
        }
    }

    impl JSType {
        pub(in super) fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
            crate::reflect::GeneratedEnumDescriptorData::new::<JSType>("FieldOptions.JSType")
        }
    }
}

// @@protoc_insertion_point(message:google.protobuf.OneofOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct OneofOptions {
    // message fields
    ///  The parser stores options it doesn't recognize here. See above.
    // @@protoc_insertion_point(field:google.protobuf.OneofOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.OneofOptions.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a OneofOptions {
    fn default() -> &'a OneofOptions {
        <OneofOptions as crate::Message>::default_instance()
    }
}

impl OneofOptions {
    pub fn new() -> OneofOptions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &OneofOptions| { &m.uninterpreted_option },
            |m: &mut OneofOptions| { &mut m.uninterpreted_option },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<OneofOptions>(
            "OneofOptions",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for OneofOptions {
    const NAME: &'static str = "OneofOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.uninterpreted_option {
            crate::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> OneofOptions {
        OneofOptions::new()
    }

    fn clear(&mut self) {
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static OneofOptions {
        static instance: OneofOptions = OneofOptions {
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for OneofOptions {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("OneofOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for OneofOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for OneofOptions {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.EnumOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnumOptions {
    // message fields
    ///  Set this option to true to allow mapping different tag names to the same
    ///  value.
    // @@protoc_insertion_point(field:google.protobuf.EnumOptions.allow_alias)
    pub allow_alias: ::std::option::Option<bool>,
    ///  Is this enum deprecated?
    ///  Depending on the target platform, this can emit Deprecated annotations
    ///  for the enum, or it will be completely ignored; in the very least, this
    ///  is a formalization for deprecating enums.
    // @@protoc_insertion_point(field:google.protobuf.EnumOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    ///  The parser stores options it doesn't recognize here. See above.
    // @@protoc_insertion_point(field:google.protobuf.EnumOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.EnumOptions.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnumOptions {
    fn default() -> &'a EnumOptions {
        <EnumOptions as crate::Message>::default_instance()
    }
}

impl EnumOptions {
    pub fn new() -> EnumOptions {
        ::std::default::Default::default()
    }

    // optional bool allow_alias = 2;

    pub fn allow_alias(&self) -> bool {
        self.allow_alias.unwrap_or(false)
    }

    pub fn clear_allow_alias(&mut self) {
        self.allow_alias = ::std::option::Option::None;
    }

    pub fn has_allow_alias(&self) -> bool {
        self.allow_alias.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allow_alias(&mut self, v: bool) {
        self.allow_alias = ::std::option::Option::Some(v);
    }

    // optional bool deprecated = 3;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "allow_alias",
            |m: &EnumOptions| { &m.allow_alias },
            |m: &mut EnumOptions| { &mut m.allow_alias },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &EnumOptions| { &m.deprecated },
            |m: &mut EnumOptions| { &mut m.deprecated },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &EnumOptions| { &m.uninterpreted_option },
            |m: &mut EnumOptions| { &mut m.uninterpreted_option },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<EnumOptions>(
            "EnumOptions",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for EnumOptions {
    const NAME: &'static str = "EnumOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                16 => {
                    self.allow_alias = ::std::option::Option::Some(is.read_bool()?);
                },
                24 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.allow_alias {
            my_size += 1 + 1;
        }
        if let Some(v) = self.deprecated {
            my_size += 1 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.allow_alias {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.deprecated {
            os.write_bool(3, v)?;
        }
        for v in &self.uninterpreted_option {
            crate::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnumOptions {
        EnumOptions::new()
    }

    fn clear(&mut self) {
        self.allow_alias = ::std::option::Option::None;
        self.deprecated = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnumOptions {
        static instance: EnumOptions = EnumOptions {
            allow_alias: ::std::option::Option::None,
            deprecated: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for EnumOptions {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnumOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnumOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for EnumOptions {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.EnumValueOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EnumValueOptions {
    // message fields
    ///  Is this enum value deprecated?
    ///  Depending on the target platform, this can emit Deprecated annotations
    ///  for the enum value, or it will be completely ignored; in the very least,
    ///  this is a formalization for deprecating enum values.
    // @@protoc_insertion_point(field:google.protobuf.EnumValueOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    ///  The parser stores options it doesn't recognize here. See above.
    // @@protoc_insertion_point(field:google.protobuf.EnumValueOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.EnumValueOptions.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EnumValueOptions {
    fn default() -> &'a EnumValueOptions {
        <EnumValueOptions as crate::Message>::default_instance()
    }
}

impl EnumValueOptions {
    pub fn new() -> EnumValueOptions {
        ::std::default::Default::default()
    }

    // optional bool deprecated = 1;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &EnumValueOptions| { &m.deprecated },
            |m: &mut EnumValueOptions| { &mut m.deprecated },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &EnumValueOptions| { &m.uninterpreted_option },
            |m: &mut EnumValueOptions| { &mut m.uninterpreted_option },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<EnumValueOptions>(
            "EnumValueOptions",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for EnumValueOptions {
    const NAME: &'static str = "EnumValueOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deprecated {
            my_size += 1 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.deprecated {
            os.write_bool(1, v)?;
        }
        for v in &self.uninterpreted_option {
            crate::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EnumValueOptions {
        EnumValueOptions::new()
    }

    fn clear(&mut self) {
        self.deprecated = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EnumValueOptions {
        static instance: EnumValueOptions = EnumValueOptions {
            deprecated: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for EnumValueOptions {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EnumValueOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EnumValueOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for EnumValueOptions {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.ServiceOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ServiceOptions {
    // message fields
    ///  Is this service deprecated?
    ///  Depending on the target platform, this can emit Deprecated annotations
    ///  for the service, or it will be completely ignored; in the very least,
    ///  this is a formalization for deprecating services.
    // @@protoc_insertion_point(field:google.protobuf.ServiceOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    ///  The parser stores options it doesn't recognize here. See above.
    // @@protoc_insertion_point(field:google.protobuf.ServiceOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.ServiceOptions.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ServiceOptions {
    fn default() -> &'a ServiceOptions {
        <ServiceOptions as crate::Message>::default_instance()
    }
}

impl ServiceOptions {
    pub fn new() -> ServiceOptions {
        ::std::default::Default::default()
    }

    // optional bool deprecated = 33;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &ServiceOptions| { &m.deprecated },
            |m: &mut ServiceOptions| { &mut m.deprecated },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &ServiceOptions| { &m.uninterpreted_option },
            |m: &mut ServiceOptions| { &mut m.uninterpreted_option },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<ServiceOptions>(
            "ServiceOptions",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for ServiceOptions {
    const NAME: &'static str = "ServiceOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                264 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deprecated {
            my_size += 2 + 1;
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.deprecated {
            os.write_bool(33, v)?;
        }
        for v in &self.uninterpreted_option {
            crate::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ServiceOptions {
        ServiceOptions::new()
    }

    fn clear(&mut self) {
        self.deprecated = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ServiceOptions {
        static instance: ServiceOptions = ServiceOptions {
            deprecated: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for ServiceOptions {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ServiceOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ServiceOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for ServiceOptions {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:google.protobuf.MethodOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MethodOptions {
    // message fields
    ///  Is this method deprecated?
    ///  Depending on the target platform, this can emit Deprecated annotations
    ///  for the method, or it will be completely ignored; in the very least,
    ///  this is a formalization for deprecating methods.
    // @@protoc_insertion_point(field:google.protobuf.MethodOptions.deprecated)
    pub deprecated: ::std::option::Option<bool>,
    // @@protoc_insertion_point(field:google.protobuf.MethodOptions.idempotency_level)
    pub idempotency_level: ::std::option::Option<crate::EnumOrUnknown<method_options::IdempotencyLevel>>,
    ///  The parser stores options it doesn't recognize here. See above.
    // @@protoc_insertion_point(field:google.protobuf.MethodOptions.uninterpreted_option)
    pub uninterpreted_option: ::std::vec::Vec<UninterpretedOption>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.MethodOptions.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MethodOptions {
    fn default() -> &'a MethodOptions {
        <MethodOptions as crate::Message>::default_instance()
    }
}

impl MethodOptions {
    pub fn new() -> MethodOptions {
        ::std::default::Default::default()
    }

    // optional bool deprecated = 33;

    pub fn deprecated(&self) -> bool {
        self.deprecated.unwrap_or(false)
    }

    pub fn clear_deprecated(&mut self) {
        self.deprecated = ::std::option::Option::None;
    }

    pub fn has_deprecated(&self) -> bool {
        self.deprecated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deprecated(&mut self, v: bool) {
        self.deprecated = ::std::option::Option::Some(v);
    }

    // optional .google.protobuf.MethodOptions.IdempotencyLevel idempotency_level = 34;

    pub fn idempotency_level(&self) -> method_options::IdempotencyLevel {
        match self.idempotency_level {
            Some(e) => e.enum_value_or(method_options::IdempotencyLevel::IDEMPOTENCY_UNKNOWN),
            None => method_options::IdempotencyLevel::IDEMPOTENCY_UNKNOWN,
        }
    }

    pub fn clear_idempotency_level(&mut self) {
        self.idempotency_level = ::std::option::Option::None;
    }

    pub fn has_idempotency_level(&self) -> bool {
        self.idempotency_level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idempotency_level(&mut self, v: method_options::IdempotencyLevel) {
        self.idempotency_level = ::std::option::Option::Some(crate::EnumOrUnknown::new(v));
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "deprecated",
            |m: &MethodOptions| { &m.deprecated },
            |m: &mut MethodOptions| { &mut m.deprecated },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "idempotency_level",
            |m: &MethodOptions| { &m.idempotency_level },
            |m: &mut MethodOptions| { &mut m.idempotency_level },
        ));
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uninterpreted_option",
            |m: &MethodOptions| { &m.uninterpreted_option },
            |m: &mut MethodOptions| { &mut m.uninterpreted_option },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<MethodOptions>(
            "MethodOptions",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for MethodOptions {
    const NAME: &'static str = "MethodOptions";

    fn is_initialized(&self) -> bool {
        for v in &self.uninterpreted_option {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                264 => {
                    self.deprecated = ::std::option::Option::Some(is.read_bool()?);
                },
                272 => {
                    self.idempotency_level = ::std::option::Option::Some(is.read_enum_or_unknown()?);
                },
                7994 => {
                    self.uninterpreted_option.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.deprecated {
            my_size += 2 + 1;
        }
        if let Some(v) = self.idempotency_level {
            my_size += crate::rt::int32_size(34, v.value());
        }
        for value in &self.uninterpreted_option {
            let len = value.compute_size();
            my_size += 2 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        if let Some(v) = self.deprecated {
            os.write_bool(33, v)?;
        }
        if let Some(v) = self.idempotency_level {
            os.write_enum(34, crate::EnumOrUnknown::value(&v))?;
        }
        for v in &self.uninterpreted_option {
            crate::rt::write_message_field_with_cached_size(999, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MethodOptions {
        MethodOptions::new()
    }

    fn clear(&mut self) {
        self.deprecated = ::std::option::Option::None;
        self.idempotency_level = ::std::option::Option::None;
        self.uninterpreted_option.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MethodOptions {
        static instance: MethodOptions = MethodOptions {
            deprecated: ::std::option::Option::None,
            idempotency_level: ::std::option::Option::None,
            uninterpreted_option: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for MethodOptions {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MethodOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MethodOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for MethodOptions {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `MethodOptions`
pub mod method_options {
    ///  Is this method side-effect-free (or safe in HTTP parlance), or idempotent,
    ///  or neither? HTTP based RPC implementation may choose GET verb for safe
    ///  methods, and PUT verb for idempotent methods instead of the default POST.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    // @@protoc_insertion_point(enum:google.protobuf.MethodOptions.IdempotencyLevel)
    pub enum IdempotencyLevel {
        // @@protoc_insertion_point(enum_value:google.protobuf.MethodOptions.IdempotencyLevel.IDEMPOTENCY_UNKNOWN)
        IDEMPOTENCY_UNKNOWN = 0,
        // @@protoc_insertion_point(enum_value:google.protobuf.MethodOptions.IdempotencyLevel.NO_SIDE_EFFECTS)
        NO_SIDE_EFFECTS = 1,
        // @@protoc_insertion_point(enum_value:google.protobuf.MethodOptions.IdempotencyLevel.IDEMPOTENT)
        IDEMPOTENT = 2,
    }

    impl crate::Enum for IdempotencyLevel {
        const NAME: &'static str = "IdempotencyLevel";

        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<IdempotencyLevel> {
            match value {
                0 => ::std::option::Option::Some(IdempotencyLevel::IDEMPOTENCY_UNKNOWN),
                1 => ::std::option::Option::Some(IdempotencyLevel::NO_SIDE_EFFECTS),
                2 => ::std::option::Option::Some(IdempotencyLevel::IDEMPOTENT),
                _ => ::std::option::Option::None
            }
        }

        fn from_str(str: &str) -> ::std::option::Option<IdempotencyLevel> {
            match str {
                "IDEMPOTENCY_UNKNOWN" => ::std::option::Option::Some(IdempotencyLevel::IDEMPOTENCY_UNKNOWN),
                "NO_SIDE_EFFECTS" => ::std::option::Option::Some(IdempotencyLevel::NO_SIDE_EFFECTS),
                "IDEMPOTENT" => ::std::option::Option::Some(IdempotencyLevel::IDEMPOTENT),
                _ => ::std::option::Option::None
            }
        }

        const VALUES: &'static [IdempotencyLevel] = &[
            IdempotencyLevel::IDEMPOTENCY_UNKNOWN,
            IdempotencyLevel::NO_SIDE_EFFECTS,
            IdempotencyLevel::IDEMPOTENT,
        ];
    }

    impl crate::EnumFull for IdempotencyLevel {
        fn enum_descriptor() -> crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().enum_by_package_relative_name("MethodOptions.IdempotencyLevel").unwrap()).clone()
        }

        fn descriptor(&self) -> crate::reflect::EnumValueDescriptor {
            let index = *self as usize;
            Self::enum_descriptor().value_by_index(index)
        }
    }

    impl ::std::default::Default for IdempotencyLevel {
        fn default() -> Self {
            IdempotencyLevel::IDEMPOTENCY_UNKNOWN
        }
    }

    impl IdempotencyLevel {
        pub(in super) fn generated_enum_descriptor_data() -> crate::reflect::GeneratedEnumDescriptorData {
            crate::reflect::GeneratedEnumDescriptorData::new::<IdempotencyLevel>("MethodOptions.IdempotencyLevel")
        }
    }
}

///  A message representing a option the parser does not recognize. This only
///  appears in options protos created by the compiler::Parser class.
///  DescriptorPool resolves these when building Descriptor objects. Therefore,
///  options protos in descriptor objects (e.g. returned by Descriptor::options(),
///  or produced by Descriptor::CopyTo()) will never have UninterpretedOptions
///  in them.
// @@protoc_insertion_point(message:google.protobuf.UninterpretedOption)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UninterpretedOption {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.name)
    pub name: ::std::vec::Vec<uninterpreted_option::NamePart>,
    ///  The value of the uninterpreted option, in whatever type the tokenizer
    ///  identified it as during parsing. Exactly one of these should be set.
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.identifier_value)
    pub identifier_value: ::std::option::Option<::std::string::String>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.positive_int_value)
    pub positive_int_value: ::std::option::Option<u64>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.negative_int_value)
    pub negative_int_value: ::std::option::Option<i64>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.double_value)
    pub double_value: ::std::option::Option<f64>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.string_value)
    pub string_value: ::std::option::Option<::std::vec::Vec<u8>>,
    // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.aggregate_value)
    pub aggregate_value: ::std::option::Option<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.UninterpretedOption.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UninterpretedOption {
    fn default() -> &'a UninterpretedOption {
        <UninterpretedOption as crate::Message>::default_instance()
    }
}

impl UninterpretedOption {
    pub fn new() -> UninterpretedOption {
        ::std::default::Default::default()
    }

    // optional string identifier_value = 3;

    pub fn identifier_value(&self) -> &str {
        match self.identifier_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_identifier_value(&mut self) {
        self.identifier_value = ::std::option::Option::None;
    }

    pub fn has_identifier_value(&self) -> bool {
        self.identifier_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier_value(&mut self, v: ::std::string::String) {
        self.identifier_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier_value(&mut self) -> &mut ::std::string::String {
        if self.identifier_value.is_none() {
            self.identifier_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.identifier_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifier_value(&mut self) -> ::std::string::String {
        self.identifier_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint64 positive_int_value = 4;

    pub fn positive_int_value(&self) -> u64 {
        self.positive_int_value.unwrap_or(0)
    }

    pub fn clear_positive_int_value(&mut self) {
        self.positive_int_value = ::std::option::Option::None;
    }

    pub fn has_positive_int_value(&self) -> bool {
        self.positive_int_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_positive_int_value(&mut self, v: u64) {
        self.positive_int_value = ::std::option::Option::Some(v);
    }

    // optional int64 negative_int_value = 5;

    pub fn negative_int_value(&self) -> i64 {
        self.negative_int_value.unwrap_or(0)
    }

    pub fn clear_negative_int_value(&mut self) {
        self.negative_int_value = ::std::option::Option::None;
    }

    pub fn has_negative_int_value(&self) -> bool {
        self.negative_int_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_negative_int_value(&mut self, v: i64) {
        self.negative_int_value = ::std::option::Option::Some(v);
    }

    // optional double double_value = 6;

    pub fn double_value(&self) -> f64 {
        self.double_value.unwrap_or(0.)
    }

    pub fn clear_double_value(&mut self) {
        self.double_value = ::std::option::Option::None;
    }

    pub fn has_double_value(&self) -> bool {
        self.double_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_double_value(&mut self, v: f64) {
        self.double_value = ::std::option::Option::Some(v);
    }

    // optional bytes string_value = 7;

    pub fn string_value(&self) -> &[u8] {
        match self.string_value.as_ref() {
            Some(v) => v,
            None => &[],
        }
    }

    pub fn clear_string_value(&mut self) {
        self.string_value = ::std::option::Option::None;
    }

    pub fn has_string_value(&self) -> bool {
        self.string_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_string_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.string_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_string_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.string_value.is_none() {
            self.string_value = ::std::option::Option::Some(::std::vec::Vec::new());
        }
        self.string_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_string_value(&mut self) -> ::std::vec::Vec<u8> {
        self.string_value.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }

    // optional string aggregate_value = 8;

    pub fn aggregate_value(&self) -> &str {
        match self.aggregate_value.as_ref() {
            Some(v) => v,
            None => "",
        }
    }

    pub fn clear_aggregate_value(&mut self) {
        self.aggregate_value = ::std::option::Option::None;
    }

    pub fn has_aggregate_value(&self) -> bool {
        self.aggregate_value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_aggregate_value(&mut self, v: ::std::string::String) {
        self.aggregate_value = ::std::option::Option::Some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_aggregate_value(&mut self) -> &mut ::std::string::String {
        if self.aggregate_value.is_none() {
            self.aggregate_value = ::std::option::Option::Some(::std::string::String::new());
        }
        self.aggregate_value.as_mut().unwrap()
    }

    // Take field
    pub fn take_aggregate_value(&mut self) -> ::std::string::String {
        self.aggregate_value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "name",
            |m: &UninterpretedOption| { &m.name },
            |m: &mut UninterpretedOption| { &mut m.name },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "identifier_value",
            |m: &UninterpretedOption| { &m.identifier_value },
            |m: &mut UninterpretedOption| { &mut m.identifier_value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "positive_int_value",
            |m: &UninterpretedOption| { &m.positive_int_value },
            |m: &mut UninterpretedOption| { &mut m.positive_int_value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "negative_int_value",
            |m: &UninterpretedOption| { &m.negative_int_value },
            |m: &mut UninterpretedOption| { &mut m.negative_int_value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "double_value",
            |m: &UninterpretedOption| { &m.double_value },
            |m: &mut UninterpretedOption| { &mut m.double_value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "string_value",
            |m: &UninterpretedOption| { &m.string_value },
            |m: &mut UninterpretedOption| { &mut m.string_value },
        ));
        fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
            "aggregate_value",
            |m: &UninterpretedOption| { &m.aggregate_value },
            |m: &mut UninterpretedOption| { &mut m.aggregate_value },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<UninterpretedOption>(
            "UninterpretedOption",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for UninterpretedOption {
    const NAME: &'static str = "UninterpretedOption";

    fn is_initialized(&self) -> bool {
        for v in &self.name {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                18 => {
                    self.name.push(is.read_message()?);
                },
                26 => {
                    self.identifier_value = ::std::option::Option::Some(is.read_string()?);
                },
                32 => {
                    self.positive_int_value = ::std::option::Option::Some(is.read_uint64()?);
                },
                40 => {
                    self.negative_int_value = ::std::option::Option::Some(is.read_int64()?);
                },
                49 => {
                    self.double_value = ::std::option::Option::Some(is.read_double()?);
                },
                58 => {
                    self.string_value = ::std::option::Option::Some(is.read_bytes()?);
                },
                66 => {
                    self.aggregate_value = ::std::option::Option::Some(is.read_string()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.name {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.identifier_value.as_ref() {
            my_size += crate::rt::string_size(3, &v);
        }
        if let Some(v) = self.positive_int_value {
            my_size += crate::rt::uint64_size(4, v);
        }
        if let Some(v) = self.negative_int_value {
            my_size += crate::rt::int64_size(5, v);
        }
        if let Some(v) = self.double_value {
            my_size += 1 + 8;
        }
        if let Some(v) = self.string_value.as_ref() {
            my_size += crate::rt::bytes_size(7, &v);
        }
        if let Some(v) = self.aggregate_value.as_ref() {
            my_size += crate::rt::string_size(8, &v);
        }
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.name {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.identifier_value.as_ref() {
            os.write_string(3, v)?;
        }
        if let Some(v) = self.positive_int_value {
            os.write_uint64(4, v)?;
        }
        if let Some(v) = self.negative_int_value {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.double_value {
            os.write_double(6, v)?;
        }
        if let Some(v) = self.string_value.as_ref() {
            os.write_bytes(7, v)?;
        }
        if let Some(v) = self.aggregate_value.as_ref() {
            os.write_string(8, v)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UninterpretedOption {
        UninterpretedOption::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.identifier_value = ::std::option::Option::None;
        self.positive_int_value = ::std::option::Option::None;
        self.negative_int_value = ::std::option::Option::None;
        self.double_value = ::std::option::Option::None;
        self.string_value = ::std::option::Option::None;
        self.aggregate_value = ::std::option::Option::None;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UninterpretedOption {
        static instance: UninterpretedOption = UninterpretedOption {
            name: ::std::vec::Vec::new(),
            identifier_value: ::std::option::Option::None,
            positive_int_value: ::std::option::Option::None,
            negative_int_value: ::std::option::Option::None,
            double_value: ::std::option::Option::None,
            string_value: ::std::option::Option::None,
            aggregate_value: ::std::option::Option::None,
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for UninterpretedOption {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UninterpretedOption").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UninterpretedOption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for UninterpretedOption {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `UninterpretedOption`
pub mod uninterpreted_option {
    ///  The name of the uninterpreted option.  Each string represents a segment in
    ///  a dot-separated name.  is_extension is true iff a segment represents an
    ///  extension (denoted with parentheses in options specs in .proto files).
    ///  E.g.,{ ["foo", false], ["bar.baz", true], ["qux", false] } represents
    ///  "foo.(bar.baz).qux".
    // @@protoc_insertion_point(message:google.protobuf.UninterpretedOption.NamePart)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct NamePart {
        // message fields
        // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.NamePart.name_part)
        pub name_part: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:google.protobuf.UninterpretedOption.NamePart.is_extension)
        pub is_extension: ::std::option::Option<bool>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.UninterpretedOption.NamePart.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a NamePart {
        fn default() -> &'a NamePart {
            <NamePart as crate::Message>::default_instance()
        }
    }

    impl NamePart {
        pub fn new() -> NamePart {
            ::std::default::Default::default()
        }

        // required string name_part = 1;

        pub fn name_part(&self) -> &str {
            match self.name_part.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_name_part(&mut self) {
            self.name_part = ::std::option::Option::None;
        }

        pub fn has_name_part(&self) -> bool {
            self.name_part.is_some()
        }

        // Param is passed by value, moved
        pub fn set_name_part(&mut self, v: ::std::string::String) {
            self.name_part = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_name_part(&mut self) -> &mut ::std::string::String {
            if self.name_part.is_none() {
                self.name_part = ::std::option::Option::Some(::std::string::String::new());
            }
            self.name_part.as_mut().unwrap()
        }

        // Take field
        pub fn take_name_part(&mut self) -> ::std::string::String {
            self.name_part.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // required bool is_extension = 2;

        pub fn is_extension(&self) -> bool {
            self.is_extension.unwrap_or(false)
        }

        pub fn clear_is_extension(&mut self) {
            self.is_extension = ::std::option::Option::None;
        }

        pub fn has_is_extension(&self) -> bool {
            self.is_extension.is_some()
        }

        // Param is passed by value, moved
        pub fn set_is_extension(&mut self, v: bool) {
            self.is_extension = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(2);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "name_part",
                |m: &NamePart| { &m.name_part },
                |m: &mut NamePart| { &mut m.name_part },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "is_extension",
                |m: &NamePart| { &m.is_extension },
                |m: &mut NamePart| { &mut m.is_extension },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<NamePart>(
                "UninterpretedOption.NamePart",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for NamePart {
        const NAME: &'static str = "NamePart";

        fn is_initialized(&self) -> bool {
            if self.name_part.is_none() {
                return false;
            }
            if self.is_extension.is_none() {
                return false;
            }
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        self.name_part = ::std::option::Option::Some(is.read_string()?);
                    },
                    16 => {
                        self.is_extension = ::std::option::Option::Some(is.read_bool()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            if let Some(v) = self.name_part.as_ref() {
                my_size += crate::rt::string_size(1, &v);
            }
            if let Some(v) = self.is_extension {
                my_size += 1 + 1;
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            if let Some(v) = self.name_part.as_ref() {
                os.write_string(1, v)?;
            }
            if let Some(v) = self.is_extension {
                os.write_bool(2, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> NamePart {
            NamePart::new()
        }

        fn clear(&mut self) {
            self.name_part = ::std::option::Option::None;
            self.is_extension = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static NamePart {
            static instance: NamePart = NamePart {
                name_part: ::std::option::Option::None,
                is_extension: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for NamePart {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("UninterpretedOption.NamePart").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for NamePart {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for NamePart {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

///  Encapsulates information about the original source file from which a
///  FileDescriptorProto was generated.
// @@protoc_insertion_point(message:google.protobuf.SourceCodeInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SourceCodeInfo {
    // message fields
    // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.location)
    pub location: ::std::vec::Vec<source_code_info::Location>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.SourceCodeInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SourceCodeInfo {
    fn default() -> &'a SourceCodeInfo {
        <SourceCodeInfo as crate::Message>::default_instance()
    }
}

impl SourceCodeInfo {
    pub fn new() -> SourceCodeInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "location",
            |m: &SourceCodeInfo| { &m.location },
            |m: &mut SourceCodeInfo| { &mut m.location },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<SourceCodeInfo>(
            "SourceCodeInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for SourceCodeInfo {
    const NAME: &'static str = "SourceCodeInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.location.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.location {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.location {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SourceCodeInfo {
        SourceCodeInfo::new()
    }

    fn clear(&mut self) {
        self.location.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SourceCodeInfo {
        static instance: SourceCodeInfo = SourceCodeInfo {
            location: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for SourceCodeInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SourceCodeInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SourceCodeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for SourceCodeInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `SourceCodeInfo`
pub mod source_code_info {
    // @@protoc_insertion_point(message:google.protobuf.SourceCodeInfo.Location)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Location {
        // message fields
        // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.Location.path)
        pub path: ::std::vec::Vec<i32>,
        ///  Always has exactly three or four elements: start line, start column,
        ///  end line (optional, otherwise assumed same as start line), end column.
        ///  These are packed into a single field for efficiency.  Note that line
        ///  and column numbers are zero-based -- typically you will want to add
        ///  1 to each before displaying to a user.
        // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.Location.span)
        pub span: ::std::vec::Vec<i32>,
        // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.Location.leading_comments)
        pub leading_comments: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.Location.trailing_comments)
        pub trailing_comments: ::std::option::Option<::std::string::String>,
        // @@protoc_insertion_point(field:google.protobuf.SourceCodeInfo.Location.leading_detached_comments)
        pub leading_detached_comments: ::std::vec::Vec<::std::string::String>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.SourceCodeInfo.Location.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Location {
        fn default() -> &'a Location {
            <Location as crate::Message>::default_instance()
        }
    }

    impl Location {
        pub fn new() -> Location {
            ::std::default::Default::default()
        }

        // optional string leading_comments = 3;

        pub fn leading_comments(&self) -> &str {
            match self.leading_comments.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_leading_comments(&mut self) {
            self.leading_comments = ::std::option::Option::None;
        }

        pub fn has_leading_comments(&self) -> bool {
            self.leading_comments.is_some()
        }

        // Param is passed by value, moved
        pub fn set_leading_comments(&mut self, v: ::std::string::String) {
            self.leading_comments = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_leading_comments(&mut self) -> &mut ::std::string::String {
            if self.leading_comments.is_none() {
                self.leading_comments = ::std::option::Option::Some(::std::string::String::new());
            }
            self.leading_comments.as_mut().unwrap()
        }

        // Take field
        pub fn take_leading_comments(&mut self) -> ::std::string::String {
            self.leading_comments.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional string trailing_comments = 4;

        pub fn trailing_comments(&self) -> &str {
            match self.trailing_comments.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_trailing_comments(&mut self) {
            self.trailing_comments = ::std::option::Option::None;
        }

        pub fn has_trailing_comments(&self) -> bool {
            self.trailing_comments.is_some()
        }

        // Param is passed by value, moved
        pub fn set_trailing_comments(&mut self, v: ::std::string::String) {
            self.trailing_comments = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_trailing_comments(&mut self) -> &mut ::std::string::String {
            if self.trailing_comments.is_none() {
                self.trailing_comments = ::std::option::Option::Some(::std::string::String::new());
            }
            self.trailing_comments.as_mut().unwrap()
        }

        // Take field
        pub fn take_trailing_comments(&mut self) -> ::std::string::String {
            self.trailing_comments.take().unwrap_or_else(|| ::std::string::String::new())
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(5);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "path",
                |m: &Location| { &m.path },
                |m: &mut Location| { &mut m.path },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "span",
                |m: &Location| { &m.span },
                |m: &mut Location| { &mut m.span },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "leading_comments",
                |m: &Location| { &m.leading_comments },
                |m: &mut Location| { &mut m.leading_comments },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "trailing_comments",
                |m: &Location| { &m.trailing_comments },
                |m: &mut Location| { &mut m.trailing_comments },
            ));
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "leading_detached_comments",
                |m: &Location| { &m.leading_detached_comments },
                |m: &mut Location| { &mut m.leading_detached_comments },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Location>(
                "SourceCodeInfo.Location",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Location {
        const NAME: &'static str = "Location";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_int32_into(&mut self.path)?;
                    },
                    8 => {
                        self.path.push(is.read_int32()?);
                    },
                    18 => {
                        is.read_repeated_packed_int32_into(&mut self.span)?;
                    },
                    16 => {
                        self.span.push(is.read_int32()?);
                    },
                    26 => {
                        self.leading_comments = ::std::option::Option::Some(is.read_string()?);
                    },
                    34 => {
                        self.trailing_comments = ::std::option::Option::Some(is.read_string()?);
                    },
                    50 => {
                        self.leading_detached_comments.push(is.read_string()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += crate::rt::vec_packed_int32_size(1, &self.path);
            my_size += crate::rt::vec_packed_int32_size(2, &self.span);
            if let Some(v) = self.leading_comments.as_ref() {
                my_size += crate::rt::string_size(3, &v);
            }
            if let Some(v) = self.trailing_comments.as_ref() {
                my_size += crate::rt::string_size(4, &v);
            }
            for value in &self.leading_detached_comments {
                my_size += crate::rt::string_size(6, &value);
            };
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            os.write_repeated_packed_int32(1, &self.path)?;
            os.write_repeated_packed_int32(2, &self.span)?;
            if let Some(v) = self.leading_comments.as_ref() {
                os.write_string(3, v)?;
            }
            if let Some(v) = self.trailing_comments.as_ref() {
                os.write_string(4, v)?;
            }
            for v in &self.leading_detached_comments {
                os.write_string(6, &v)?;
            };
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Location {
            Location::new()
        }

        fn clear(&mut self) {
            self.path.clear();
            self.span.clear();
            self.leading_comments = ::std::option::Option::None;
            self.trailing_comments = ::std::option::Option::None;
            self.leading_detached_comments.clear();
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Location {
            static instance: Location = Location {
                path: ::std::vec::Vec::new(),
                span: ::std::vec::Vec::new(),
                leading_comments: ::std::option::Option::None,
                trailing_comments: ::std::option::Option::None,
                leading_detached_comments: ::std::vec::Vec::new(),
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Location {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("SourceCodeInfo.Location").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Location {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Location {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

///  Describes the relationship between generated code and its original source
///  file. A GeneratedCodeInfo message is associated with only one generated
///  source file, but may contain references to different source .proto files.
// @@protoc_insertion_point(message:google.protobuf.GeneratedCodeInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GeneratedCodeInfo {
    // message fields
    ///  An Annotation connects some span of text in generated code to an element
    ///  of its generating .proto file.
    // @@protoc_insertion_point(field:google.protobuf.GeneratedCodeInfo.annotation)
    pub annotation: ::std::vec::Vec<generated_code_info::Annotation>,
    // special fields
    // @@protoc_insertion_point(special_field:google.protobuf.GeneratedCodeInfo.special_fields)
    pub special_fields: crate::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GeneratedCodeInfo {
    fn default() -> &'a GeneratedCodeInfo {
        <GeneratedCodeInfo as crate::Message>::default_instance()
    }
}

impl GeneratedCodeInfo {
    pub fn new() -> GeneratedCodeInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "annotation",
            |m: &GeneratedCodeInfo| { &m.annotation },
            |m: &mut GeneratedCodeInfo| { &mut m.annotation },
        ));
        crate::reflect::GeneratedMessageDescriptorData::new_2::<GeneratedCodeInfo>(
            "GeneratedCodeInfo",
            fields,
            oneofs,
        )
    }
}

impl crate::Message for GeneratedCodeInfo {
    const NAME: &'static str = "GeneratedCodeInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.annotation.push(is.read_message()?);
                },
                tag => {
                    crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.annotation {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
        for v in &self.annotation {
            crate::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &crate::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GeneratedCodeInfo {
        GeneratedCodeInfo::new()
    }

    fn clear(&mut self) {
        self.annotation.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GeneratedCodeInfo {
        static instance: GeneratedCodeInfo = GeneratedCodeInfo {
            annotation: ::std::vec::Vec::new(),
            special_fields: crate::SpecialFields::new(),
        };
        &instance
    }
}

impl crate::MessageFull for GeneratedCodeInfo {
    fn descriptor() -> crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GeneratedCodeInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GeneratedCodeInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for GeneratedCodeInfo {
    type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `GeneratedCodeInfo`
pub mod generated_code_info {
    // @@protoc_insertion_point(message:google.protobuf.GeneratedCodeInfo.Annotation)
    #[derive(PartialEq,Clone,Default,Debug)]
    pub struct Annotation {
        // message fields
        ///  Identifies the element in the original source .proto file. This field
        ///  is formatted the same as SourceCodeInfo.Location.path.
        // @@protoc_insertion_point(field:google.protobuf.GeneratedCodeInfo.Annotation.path)
        pub path: ::std::vec::Vec<i32>,
        ///  Identifies the filesystem path to the original source .proto.
        // @@protoc_insertion_point(field:google.protobuf.GeneratedCodeInfo.Annotation.source_file)
        pub source_file: ::std::option::Option<::std::string::String>,
        ///  Identifies the starting offset in bytes in the generated code
        ///  that relates to the identified object.
        // @@protoc_insertion_point(field:google.protobuf.GeneratedCodeInfo.Annotation.begin)
        pub begin: ::std::option::Option<i32>,
        ///  Identifies the ending offset in bytes in the generated code that
        ///  relates to the identified offset. The end offset should be one past
        ///  the last relevant byte (so the length of the text = end - begin).
        // @@protoc_insertion_point(field:google.protobuf.GeneratedCodeInfo.Annotation.end)
        pub end: ::std::option::Option<i32>,
        // special fields
        // @@protoc_insertion_point(special_field:google.protobuf.GeneratedCodeInfo.Annotation.special_fields)
        pub special_fields: crate::SpecialFields,
    }

    impl<'a> ::std::default::Default for &'a Annotation {
        fn default() -> &'a Annotation {
            <Annotation as crate::Message>::default_instance()
        }
    }

    impl Annotation {
        pub fn new() -> Annotation {
            ::std::default::Default::default()
        }

        // optional string source_file = 2;

        pub fn source_file(&self) -> &str {
            match self.source_file.as_ref() {
                Some(v) => v,
                None => "",
            }
        }

        pub fn clear_source_file(&mut self) {
            self.source_file = ::std::option::Option::None;
        }

        pub fn has_source_file(&self) -> bool {
            self.source_file.is_some()
        }

        // Param is passed by value, moved
        pub fn set_source_file(&mut self, v: ::std::string::String) {
            self.source_file = ::std::option::Option::Some(v);
        }

        // Mutable pointer to the field.
        // If field is not initialized, it is initialized with default value first.
        pub fn mut_source_file(&mut self) -> &mut ::std::string::String {
            if self.source_file.is_none() {
                self.source_file = ::std::option::Option::Some(::std::string::String::new());
            }
            self.source_file.as_mut().unwrap()
        }

        // Take field
        pub fn take_source_file(&mut self) -> ::std::string::String {
            self.source_file.take().unwrap_or_else(|| ::std::string::String::new())
        }

        // optional int32 begin = 3;

        pub fn begin(&self) -> i32 {
            self.begin.unwrap_or(0)
        }

        pub fn clear_begin(&mut self) {
            self.begin = ::std::option::Option::None;
        }

        pub fn has_begin(&self) -> bool {
            self.begin.is_some()
        }

        // Param is passed by value, moved
        pub fn set_begin(&mut self, v: i32) {
            self.begin = ::std::option::Option::Some(v);
        }

        // optional int32 end = 4;

        pub fn end(&self) -> i32 {
            self.end.unwrap_or(0)
        }

        pub fn clear_end(&mut self) {
            self.end = ::std::option::Option::None;
        }

        pub fn has_end(&self) -> bool {
            self.end.is_some()
        }

        // Param is passed by value, moved
        pub fn set_end(&mut self, v: i32) {
            self.end = ::std::option::Option::Some(v);
        }

        pub(in super) fn generated_message_descriptor_data() -> crate::reflect::GeneratedMessageDescriptorData {
            let mut fields = ::std::vec::Vec::with_capacity(4);
            let mut oneofs = ::std::vec::Vec::with_capacity(0);
            fields.push(crate::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
                "path",
                |m: &Annotation| { &m.path },
                |m: &mut Annotation| { &mut m.path },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "source_file",
                |m: &Annotation| { &m.source_file },
                |m: &mut Annotation| { &mut m.source_file },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "begin",
                |m: &Annotation| { &m.begin },
                |m: &mut Annotation| { &mut m.begin },
            ));
            fields.push(crate::reflect::rt::v2::make_option_accessor::<_, _>(
                "end",
                |m: &Annotation| { &m.end },
                |m: &mut Annotation| { &mut m.end },
            ));
            crate::reflect::GeneratedMessageDescriptorData::new_2::<Annotation>(
                "GeneratedCodeInfo.Annotation",
                fields,
                oneofs,
            )
        }
    }

    impl crate::Message for Annotation {
        const NAME: &'static str = "Annotation";

        fn is_initialized(&self) -> bool {
            true
        }

        fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::Result<()> {
            while let Some(tag) = is.read_raw_tag_or_eof()? {
                match tag {
                    10 => {
                        is.read_repeated_packed_int32_into(&mut self.path)?;
                    },
                    8 => {
                        self.path.push(is.read_int32()?);
                    },
                    18 => {
                        self.source_file = ::std::option::Option::Some(is.read_string()?);
                    },
                    24 => {
                        self.begin = ::std::option::Option::Some(is.read_int32()?);
                    },
                    32 => {
                        self.end = ::std::option::Option::Some(is.read_int32()?);
                    },
                    tag => {
                        crate::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                    },
                };
            }
            ::std::result::Result::Ok(())
        }

        // Compute sizes of nested messages
        #[allow(unused_variables)]
        fn compute_size(&self) -> u64 {
            let mut my_size = 0;
            my_size += crate::rt::vec_packed_int32_size(1, &self.path);
            if let Some(v) = self.source_file.as_ref() {
                my_size += crate::rt::string_size(2, &v);
            }
            if let Some(v) = self.begin {
                my_size += crate::rt::int32_size(3, v);
            }
            if let Some(v) = self.end {
                my_size += crate::rt::int32_size(4, v);
            }
            my_size += crate::rt::unknown_fields_size(self.special_fields.unknown_fields());
            self.special_fields.cached_size().set(my_size as u32);
            my_size
        }

        fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::Result<()> {
            os.write_repeated_packed_int32(1, &self.path)?;
            if let Some(v) = self.source_file.as_ref() {
                os.write_string(2, v)?;
            }
            if let Some(v) = self.begin {
                os.write_int32(3, v)?;
            }
            if let Some(v) = self.end {
                os.write_int32(4, v)?;
            }
            os.write_unknown_fields(self.special_fields.unknown_fields())?;
            ::std::result::Result::Ok(())
        }

        fn special_fields(&self) -> &crate::SpecialFields {
            &self.special_fields
        }

        fn mut_special_fields(&mut self) -> &mut crate::SpecialFields {
            &mut self.special_fields
        }

        fn new() -> Annotation {
            Annotation::new()
        }

        fn clear(&mut self) {
            self.path.clear();
            self.source_file = ::std::option::Option::None;
            self.begin = ::std::option::Option::None;
            self.end = ::std::option::Option::None;
            self.special_fields.clear();
        }

        fn default_instance() -> &'static Annotation {
            static instance: Annotation = Annotation {
                path: ::std::vec::Vec::new(),
                source_file: ::std::option::Option::None,
                begin: ::std::option::Option::None,
                end: ::std::option::Option::None,
                special_fields: crate::SpecialFields::new(),
            };
            &instance
        }
    }

    impl crate::MessageFull for Annotation {
        fn descriptor() -> crate::reflect::MessageDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::new();
            descriptor.get(|| super::file_descriptor().message_by_package_relative_name("GeneratedCodeInfo.Annotation").unwrap()).clone()
        }
    }

    impl ::std::fmt::Display for Annotation {
        fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            crate::text_format::fmt(self, f)
        }
    }

    impl crate::reflect::ProtobufValue for Annotation {
        type RuntimeType = crate::reflect::rt::RuntimeTypeMessage<Self>;
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20google/protobuf/descriptor.proto\x12\x0fgoogle.protobuf\"M\n\x11Fi\
    leDescriptorSet\x128\n\x04file\x18\x01\x20\x03(\x0b2$.google.protobuf.Fi\
    leDescriptorProtoR\x04file\"\xe4\x04\n\x13FileDescriptorProto\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12\x18\n\x07package\x18\x02\x20\
    \x01(\tR\x07package\x12\x1e\n\ndependency\x18\x03\x20\x03(\tR\ndependenc\
    y\x12+\n\x11public_dependency\x18\n\x20\x03(\x05R\x10publicDependency\
    \x12'\n\x0fweak_dependency\x18\x0b\x20\x03(\x05R\x0eweakDependency\x12C\
    \n\x0cmessage_type\x18\x04\x20\x03(\x0b2\x20.google.protobuf.DescriptorP\
    rotoR\x0bmessageType\x12A\n\tenum_type\x18\x05\x20\x03(\x0b2$.google.pro\
    tobuf.EnumDescriptorProtoR\x08enumType\x12A\n\x07service\x18\x06\x20\x03\
    (\x0b2'.google.protobuf.ServiceDescriptorProtoR\x07service\x12C\n\texten\
    sion\x18\x07\x20\x03(\x0b2%.google.protobuf.FieldDescriptorProtoR\texten\
    sion\x126\n\x07options\x18\x08\x20\x01(\x0b2\x1c.google.protobuf.FileOpt\
    ionsR\x07options\x12I\n\x10source_code_info\x18\t\x20\x01(\x0b2\x1f.goog\
    le.protobuf.SourceCodeInfoR\x0esourceCodeInfo\x12\x16\n\x06syntax\x18\
    \x0c\x20\x01(\tR\x06syntax\"\xb9\x06\n\x0fDescriptorProto\x12\x12\n\x04n\
    ame\x18\x01\x20\x01(\tR\x04name\x12;\n\x05field\x18\x02\x20\x03(\x0b2%.g\
    oogle.protobuf.FieldDescriptorProtoR\x05field\x12C\n\textension\x18\x06\
    \x20\x03(\x0b2%.google.protobuf.FieldDescriptorProtoR\textension\x12A\n\
    \x0bnested_type\x18\x03\x20\x03(\x0b2\x20.google.protobuf.DescriptorProt\
    oR\nnestedType\x12A\n\tenum_type\x18\x04\x20\x03(\x0b2$.google.protobuf.\
    EnumDescriptorProtoR\x08enumType\x12X\n\x0fextension_range\x18\x05\x20\
    \x03(\x0b2/.google.protobuf.DescriptorProto.ExtensionRangeR\x0eextension\
    Range\x12D\n\noneof_decl\x18\x08\x20\x03(\x0b2%.google.protobuf.OneofDes\
    criptorProtoR\toneofDecl\x129\n\x07options\x18\x07\x20\x01(\x0b2\x1f.goo\
    gle.protobuf.MessageOptionsR\x07options\x12U\n\x0ereserved_range\x18\t\
    \x20\x03(\x0b2..google.protobuf.DescriptorProto.ReservedRangeR\rreserved\
    Range\x12#\n\rreserved_name\x18\n\x20\x03(\tR\x0creservedName\x1az\n\x0e\
    ExtensionRange\x12\x14\n\x05start\x18\x01\x20\x01(\x05R\x05start\x12\x10\
    \n\x03end\x18\x02\x20\x01(\x05R\x03end\x12@\n\x07options\x18\x03\x20\x01\
    (\x0b2&.google.protobuf.ExtensionRangeOptionsR\x07options\x1a7\n\rReserv\
    edRange\x12\x14\n\x05start\x18\x01\x20\x01(\x05R\x05start\x12\x10\n\x03e\
    nd\x18\x02\x20\x01(\x05R\x03end\"|\n\x15ExtensionRangeOptions\x12X\n\x14\
    uninterpreted_option\x18\xe7\x07\x20\x03(\x0b2$.google.protobuf.Uninterp\
    retedOptionR\x13uninterpretedOption*\t\x08\xe8\x07\x10\x80\x80\x80\x80\
    \x02\"\xc1\x06\n\x14FieldDescriptorProto\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x16\n\x06number\x18\x03\x20\x01(\x05R\x06number\x12\
    A\n\x05label\x18\x04\x20\x01(\x0e2+.google.protobuf.FieldDescriptorProto\
    .LabelR\x05label\x12>\n\x04type\x18\x05\x20\x01(\x0e2*.google.protobuf.F\
    ieldDescriptorProto.TypeR\x04type\x12\x1b\n\ttype_name\x18\x06\x20\x01(\
    \tR\x08typeName\x12\x1a\n\x08extendee\x18\x02\x20\x01(\tR\x08extendee\
    \x12#\n\rdefault_value\x18\x07\x20\x01(\tR\x0cdefaultValue\x12\x1f\n\x0b\
    oneof_index\x18\t\x20\x01(\x05R\noneofIndex\x12\x1b\n\tjson_name\x18\n\
    \x20\x01(\tR\x08jsonName\x127\n\x07options\x18\x08\x20\x01(\x0b2\x1d.goo\
    gle.protobuf.FieldOptionsR\x07options\x12'\n\x0fproto3_optional\x18\x11\
    \x20\x01(\x08R\x0eproto3Optional\"\xb6\x02\n\x04Type\x12\x0f\n\x0bTYPE_D\
    OUBLE\x10\x01\x12\x0e\n\nTYPE_FLOAT\x10\x02\x12\x0e\n\nTYPE_INT64\x10\
    \x03\x12\x0f\n\x0bTYPE_UINT64\x10\x04\x12\x0e\n\nTYPE_INT32\x10\x05\x12\
    \x10\n\x0cTYPE_FIXED64\x10\x06\x12\x10\n\x0cTYPE_FIXED32\x10\x07\x12\r\n\
    \tTYPE_BOOL\x10\x08\x12\x0f\n\x0bTYPE_STRING\x10\t\x12\x0e\n\nTYPE_GROUP\
    \x10\n\x12\x10\n\x0cTYPE_MESSAGE\x10\x0b\x12\x0e\n\nTYPE_BYTES\x10\x0c\
    \x12\x0f\n\x0bTYPE_UINT32\x10\r\x12\r\n\tTYPE_ENUM\x10\x0e\x12\x11\n\rTY\
    PE_SFIXED32\x10\x0f\x12\x11\n\rTYPE_SFIXED64\x10\x10\x12\x0f\n\x0bTYPE_S\
    INT32\x10\x11\x12\x0f\n\x0bTYPE_SINT64\x10\x12\"C\n\x05Label\x12\x12\n\
    \x0eLABEL_OPTIONAL\x10\x01\x12\x12\n\x0eLABEL_REQUIRED\x10\x02\x12\x12\n\
    \x0eLABEL_REPEATED\x10\x03\"c\n\x14OneofDescriptorProto\x12\x12\n\x04nam\
    e\x18\x01\x20\x01(\tR\x04name\x127\n\x07options\x18\x02\x20\x01(\x0b2\
    \x1d.google.protobuf.OneofOptionsR\x07options\"\xe3\x02\n\x13EnumDescrip\
    torProto\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12?\n\x05value\
    \x18\x02\x20\x03(\x0b2).google.protobuf.EnumValueDescriptorProtoR\x05val\
    ue\x126\n\x07options\x18\x03\x20\x01(\x0b2\x1c.google.protobuf.EnumOptio\
    nsR\x07options\x12]\n\x0ereserved_range\x18\x04\x20\x03(\x0b26.google.pr\
    otobuf.EnumDescriptorProto.EnumReservedRangeR\rreservedRange\x12#\n\rres\
    erved_name\x18\x05\x20\x03(\tR\x0creservedName\x1a;\n\x11EnumReservedRan\
    ge\x12\x14\n\x05start\x18\x01\x20\x01(\x05R\x05start\x12\x10\n\x03end\
    \x18\x02\x20\x01(\x05R\x03end\"\x83\x01\n\x18EnumValueDescriptorProto\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x16\n\x06number\x18\
    \x02\x20\x01(\x05R\x06number\x12;\n\x07options\x18\x03\x20\x01(\x0b2!.go\
    ogle.protobuf.EnumValueOptionsR\x07options\"\xa7\x01\n\x16ServiceDescrip\
    torProto\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12>\n\x06method\
    \x18\x02\x20\x03(\x0b2&.google.protobuf.MethodDescriptorProtoR\x06method\
    \x129\n\x07options\x18\x03\x20\x01(\x0b2\x1f.google.protobuf.ServiceOpti\
    onsR\x07options\"\x89\x02\n\x15MethodDescriptorProto\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12\x1d\n\ninput_type\x18\x02\x20\x01(\tR\t\
    inputType\x12\x1f\n\x0boutput_type\x18\x03\x20\x01(\tR\noutputType\x128\
    \n\x07options\x18\x04\x20\x01(\x0b2\x1e.google.protobuf.MethodOptionsR\
    \x07options\x120\n\x10client_streaming\x18\x05\x20\x01(\x08:\x05falseR\
    \x0fclientStreaming\x120\n\x10server_streaming\x18\x06\x20\x01(\x08:\x05\
    falseR\x0fserverStreaming\"\x91\t\n\x0bFileOptions\x12!\n\x0cjava_packag\
    e\x18\x01\x20\x01(\tR\x0bjavaPackage\x120\n\x14java_outer_classname\x18\
    \x08\x20\x01(\tR\x12javaOuterClassname\x125\n\x13java_multiple_files\x18\
    \n\x20\x01(\x08:\x05falseR\x11javaMultipleFiles\x12D\n\x1djava_generate_\
    equals_and_hash\x18\x14\x20\x01(\x08R\x19javaGenerateEqualsAndHashB\x02\
    \x18\x01\x12:\n\x16java_string_check_utf8\x18\x1b\x20\x01(\x08:\x05false\
    R\x13javaStringCheckUtf8\x12S\n\x0coptimize_for\x18\t\x20\x01(\x0e2).goo\
    gle.protobuf.FileOptions.OptimizeMode:\x05SPEEDR\x0boptimizeFor\x12\x1d\
    \n\ngo_package\x18\x0b\x20\x01(\tR\tgoPackage\x125\n\x13cc_generic_servi\
    ces\x18\x10\x20\x01(\x08:\x05falseR\x11ccGenericServices\x129\n\x15java_\
    generic_services\x18\x11\x20\x01(\x08:\x05falseR\x13javaGenericServices\
    \x125\n\x13py_generic_services\x18\x12\x20\x01(\x08:\x05falseR\x11pyGene\
    ricServices\x127\n\x14php_generic_services\x18*\x20\x01(\x08:\x05falseR\
    \x12phpGenericServices\x12%\n\ndeprecated\x18\x17\x20\x01(\x08:\x05false\
    R\ndeprecated\x12.\n\x10cc_enable_arenas\x18\x1f\x20\x01(\x08:\x04trueR\
    \x0eccEnableArenas\x12*\n\x11objc_class_prefix\x18$\x20\x01(\tR\x0fobjcC\
    lassPrefix\x12)\n\x10csharp_namespace\x18%\x20\x01(\tR\x0fcsharpNamespac\
    e\x12!\n\x0cswift_prefix\x18'\x20\x01(\tR\x0bswiftPrefix\x12(\n\x10php_c\
    lass_prefix\x18(\x20\x01(\tR\x0ephpClassPrefix\x12#\n\rphp_namespace\x18\
    )\x20\x01(\tR\x0cphpNamespace\x124\n\x16php_metadata_namespace\x18,\x20\
    \x01(\tR\x14phpMetadataNamespace\x12!\n\x0cruby_package\x18-\x20\x01(\tR\
    \x0brubyPackage\x12X\n\x14uninterpreted_option\x18\xe7\x07\x20\x03(\x0b2\
    $.google.protobuf.UninterpretedOptionR\x13uninterpretedOption\":\n\x0cOp\
    timizeMode\x12\t\n\x05SPEED\x10\x01\x12\r\n\tCODE_SIZE\x10\x02\x12\x10\n\
    \x0cLITE_RUNTIME\x10\x03*\t\x08\xe8\x07\x10\x80\x80\x80\x80\x02J\x04\x08\
    &\x10'\"\xe3\x02\n\x0eMessageOptions\x12<\n\x17message_set_wire_format\
    \x18\x01\x20\x01(\x08:\x05falseR\x14messageSetWireFormat\x12L\n\x1fno_st\
    andard_descriptor_accessor\x18\x02\x20\x01(\x08:\x05falseR\x1cnoStandard\
    DescriptorAccessor\x12%\n\ndeprecated\x18\x03\x20\x01(\x08:\x05falseR\nd\
    eprecated\x12\x1b\n\tmap_entry\x18\x07\x20\x01(\x08R\x08mapEntry\x12X\n\
    \x14uninterpreted_option\x18\xe7\x07\x20\x03(\x0b2$.google.protobuf.Unin\
    terpretedOptionR\x13uninterpretedOption*\t\x08\xe8\x07\x10\x80\x80\x80\
    \x80\x02J\x04\x08\x04\x10\x05J\x04\x08\x05\x10\x06J\x04\x08\x06\x10\x07J\
    \x04\x08\x08\x10\tJ\x04\x08\t\x10\n\"\xe2\x03\n\x0cFieldOptions\x12A\n\
    \x05ctype\x18\x01\x20\x01(\x0e2#.google.protobuf.FieldOptions.CType:\x06\
    STRINGR\x05ctype\x12\x16\n\x06packed\x18\x02\x20\x01(\x08R\x06packed\x12\
    G\n\x06jstype\x18\x06\x20\x01(\x0e2$.google.protobuf.FieldOptions.JSType\
    :\tJS_NORMALR\x06jstype\x12\x19\n\x04lazy\x18\x05\x20\x01(\x08:\x05false\
    R\x04lazy\x12%\n\ndeprecated\x18\x03\x20\x01(\x08:\x05falseR\ndeprecated\
    \x12\x19\n\x04weak\x18\n\x20\x01(\x08:\x05falseR\x04weak\x12X\n\x14unint\
    erpreted_option\x18\xe7\x07\x20\x03(\x0b2$.google.protobuf.Uninterpreted\
    OptionR\x13uninterpretedOption\"/\n\x05CType\x12\n\n\x06STRING\x10\0\x12\
    \x08\n\x04CORD\x10\x01\x12\x10\n\x0cSTRING_PIECE\x10\x02\"5\n\x06JSType\
    \x12\r\n\tJS_NORMAL\x10\0\x12\r\n\tJS_STRING\x10\x01\x12\r\n\tJS_NUMBER\
    \x10\x02*\t\x08\xe8\x07\x10\x80\x80\x80\x80\x02J\x04\x08\x04\x10\x05\"s\
    \n\x0cOneofOptions\x12X\n\x14uninterpreted_option\x18\xe7\x07\x20\x03(\
    \x0b2$.google.protobuf.UninterpretedOptionR\x13uninterpretedOption*\t\
    \x08\xe8\x07\x10\x80\x80\x80\x80\x02\"\xc0\x01\n\x0bEnumOptions\x12\x1f\
    \n\x0ballow_alias\x18\x02\x20\x01(\x08R\nallowAlias\x12%\n\ndeprecated\
    \x18\x03\x20\x01(\x08:\x05falseR\ndeprecated\x12X\n\x14uninterpreted_opt\
    ion\x18\xe7\x07\x20\x03(\x0b2$.google.protobuf.UninterpretedOptionR\x13u\
    ninterpretedOption*\t\x08\xe8\x07\x10\x80\x80\x80\x80\x02J\x04\x08\x05\
    \x10\x06\"\x9e\x01\n\x10EnumValueOptions\x12%\n\ndeprecated\x18\x01\x20\
    \x01(\x08:\x05falseR\ndeprecated\x12X\n\x14uninterpreted_option\x18\xe7\
    \x07\x20\x03(\x0b2$.google.protobuf.UninterpretedOptionR\x13uninterprete\
    dOption*\t\x08\xe8\x07\x10\x80\x80\x80\x80\x02\"\x9c\x01\n\x0eServiceOpt\
    ions\x12%\n\ndeprecated\x18!\x20\x01(\x08:\x05falseR\ndeprecated\x12X\n\
    \x14uninterpreted_option\x18\xe7\x07\x20\x03(\x0b2$.google.protobuf.Unin\
    terpretedOptionR\x13uninterpretedOption*\t\x08\xe8\x07\x10\x80\x80\x80\
    \x80\x02\"\xe0\x02\n\rMethodOptions\x12%\n\ndeprecated\x18!\x20\x01(\x08\
    :\x05falseR\ndeprecated\x12q\n\x11idempotency_level\x18\"\x20\x01(\x0e2/\
    .google.protobuf.MethodOptions.IdempotencyLevel:\x13IDEMPOTENCY_UNKNOWNR\
    \x10idempotencyLevel\x12X\n\x14uninterpreted_option\x18\xe7\x07\x20\x03(\
    \x0b2$.google.protobuf.UninterpretedOptionR\x13uninterpretedOption\"P\n\
    \x10IdempotencyLevel\x12\x17\n\x13IDEMPOTENCY_UNKNOWN\x10\0\x12\x13\n\
    \x0fNO_SIDE_EFFECTS\x10\x01\x12\x0e\n\nIDEMPOTENT\x10\x02*\t\x08\xe8\x07\
    \x10\x80\x80\x80\x80\x02\"\x9a\x03\n\x13UninterpretedOption\x12A\n\x04na\
    me\x18\x02\x20\x03(\x0b2-.google.protobuf.UninterpretedOption.NamePartR\
    \x04name\x12)\n\x10identifier_value\x18\x03\x20\x01(\tR\x0fidentifierVal\
    ue\x12,\n\x12positive_int_value\x18\x04\x20\x01(\x04R\x10positiveIntValu\
    e\x12,\n\x12negative_int_value\x18\x05\x20\x01(\x03R\x10negativeIntValue\
    \x12!\n\x0cdouble_value\x18\x06\x20\x01(\x01R\x0bdoubleValue\x12!\n\x0cs\
    tring_value\x18\x07\x20\x01(\x0cR\x0bstringValue\x12'\n\x0faggregate_val\
    ue\x18\x08\x20\x01(\tR\x0eaggregateValue\x1aJ\n\x08NamePart\x12\x1b\n\tn\
    ame_part\x18\x01\x20\x02(\tR\x08namePart\x12!\n\x0cis_extension\x18\x02\
    \x20\x02(\x08R\x0bisExtension\"\xa7\x02\n\x0eSourceCodeInfo\x12D\n\x08lo\
    cation\x18\x01\x20\x03(\x0b2(.google.protobuf.SourceCodeInfo.LocationR\
    \x08location\x1a\xce\x01\n\x08Location\x12\x16\n\x04path\x18\x01\x20\x03\
    (\x05R\x04pathB\x02\x10\x01\x12\x16\n\x04span\x18\x02\x20\x03(\x05R\x04s\
    panB\x02\x10\x01\x12)\n\x10leading_comments\x18\x03\x20\x01(\tR\x0fleadi\
    ngComments\x12+\n\x11trailing_comments\x18\x04\x20\x01(\tR\x10trailingCo\
    mments\x12:\n\x19leading_detached_comments\x18\x06\x20\x03(\tR\x17leadin\
    gDetachedComments\"\xd1\x01\n\x11GeneratedCodeInfo\x12M\n\nannotation\
    \x18\x01\x20\x03(\x0b2-.google.protobuf.GeneratedCodeInfo.AnnotationR\na\
    nnotation\x1am\n\nAnnotation\x12\x16\n\x04path\x18\x01\x20\x03(\x05R\x04\
    pathB\x02\x10\x01\x12\x1f\n\x0bsource_file\x18\x02\x20\x01(\tR\nsourceFi\
    le\x12\x14\n\x05begin\x18\x03\x20\x01(\x05R\x05begin\x12\x10\n\x03end\
    \x18\x04\x20\x01(\x05R\x03endB~\n\x13com.google.protobufB\x10DescriptorP\
    rotosH\x01Z-google.golang.org/protobuf/types/descriptorpb\xf8\x01\x01\
    \xa2\x02\x03GPB\xaa\x02\x1aGoogle.Protobuf.ReflectionJ\x82\xca\x02\n\x07\
    \x12\x05'\0\x8e\x07\x01\n\xaa\x0f\n\x01\x0c\x12\x03'\0\x122\xc1\x0c\x20P\
    rotocol\x20Buffers\x20-\x20Google's\x20data\x20interchange\x20format\n\
    \x20Copyright\x202008\x20Google\x20Inc.\x20\x20All\x20rights\x20reserved\
    .\n\x20https://developers.google.com/protocol-buffers/\n\n\x20Redistribu\
    tion\x20and\x20use\x20in\x20source\x20and\x20binary\x20forms,\x20with\
    \x20or\x20without\n\x20modification,\x20are\x20permitted\x20provided\x20\
    that\x20the\x20following\x20conditions\x20are\n\x20met:\n\n\x20\x20\x20\
    \x20\x20*\x20Redistributions\x20of\x20source\x20code\x20must\x20retain\
    \x20the\x20above\x20copyright\n\x20notice,\x20this\x20list\x20of\x20cond\
    itions\x20and\x20the\x20following\x20disclaimer.\n\x20\x20\x20\x20\x20*\
    \x20Redistributions\x20in\x20binary\x20form\x20must\x20reproduce\x20the\
    \x20above\n\x20copyright\x20notice,\x20this\x20list\x20of\x20conditions\
    \x20and\x20the\x20following\x20disclaimer\n\x20in\x20the\x20documentatio\
    n\x20and/or\x20other\x20materials\x20provided\x20with\x20the\n\x20distri\
    bution.\n\x20\x20\x20\x20\x20*\x20Neither\x20the\x20name\x20of\x20Google\
    \x20Inc.\x20nor\x20the\x20names\x20of\x20its\n\x20contributors\x20may\
    \x20be\x20used\x20to\x20endorse\x20or\x20promote\x20products\x20derived\
    \x20from\n\x20this\x20software\x20without\x20specific\x20prior\x20writte\
    n\x20permission.\n\n\x20THIS\x20SOFTWARE\x20IS\x20PROVIDED\x20BY\x20THE\
    \x20COPYRIGHT\x20HOLDERS\x20AND\x20CONTRIBUTORS\n\x20\"AS\x20IS\"\x20AND\
    \x20ANY\x20EXPRESS\x20OR\x20IMPLIED\x20WARRANTIES,\x20INCLUDING,\x20BUT\
    \x20NOT\n\x20LIMITED\x20TO,\x20THE\x20IMPLIED\x20WARRANTIES\x20OF\x20MER\
    CHANTABILITY\x20AND\x20FITNESS\x20FOR\n\x20A\x20PARTICULAR\x20PURPOSE\
    \x20ARE\x20DISCLAIMED.\x20IN\x20NO\x20EVENT\x20SHALL\x20THE\x20COPYRIGHT\
    \n\x20OWNER\x20OR\x20CONTRIBUTORS\x20BE\x20LIABLE\x20FOR\x20ANY\x20DIREC\
    T,\x20INDIRECT,\x20INCIDENTAL,\n\x20SPECIAL,\x20EXEMPLARY,\x20OR\x20CONS\
    EQUENTIAL\x20DAMAGES\x20(INCLUDING,\x20BUT\x20NOT\n\x20LIMITED\x20TO,\
    \x20PROCUREMENT\x20OF\x20SUBSTITUTE\x20GOODS\x20OR\x20SERVICES;\x20LOSS\
    \x20OF\x20USE,\n\x20DATA,\x20OR\x20PROFITS;\x20OR\x20BUSINESS\x20INTERRU\
    PTION)\x20HOWEVER\x20CAUSED\x20AND\x20ON\x20ANY\n\x20THEORY\x20OF\x20LIA\
    BILITY,\x20WHETHER\x20IN\x20CONTRACT,\x20STRICT\x20LIABILITY,\x20OR\x20T\
    ORT\n\x20(INCLUDING\x20NEGLIGENCE\x20OR\x20OTHERWISE)\x20ARISING\x20IN\
    \x20ANY\x20WAY\x20OUT\x20OF\x20THE\x20USE\n\x20OF\x20THIS\x20SOFTWARE,\
    \x20EVEN\x20IF\x20ADVISED\x20OF\x20THE\x20POSSIBILITY\x20OF\x20SUCH\x20D\
    AMAGE.\n2\xdb\x02\x20Author:\x20kenton@google.com\x20(Kenton\x20Varda)\n\
    \x20\x20Based\x20on\x20original\x20Protocol\x20Buffers\x20design\x20by\n\
    \x20\x20Sanjay\x20Ghemawat,\x20Jeff\x20Dean,\x20and\x20others.\n\n\x20Th\
    e\x20messages\x20in\x20this\x20file\x20describe\x20the\x20definitions\
    \x20found\x20in\x20.proto\x20files.\n\x20A\x20valid\x20.proto\x20file\
    \x20can\x20be\x20translated\x20directly\x20to\x20a\x20FileDescriptorProt\
    o\n\x20without\x20any\x20other\x20information\x20(e.g.\x20without\x20rea\
    ding\x20its\x20imports).\n\n\x08\n\x01\x02\x12\x03)\0\x18\n\x08\n\x01\
    \x08\x12\x03+\0D\n\t\n\x02\x08\x0b\x12\x03+\0D\n\x08\n\x01\x08\x12\x03,\
    \0,\n\t\n\x02\x08\x01\x12\x03,\0,\n\x08\n\x01\x08\x12\x03-\01\n\t\n\x02\
    \x08\x08\x12\x03-\01\n\x08\n\x01\x08\x12\x03.\07\n\t\n\x02\x08%\x12\x03.\
    \07\n\x08\n\x01\x08\x12\x03/\0!\n\t\n\x02\x08$\x12\x03/\0!\n\x08\n\x01\
    \x08\x12\x030\0\x1f\n\t\n\x02\x08\x1f\x12\x030\0\x1f\n\x08\n\x01\x08\x12\
    \x034\0\x1c\n\x7f\n\x02\x08\t\x12\x034\0\x1c\x1at\x20descriptor.proto\
    \x20must\x20be\x20optimized\x20for\x20speed\x20because\x20reflection-bas\
    ed\n\x20algorithms\x20don't\x20work\x20during\x20bootstrapping.\n\nj\n\
    \x02\x04\0\x12\x048\0:\x01\x1a^\x20The\x20protocol\x20compiler\x20can\
    \x20output\x20a\x20FileDescriptorSet\x20containing\x20the\x20.proto\n\
    \x20files\x20it\x20parses.\n\n\n\n\x03\x04\0\x01\x12\x038\x08\x19\n\x0b\
    \n\x04\x04\0\x02\0\x12\x039\x02(\n\x0c\n\x05\x04\0\x02\0\x04\x12\x039\
    \x02\n\n\x0c\n\x05\x04\0\x02\0\x06\x12\x039\x0b\x1e\n\x0c\n\x05\x04\0\
    \x02\0\x01\x12\x039\x1f#\n\x0c\n\x05\x04\0\x02\0\x03\x12\x039&'\n/\n\x02\
    \x04\x01\x12\x04=\0Z\x01\x1a#\x20Describes\x20a\x20complete\x20.proto\
    \x20file.\n\n\n\n\x03\x04\x01\x01\x12\x03=\x08\x1b\n9\n\x04\x04\x01\x02\
    \0\x12\x03>\x02\x1b\",\x20file\x20name,\x20relative\x20to\x20root\x20of\
    \x20source\x20tree\n\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03>\x02\n\n\x0c\
    \n\x05\x04\x01\x02\0\x05\x12\x03>\x0b\x11\n\x0c\n\x05\x04\x01\x02\0\x01\
    \x12\x03>\x12\x16\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03>\x19\x1a\n*\n\
    \x04\x04\x01\x02\x01\x12\x03?\x02\x1e\"\x1d\x20e.g.\x20\"foo\",\x20\"foo\
    .bar\",\x20etc.\n\n\x0c\n\x05\x04\x01\x02\x01\x04\x12\x03?\x02\n\n\x0c\n\
    \x05\x04\x01\x02\x01\x05\x12\x03?\x0b\x11\n\x0c\n\x05\x04\x01\x02\x01\
    \x01\x12\x03?\x12\x19\n\x0c\n\x05\x04\x01\x02\x01\x03\x12\x03?\x1c\x1d\n\
    4\n\x04\x04\x01\x02\x02\x12\x03B\x02!\x1a'\x20Names\x20of\x20files\x20im\
    ported\x20by\x20this\x20file.\n\n\x0c\n\x05\x04\x01\x02\x02\x04\x12\x03B\
    \x02\n\n\x0c\n\x05\x04\x01\x02\x02\x05\x12\x03B\x0b\x11\n\x0c\n\x05\x04\
    \x01\x02\x02\x01\x12\x03B\x12\x1c\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\
    \x03B\x1f\x20\nQ\n\x04\x04\x01\x02\x03\x12\x03D\x02(\x1aD\x20Indexes\x20\
    of\x20the\x20public\x20imported\x20files\x20in\x20the\x20dependency\x20l\
    ist\x20above.\n\n\x0c\n\x05\x04\x01\x02\x03\x04\x12\x03D\x02\n\n\x0c\n\
    \x05\x04\x01\x02\x03\x05\x12\x03D\x0b\x10\n\x0c\n\x05\x04\x01\x02\x03\
    \x01\x12\x03D\x11\"\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03D%'\nz\n\x04\
    \x04\x01\x02\x04\x12\x03G\x02&\x1am\x20Indexes\x20of\x20the\x20weak\x20i\
    mported\x20files\x20in\x20the\x20dependency\x20list.\n\x20For\x20Google-\
    internal\x20migration\x20only.\x20Do\x20not\x20use.\n\n\x0c\n\x05\x04\
    \x01\x02\x04\x04\x12\x03G\x02\n\n\x0c\n\x05\x04\x01\x02\x04\x05\x12\x03G\
    \x0b\x10\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03G\x11\x20\n\x0c\n\x05\
    \x04\x01\x02\x04\x03\x12\x03G#%\n6\n\x04\x04\x01\x02\x05\x12\x03J\x02,\
    \x1a)\x20All\x20top-level\x20definitions\x20in\x20this\x20file.\n\n\x0c\
    \n\x05\x04\x01\x02\x05\x04\x12\x03J\x02\n\n\x0c\n\x05\x04\x01\x02\x05\
    \x06\x12\x03J\x0b\x1a\n\x0c\n\x05\x04\x01\x02\x05\x01\x12\x03J\x1b'\n\
    \x0c\n\x05\x04\x01\x02\x05\x03\x12\x03J*+\n\x0b\n\x04\x04\x01\x02\x06\
    \x12\x03K\x02-\n\x0c\n\x05\x04\x01\x02\x06\x04\x12\x03K\x02\n\n\x0c\n\
    \x05\x04\x01\x02\x06\x06\x12\x03K\x0b\x1e\n\x0c\n\x05\x04\x01\x02\x06\
    \x01\x12\x03K\x1f(\n\x0c\n\x05\x04\x01\x02\x06\x03\x12\x03K+,\n\x0b\n\
    \x04\x04\x01\x02\x07\x12\x03L\x02.\n\x0c\n\x05\x04\x01\x02\x07\x04\x12\
    \x03L\x02\n\n\x0c\n\x05\x04\x01\x02\x07\x06\x12\x03L\x0b!\n\x0c\n\x05\
    \x04\x01\x02\x07\x01\x12\x03L\")\n\x0c\n\x05\x04\x01\x02\x07\x03\x12\x03\
    L,-\n\x0b\n\x04\x04\x01\x02\x08\x12\x03M\x02.\n\x0c\n\x05\x04\x01\x02\
    \x08\x04\x12\x03M\x02\n\n\x0c\n\x05\x04\x01\x02\x08\x06\x12\x03M\x0b\x1f\
    \n\x0c\n\x05\x04\x01\x02\x08\x01\x12\x03M\x20)\n\x0c\n\x05\x04\x01\x02\
    \x08\x03\x12\x03M,-\n\x0b\n\x04\x04\x01\x02\t\x12\x03O\x02#\n\x0c\n\x05\
    \x04\x01\x02\t\x04\x12\x03O\x02\n\n\x0c\n\x05\x04\x01\x02\t\x06\x12\x03O\
    \x0b\x16\n\x0c\n\x05\x04\x01\x02\t\x01\x12\x03O\x17\x1e\n\x0c\n\x05\x04\
    \x01\x02\t\x03\x12\x03O!\"\n\xf4\x01\n\x04\x04\x01\x02\n\x12\x03U\x02/\
    \x1a\xe6\x01\x20This\x20field\x20contains\x20optional\x20information\x20\
    about\x20the\x20original\x20source\x20code.\n\x20You\x20may\x20safely\
    \x20remove\x20this\x20entire\x20field\x20without\x20harming\x20runtime\n\
    \x20functionality\x20of\x20the\x20descriptors\x20--\x20the\x20informatio\
    n\x20is\x20needed\x20only\x20by\n\x20development\x20tools.\n\n\x0c\n\x05\
    \x04\x01\x02\n\x04\x12\x03U\x02\n\n\x0c\n\x05\x04\x01\x02\n\x06\x12\x03U\
    \x0b\x19\n\x0c\n\x05\x04\x01\x02\n\x01\x12\x03U\x1a*\n\x0c\n\x05\x04\x01\
    \x02\n\x03\x12\x03U-.\n]\n\x04\x04\x01\x02\x0b\x12\x03Y\x02\x1e\x1aP\x20\
    The\x20syntax\x20of\x20the\x20proto\x20file.\n\x20The\x20supported\x20va\
    lues\x20are\x20\"proto2\"\x20and\x20\"proto3\".\n\n\x0c\n\x05\x04\x01\
    \x02\x0b\x04\x12\x03Y\x02\n\n\x0c\n\x05\x04\x01\x02\x0b\x05\x12\x03Y\x0b\
    \x11\n\x0c\n\x05\x04\x01\x02\x0b\x01\x12\x03Y\x12\x18\n\x0c\n\x05\x04\
    \x01\x02\x0b\x03\x12\x03Y\x1b\x1d\n'\n\x02\x04\x02\x12\x04]\0}\x01\x1a\
    \x1b\x20Describes\x20a\x20message\x20type.\n\n\n\n\x03\x04\x02\x01\x12\
    \x03]\x08\x17\n\x0b\n\x04\x04\x02\x02\0\x12\x03^\x02\x1b\n\x0c\n\x05\x04\
    \x02\x02\0\x04\x12\x03^\x02\n\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03^\x0b\
    \x11\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03^\x12\x16\n\x0c\n\x05\x04\x02\
    \x02\0\x03\x12\x03^\x19\x1a\n\x0b\n\x04\x04\x02\x02\x01\x12\x03`\x02*\n\
    \x0c\n\x05\x04\x02\x02\x01\x04\x12\x03`\x02\n\n\x0c\n\x05\x04\x02\x02\
    \x01\x06\x12\x03`\x0b\x1f\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03`\x20%\
    \n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03`()\n\x0b\n\x04\x04\x02\x02\x02\
    \x12\x03a\x02.\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03a\x02\n\n\x0c\n\
    \x05\x04\x02\x02\x02\x06\x12\x03a\x0b\x1f\n\x0c\n\x05\x04\x02\x02\x02\
    \x01\x12\x03a\x20)\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03a,-\n\x0b\n\
    \x04\x04\x02\x02\x03\x12\x03c\x02+\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\
    \x03c\x02\n\n\x0c\n\x05\x04\x02\x02\x03\x06\x12\x03c\x0b\x1a\n\x0c\n\x05\
    \x04\x02\x02\x03\x01\x12\x03c\x1b&\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\
    \x03c)*\n\x0b\n\x04\x04\x02\x02\x04\x12\x03d\x02-\n\x0c\n\x05\x04\x02\
    \x02\x04\x04\x12\x03d\x02\n\n\x0c\n\x05\x04\x02\x02\x04\x06\x12\x03d\x0b\
    \x1e\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03d\x1f(\n\x0c\n\x05\x04\x02\
    \x02\x04\x03\x12\x03d+,\n\x0c\n\x04\x04\x02\x03\0\x12\x04f\x02k\x03\n\
    \x0c\n\x05\x04\x02\x03\0\x01\x12\x03f\n\x18\n\x1b\n\x06\x04\x02\x03\0\
    \x02\0\x12\x03g\x04\x1d\"\x0c\x20Inclusive.\n\n\x0e\n\x07\x04\x02\x03\0\
    \x02\0\x04\x12\x03g\x04\x0c\n\x0e\n\x07\x04\x02\x03\0\x02\0\x05\x12\x03g\
    \r\x12\n\x0e\n\x07\x04\x02\x03\0\x02\0\x01\x12\x03g\x13\x18\n\x0e\n\x07\
    \x04\x02\x03\0\x02\0\x03\x12\x03g\x1b\x1c\n\x1b\n\x06\x04\x02\x03\0\x02\
    \x01\x12\x03h\x04\x1b\"\x0c\x20Exclusive.\n\n\x0e\n\x07\x04\x02\x03\0\
    \x02\x01\x04\x12\x03h\x04\x0c\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x05\x12\
    \x03h\r\x12\n\x0e\n\x07\x04\x02\x03\0\x02\x01\x01\x12\x03h\x13\x16\n\x0e\
    \n\x07\x04\x02\x03\0\x02\x01\x03\x12\x03h\x19\x1a\n\r\n\x06\x04\x02\x03\
    \0\x02\x02\x12\x03j\x04/\n\x0e\n\x07\x04\x02\x03\0\x02\x02\x04\x12\x03j\
    \x04\x0c\n\x0e\n\x07\x04\x02\x03\0\x02\x02\x06\x12\x03j\r\"\n\x0e\n\x07\
    \x04\x02\x03\0\x02\x02\x01\x12\x03j#*\n\x0e\n\x07\x04\x02\x03\0\x02\x02\
    \x03\x12\x03j-.\n\x0b\n\x04\x04\x02\x02\x05\x12\x03l\x02.\n\x0c\n\x05\
    \x04\x02\x02\x05\x04\x12\x03l\x02\n\n\x0c\n\x05\x04\x02\x02\x05\x06\x12\
    \x03l\x0b\x19\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03l\x1a)\n\x0c\n\x05\
    \x04\x02\x02\x05\x03\x12\x03l,-\n\x0b\n\x04\x04\x02\x02\x06\x12\x03n\x02\
    /\n\x0c\n\x05\x04\x02\x02\x06\x04\x12\x03n\x02\n\n\x0c\n\x05\x04\x02\x02\
    \x06\x06\x12\x03n\x0b\x1f\n\x0c\n\x05\x04\x02\x02\x06\x01\x12\x03n\x20*\
    \n\x0c\n\x05\x04\x02\x02\x06\x03\x12\x03n-.\n\x0b\n\x04\x04\x02\x02\x07\
    \x12\x03p\x02&\n\x0c\n\x05\x04\x02\x02\x07\x04\x12\x03p\x02\n\n\x0c\n\
    \x05\x04\x02\x02\x07\x06\x12\x03p\x0b\x19\n\x0c\n\x05\x04\x02\x02\x07\
    \x01\x12\x03p\x1a!\n\x0c\n\x05\x04\x02\x02\x07\x03\x12\x03p$%\n\xaa\x01\
    \n\x04\x04\x02\x03\x01\x12\x04u\x02x\x03\x1a\x9b\x01\x20Range\x20of\x20r\
    eserved\x20tag\x20numbers.\x20Reserved\x20tag\x20numbers\x20may\x20not\
    \x20be\x20used\x20by\n\x20fields\x20or\x20extension\x20ranges\x20in\x20t\
    he\x20same\x20message.\x20Reserved\x20ranges\x20may\n\x20not\x20overlap.\
    \n\n\x0c\n\x05\x04\x02\x03\x01\x01\x12\x03u\n\x17\n\x1b\n\x06\x04\x02\
    \x03\x01\x02\0\x12\x03v\x04\x1d\"\x0c\x20Inclusive.\n\n\x0e\n\x07\x04\
    \x02\x03\x01\x02\0\x04\x12\x03v\x04\x0c\n\x0e\n\x07\x04\x02\x03\x01\x02\
    \0\x05\x12\x03v\r\x12\n\x0e\n\x07\x04\x02\x03\x01\x02\0\x01\x12\x03v\x13\
    \x18\n\x0e\n\x07\x04\x02\x03\x01\x02\0\x03\x12\x03v\x1b\x1c\n\x1b\n\x06\
    \x04\x02\x03\x01\x02\x01\x12\x03w\x04\x1b\"\x0c\x20Exclusive.\n\n\x0e\n\
    \x07\x04\x02\x03\x01\x02\x01\x04\x12\x03w\x04\x0c\n\x0e\n\x07\x04\x02\
    \x03\x01\x02\x01\x05\x12\x03w\r\x12\n\x0e\n\x07\x04\x02\x03\x01\x02\x01\
    \x01\x12\x03w\x13\x16\n\x0e\n\x07\x04\x02\x03\x01\x02\x01\x03\x12\x03w\
    \x19\x1a\n\x0b\n\x04\x04\x02\x02\x08\x12\x03y\x02,\n\x0c\n\x05\x04\x02\
    \x02\x08\x04\x12\x03y\x02\n\n\x0c\n\x05\x04\x02\x02\x08\x06\x12\x03y\x0b\
    \x18\n\x0c\n\x05\x04\x02\x02\x08\x01\x12\x03y\x19'\n\x0c\n\x05\x04\x02\
    \x02\x08\x03\x12\x03y*+\n\x82\x01\n\x04\x04\x02\x02\t\x12\x03|\x02%\x1au\
    \x20Reserved\x20field\x20names,\x20which\x20may\x20not\x20be\x20used\x20\
    by\x20fields\x20in\x20the\x20same\x20message.\n\x20A\x20given\x20name\
    \x20may\x20only\x20be\x20reserved\x20once.\n\n\x0c\n\x05\x04\x02\x02\t\
    \x04\x12\x03|\x02\n\n\x0c\n\x05\x04\x02\x02\t\x05\x12\x03|\x0b\x11\n\x0c\
    \n\x05\x04\x02\x02\t\x01\x12\x03|\x12\x1f\n\x0c\n\x05\x04\x02\x02\t\x03\
    \x12\x03|\"$\n\x0b\n\x02\x04\x03\x12\x05\x7f\0\x86\x01\x01\n\n\n\x03\x04\
    \x03\x01\x12\x03\x7f\x08\x1d\nO\n\x04\x04\x03\x02\0\x12\x04\x81\x01\x02:\
    \x1aA\x20The\x20parser\x20stores\x20options\x20it\x20doesn't\x20recogniz\
    e\x20here.\x20See\x20above.\n\n\r\n\x05\x04\x03\x02\0\x04\x12\x04\x81\
    \x01\x02\n\n\r\n\x05\x04\x03\x02\0\x06\x12\x04\x81\x01\x0b\x1e\n\r\n\x05\
    \x04\x03\x02\0\x01\x12\x04\x81\x01\x1f3\n\r\n\x05\x04\x03\x02\0\x03\x12\
    \x04\x81\x0169\nZ\n\x03\x04\x03\x05\x12\x04\x85\x01\x02\x19\x1aM\x20Clie\
    nts\x20can\x20define\x20custom\x20options\x20in\x20extensions\x20of\x20t\
    his\x20message.\x20See\x20above.\n\n\x0c\n\x04\x04\x03\x05\0\x12\x04\x85\
    \x01\r\x18\n\r\n\x05\x04\x03\x05\0\x01\x12\x04\x85\x01\r\x11\n\r\n\x05\
    \x04\x03\x05\0\x02\x12\x04\x85\x01\x15\x18\n3\n\x02\x04\x04\x12\x06\x89\
    \x01\0\xee\x01\x01\x1a%\x20Describes\x20a\x20field\x20within\x20a\x20mes\
    sage.\n\n\x0b\n\x03\x04\x04\x01\x12\x04\x89\x01\x08\x1c\n\x0e\n\x04\x04\
    \x04\x04\0\x12\x06\x8a\x01\x02\xa9\x01\x03\n\r\n\x05\x04\x04\x04\0\x01\
    \x12\x04\x8a\x01\x07\x0b\nS\n\x06\x04\x04\x04\0\x02\0\x12\x04\x8d\x01\
    \x04\x14\x1aC\x200\x20is\x20reserved\x20for\x20errors.\n\x20Order\x20is\
    \x20weird\x20for\x20historical\x20reasons.\n\n\x0f\n\x07\x04\x04\x04\0\
    \x02\0\x01\x12\x04\x8d\x01\x04\x0f\n\x0f\n\x07\x04\x04\x04\0\x02\0\x02\
    \x12\x04\x8d\x01\x12\x13\n\x0e\n\x06\x04\x04\x04\0\x02\x01\x12\x04\x8e\
    \x01\x04\x13\n\x0f\n\x07\x04\x04\x04\0\x02\x01\x01\x12\x04\x8e\x01\x04\
    \x0e\n\x0f\n\x07\x04\x04\x04\0\x02\x01\x02\x12\x04\x8e\x01\x11\x12\nw\n\
    \x06\x04\x04\x04\0\x02\x02\x12\x04\x91\x01\x04\x13\x1ag\x20Not\x20ZigZag\
    \x20encoded.\x20\x20Negative\x20numbers\x20take\x2010\x20bytes.\x20\x20U\
    se\x20TYPE_SINT64\x20if\n\x20negative\x20values\x20are\x20likely.\n\n\
    \x0f\n\x07\x04\x04\x04\0\x02\x02\x01\x12\x04\x91\x01\x04\x0e\n\x0f\n\x07\
    \x04\x04\x04\0\x02\x02\x02\x12\x04\x91\x01\x11\x12\n\x0e\n\x06\x04\x04\
    \x04\0\x02\x03\x12\x04\x92\x01\x04\x14\n\x0f\n\x07\x04\x04\x04\0\x02\x03\
    \x01\x12\x04\x92\x01\x04\x0f\n\x0f\n\x07\x04\x04\x04\0\x02\x03\x02\x12\
    \x04\x92\x01\x12\x13\nw\n\x06\x04\x04\x04\0\x02\x04\x12\x04\x95\x01\x04\
    \x13\x1ag\x20Not\x20ZigZag\x20encoded.\x20\x20Negative\x20numbers\x20tak\
    e\x2010\x20bytes.\x20\x20Use\x20TYPE_SINT32\x20if\n\x20negative\x20value\
    s\x20are\x20likely.\n\n\x0f\n\x07\x04\x04\x04\0\x02\x04\x01\x12\x04\x95\
    \x01\x04\x0e\n\x0f\n\x07\x04\x04\x04\0\x02\x04\x02\x12\x04\x95\x01\x11\
    \x12\n\x0e\n\x06\x04\x04\x04\0\x02\x05\x12\x04\x96\x01\x04\x15\n\x0f\n\
    \x07\x04\x04\x04\0\x02\x05\x01\x12\x04\x96\x01\x04\x10\n\x0f\n\x07\x04\
    \x04\x04\0\x02\x05\x02\x12\x04\x96\x01\x13\x14\n\x0e\n\x06\x04\x04\x04\0\
    \x02\x06\x12\x04\x97\x01\x04\x15\n\x0f\n\x07\x04\x04\x04\0\x02\x06\x01\
    \x12\x04\x97\x01\x04\x10\n\x0f\n\x07\x04\x04\x04\0\x02\x06\x02\x12\x04\
    \x97\x01\x13\x14\n\x0e\n\x06\x04\x04\x04\0\x02\x07\x12\x04\x98\x01\x04\
    \x12\n\x0f\n\x07\x04\x04\x04\0\x02\x07\x01\x12\x04\x98\x01\x04\r\n\x0f\n\
    \x07\x04\x04\x04\0\x02\x07\x02\x12\x04\x98\x01\x10\x11\n\x0e\n\x06\x04\
    \x04\x04\0\x02\x08\x12\x04\x99\x01\x04\x14\n\x0f\n\x07\x04\x04\x04\0\x02\
    \x08\x01\x12\x04\x99\x01\x04\x0f\n\x0f\n\x07\x04\x04\x04\0\x02\x08\x02\
    \x12\x04\x99\x01\x12\x13\n\xe2\x01\n\x06\x04\x04\x04\0\x02\t\x12\x04\x9e\
    \x01\x04\x14\x1a\xd1\x01\x20Tag-delimited\x20aggregate.\n\x20Group\x20ty\
    pe\x20is\x20deprecated\x20and\x20not\x20supported\x20in\x20proto3.\x20Ho\
    wever,\x20Proto3\n\x20implementations\x20should\x20still\x20be\x20able\
    \x20to\x20parse\x20the\x20group\x20wire\x20format\x20and\n\x20treat\x20g\
    roup\x20fields\x20as\x20unknown\x20fields.\n\n\x0f\n\x07\x04\x04\x04\0\
    \x02\t\x01\x12\x04\x9e\x01\x04\x0e\n\x0f\n\x07\x04\x04\x04\0\x02\t\x02\
    \x12\x04\x9e\x01\x11\x13\n-\n\x06\x04\x04\x04\0\x02\n\x12\x04\x9f\x01\
    \x04\x16\"\x1d\x20Length-delimited\x20aggregate.\n\n\x0f\n\x07\x04\x04\
    \x04\0\x02\n\x01\x12\x04\x9f\x01\x04\x10\n\x0f\n\x07\x04\x04\x04\0\x02\n\
    \x02\x12\x04\x9f\x01\x13\x15\n#\n\x06\x04\x04\x04\0\x02\x0b\x12\x04\xa2\
    \x01\x04\x14\x1a\x13\x20New\x20in\x20version\x202.\n\n\x0f\n\x07\x04\x04\
    \x04\0\x02\x0b\x01\x12\x04\xa2\x01\x04\x0e\n\x0f\n\x07\x04\x04\x04\0\x02\
    \x0b\x02\x12\x04\xa2\x01\x11\x13\n\x0e\n\x06\x04\x04\x04\0\x02\x0c\x12\
    \x04\xa3\x01\x04\x15\n\x0f\n\x07\x04\x04\x04\0\x02\x0c\x01\x12\x04\xa3\
    \x01\x04\x0f\n\x0f\n\x07\x04\x04\x04\0\x02\x0c\x02\x12\x04\xa3\x01\x12\
    \x14\n\x0e\n\x06\x04\x04\x04\0\x02\r\x12\x04\xa4\x01\x04\x13\n\x0f\n\x07\
    \x04\x04\x04\0\x02\r\x01\x12\x04\xa4\x01\x04\r\n\x0f\n\x07\x04\x04\x04\0\
    \x02\r\x02\x12\x04\xa4\x01\x10\x12\n\x0e\n\x06\x04\x04\x04\0\x02\x0e\x12\
    \x04\xa5\x01\x04\x17\n\x0f\n\x07\x04\x04\x04\0\x02\x0e\x01\x12\x04\xa5\
    \x01\x04\x11\n\x0f\n\x07\x04\x04\x04\0\x02\x0e\x02\x12\x04\xa5\x01\x14\
    \x16\n\x0e\n\x06\x04\x04\x04\0\x02\x0f\x12\x04\xa6\x01\x04\x17\n\x0f\n\
    \x07\x04\x04\x04\0\x02\x0f\x01\x12\x04\xa6\x01\x04\x11\n\x0f\n\x07\x04\
    \x04\x04\0\x02\x0f\x02\x12\x04\xa6\x01\x14\x16\n'\n\x06\x04\x04\x04\0\
    \x02\x10\x12\x04\xa7\x01\x04\x15\"\x17\x20Uses\x20ZigZag\x20encoding.\n\
    \n\x0f\n\x07\x04\x04\x04\0\x02\x10\x01\x12\x04\xa7\x01\x04\x0f\n\x0f\n\
    \x07\x04\x04\x04\0\x02\x10\x02\x12\x04\xa7\x01\x12\x14\n'\n\x06\x04\x04\
    \x04\0\x02\x11\x12\x04\xa8\x01\x04\x15\"\x17\x20Uses\x20ZigZag\x20encodi\
    ng.\n\n\x0f\n\x07\x04\x04\x04\0\x02\x11\x01\x12\x04\xa8\x01\x04\x0f\n\
    \x0f\n\x07\x04\x04\x04\0\x02\x11\x02\x12\x04\xa8\x01\x12\x14\n\x0e\n\x04\
    \x04\x04\x04\x01\x12\x06\xab\x01\x02\xb0\x01\x03\n\r\n\x05\x04\x04\x04\
    \x01\x01\x12\x04\xab\x01\x07\x0c\n*\n\x06\x04\x04\x04\x01\x02\0\x12\x04\
    \xad\x01\x04\x17\x1a\x1a\x200\x20is\x20reserved\x20for\x20errors\n\n\x0f\
    \n\x07\x04\x04\x04\x01\x02\0\x01\x12\x04\xad\x01\x04\x12\n\x0f\n\x07\x04\
    \x04\x04\x01\x02\0\x02\x12\x04\xad\x01\x15\x16\n\x0e\n\x06\x04\x04\x04\
    \x01\x02\x01\x12\x04\xae\x01\x04\x17\n\x0f\n\x07\x04\x04\x04\x01\x02\x01\
    \x01\x12\x04\xae\x01\x04\x12\n\x0f\n\x07\x04\x04\x04\x01\x02\x01\x02\x12\
    \x04\xae\x01\x15\x16\n\x0e\n\x06\x04\x04\x04\x01\x02\x02\x12\x04\xaf\x01\
    \x04\x17\n\x0f\n\x07\x04\x04\x04\x01\x02\x02\x01\x12\x04\xaf\x01\x04\x12\
    \n\x0f\n\x07\x04\x04\x04\x01\x02\x02\x02\x12\x04\xaf\x01\x15\x16\n\x0c\n\
    \x04\x04\x04\x02\0\x12\x04\xb2\x01\x02\x1b\n\r\n\x05\x04\x04\x02\0\x04\
    \x12\x04\xb2\x01\x02\n\n\r\n\x05\x04\x04\x02\0\x05\x12\x04\xb2\x01\x0b\
    \x11\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xb2\x01\x12\x16\n\r\n\x05\x04\
    \x04\x02\0\x03\x12\x04\xb2\x01\x19\x1a\n\x0c\n\x04\x04\x04\x02\x01\x12\
    \x04\xb3\x01\x02\x1c\n\r\n\x05\x04\x04\x02\x01\x04\x12\x04\xb3\x01\x02\n\
    \n\r\n\x05\x04\x04\x02\x01\x05\x12\x04\xb3\x01\x0b\x10\n\r\n\x05\x04\x04\
    \x02\x01\x01\x12\x04\xb3\x01\x11\x17\n\r\n\x05\x04\x04\x02\x01\x03\x12\
    \x04\xb3\x01\x1a\x1b\n\x0c\n\x04\x04\x04\x02\x02\x12\x04\xb4\x01\x02\x1b\
    \n\r\n\x05\x04\x04\x02\x02\x04\x12\x04\xb4\x01\x02\n\n\r\n\x05\x04\x04\
    \x02\x02\x06\x12\x04\xb4\x01\x0b\x10\n\r\n\x05\x04\x04\x02\x02\x01\x12\
    \x04\xb4\x01\x11\x16\n\r\n\x05\x04\x04\x02\x02\x03\x12\x04\xb4\x01\x19\
    \x1a\n\x9c\x01\n\x04\x04\x04\x02\x03\x12\x04\xb8\x01\x02\x19\x1a\x8d\x01\
    \x20If\x20type_name\x20is\x20set,\x20this\x20need\x20not\x20be\x20set.\
    \x20\x20If\x20both\x20this\x20and\x20type_name\n\x20are\x20set,\x20this\
    \x20must\x20be\x20one\x20of\x20TYPE_ENUM,\x20TYPE_MESSAGE\x20or\x20TYPE_\
    GROUP.\n\n\r\n\x05\x04\x04\x02\x03\x04\x12\x04\xb8\x01\x02\n\n\r\n\x05\
    \x04\x04\x02\x03\x06\x12\x04\xb8\x01\x0b\x0f\n\r\n\x05\x04\x04\x02\x03\
    \x01\x12\x04\xb8\x01\x10\x14\n\r\n\x05\x04\x04\x02\x03\x03\x12\x04\xb8\
    \x01\x17\x18\n\xb7\x02\n\x04\x04\x04\x02\x04\x12\x04\xbf\x01\x02\x20\x1a\
    \xa8\x02\x20For\x20message\x20and\x20enum\x20types,\x20this\x20is\x20the\
    \x20name\x20of\x20the\x20type.\x20\x20If\x20the\x20name\n\x20starts\x20w\
    ith\x20a\x20'.',\x20it\x20is\x20fully-qualified.\x20\x20Otherwise,\x20C+\
    +-like\x20scoping\n\x20rules\x20are\x20used\x20to\x20find\x20the\x20type\
    \x20(i.e.\x20first\x20the\x20nested\x20types\x20within\x20this\n\x20mess\
    age\x20are\x20searched,\x20then\x20within\x20the\x20parent,\x20on\x20up\
    \x20to\x20the\x20root\n\x20namespace).\n\n\r\n\x05\x04\x04\x02\x04\x04\
    \x12\x04\xbf\x01\x02\n\n\r\n\x05\x04\x04\x02\x04\x05\x12\x04\xbf\x01\x0b\
    \x11\n\r\n\x05\x04\x04\x02\x04\x01\x12\x04\xbf\x01\x12\x1b\n\r\n\x05\x04\
    \x04\x02\x04\x03\x12\x04\xbf\x01\x1e\x1f\n~\n\x04\x04\x04\x02\x05\x12\
    \x04\xc3\x01\x02\x1f\x1ap\x20For\x20extensions,\x20this\x20is\x20the\x20\
    name\x20of\x20the\x20type\x20being\x20extended.\x20\x20It\x20is\n\x20res\
    olved\x20in\x20the\x20same\x20manner\x20as\x20type_name.\n\n\r\n\x05\x04\
    \x04\x02\x05\x04\x12\x04\xc3\x01\x02\n\n\r\n\x05\x04\x04\x02\x05\x05\x12\
    \x04\xc3\x01\x0b\x11\n\r\n\x05\x04\x04\x02\x05\x01\x12\x04\xc3\x01\x12\
    \x1a\n\r\n\x05\x04\x04\x02\x05\x03\x12\x04\xc3\x01\x1d\x1e\n\xb1\x02\n\
    \x04\x04\x04\x02\x06\x12\x04\xca\x01\x02$\x1a\xa2\x02\x20For\x20numeric\
    \x20types,\x20contains\x20the\x20original\x20text\x20representation\x20o\
    f\x20the\x20value.\n\x20For\x20booleans,\x20\"true\"\x20or\x20\"false\".\
    \n\x20For\x20strings,\x20contains\x20the\x20default\x20text\x20contents\
    \x20(not\x20escaped\x20in\x20any\x20way).\n\x20For\x20bytes,\x20contains\
    \x20the\x20C\x20escaped\x20value.\x20\x20All\x20bytes\x20>=\x20128\x20ar\
    e\x20escaped.\n\x20TODO(kenton):\x20\x20Base-64\x20encode?\n\n\r\n\x05\
    \x04\x04\x02\x06\x04\x12\x04\xca\x01\x02\n\n\r\n\x05\x04\x04\x02\x06\x05\
    \x12\x04\xca\x01\x0b\x11\n\r\n\x05\x04\x04\x02\x06\x01\x12\x04\xca\x01\
    \x12\x1f\n\r\n\x05\x04\x04\x02\x06\x03\x12\x04\xca\x01\"#\n\x84\x01\n\
    \x04\x04\x04\x02\x07\x12\x04\xce\x01\x02!\x1av\x20If\x20set,\x20gives\
    \x20the\x20index\x20of\x20a\x20oneof\x20in\x20the\x20containing\x20type'\
    s\x20oneof_decl\n\x20list.\x20\x20This\x20field\x20is\x20a\x20member\x20\
    of\x20that\x20oneof.\n\n\r\n\x05\x04\x04\x02\x07\x04\x12\x04\xce\x01\x02\
    \n\n\r\n\x05\x04\x04\x02\x07\x05\x12\x04\xce\x01\x0b\x10\n\r\n\x05\x04\
    \x04\x02\x07\x01\x12\x04\xce\x01\x11\x1c\n\r\n\x05\x04\x04\x02\x07\x03\
    \x12\x04\xce\x01\x1f\x20\n\xfa\x01\n\x04\x04\x04\x02\x08\x12\x04\xd4\x01\
    \x02!\x1a\xeb\x01\x20JSON\x20name\x20of\x20this\x20field.\x20The\x20valu\
    e\x20is\x20set\x20by\x20protocol\x20compiler.\x20If\x20the\n\x20user\x20\
    has\x20set\x20a\x20\"json_name\"\x20option\x20on\x20this\x20field,\x20th\
    at\x20option's\x20value\n\x20will\x20be\x20used.\x20Otherwise,\x20it's\
    \x20deduced\x20from\x20the\x20field's\x20name\x20by\x20converting\n\x20i\
    t\x20to\x20camelCase.\n\n\r\n\x05\x04\x04\x02\x08\x04\x12\x04\xd4\x01\
    \x02\n\n\r\n\x05\x04\x04\x02\x08\x05\x12\x04\xd4\x01\x0b\x11\n\r\n\x05\
    \x04\x04\x02\x08\x01\x12\x04\xd4\x01\x12\x1b\n\r\n\x05\x04\x04\x02\x08\
    \x03\x12\x04\xd4\x01\x1e\x20\n\x0c\n\x04\x04\x04\x02\t\x12\x04\xd6\x01\
    \x02$\n\r\n\x05\x04\x04\x02\t\x04\x12\x04\xd6\x01\x02\n\n\r\n\x05\x04\
    \x04\x02\t\x06\x12\x04\xd6\x01\x0b\x17\n\r\n\x05\x04\x04\x02\t\x01\x12\
    \x04\xd6\x01\x18\x1f\n\r\n\x05\x04\x04\x02\t\x03\x12\x04\xd6\x01\"#\n\
    \xb3\t\n\x04\x04\x04\x02\n\x12\x04\xed\x01\x02%\x1a\xa4\t\x20If\x20true,\
    \x20this\x20is\x20a\x20proto3\x20\"optional\".\x20When\x20a\x20proto3\
    \x20field\x20is\x20optional,\x20it\n\x20tracks\x20presence\x20regardless\
    \x20of\x20field\x20type.\n\n\x20When\x20proto3_optional\x20is\x20true,\
    \x20this\x20field\x20must\x20be\x20belong\x20to\x20a\x20oneof\x20to\n\
    \x20signal\x20to\x20old\x20proto3\x20clients\x20that\x20presence\x20is\
    \x20tracked\x20for\x20this\x20field.\x20This\n\x20oneof\x20is\x20known\
    \x20as\x20a\x20\"synthetic\"\x20oneof,\x20and\x20this\x20field\x20must\
    \x20be\x20its\x20sole\n\x20member\x20(each\x20proto3\x20optional\x20fiel\
    d\x20gets\x20its\x20own\x20synthetic\x20oneof).\x20Synthetic\n\x20oneofs\
    \x20exist\x20in\x20the\x20descriptor\x20only,\x20and\x20do\x20not\x20gen\
    erate\x20any\x20API.\x20Synthetic\n\x20oneofs\x20must\x20be\x20ordered\
    \x20after\x20all\x20\"real\"\x20oneofs.\n\n\x20For\x20message\x20fields,\
    \x20proto3_optional\x20doesn't\x20create\x20any\x20semantic\x20change,\n\
    \x20since\x20non-repeated\x20message\x20fields\x20always\x20track\x20pre\
    sence.\x20However\x20it\x20still\n\x20indicates\x20the\x20semantic\x20de\
    tail\x20of\x20whether\x20the\x20user\x20wrote\x20\"optional\"\x20or\x20n\
    ot.\n\x20This\x20can\x20be\x20useful\x20for\x20round-tripping\x20the\x20\
    .proto\x20file.\x20For\x20consistency\x20we\n\x20give\x20message\x20fiel\
    ds\x20a\x20synthetic\x20oneof\x20also,\x20even\x20though\x20it\x20is\x20\
    not\x20required\n\x20to\x20track\x20presence.\x20This\x20is\x20especiall\
    y\x20important\x20because\x20the\x20parser\x20can't\n\x20tell\x20if\x20a\
    \x20field\x20is\x20a\x20message\x20or\x20an\x20enum,\x20so\x20it\x20must\
    \x20always\x20create\x20a\n\x20synthetic\x20oneof.\n\n\x20Proto2\x20opti\
    onal\x20fields\x20do\x20not\x20set\x20this\x20flag,\x20because\x20they\
    \x20already\x20indicate\n\x20optional\x20with\x20`LABEL_OPTIONAL`.\n\n\r\
    \n\x05\x04\x04\x02\n\x04\x12\x04\xed\x01\x02\n\n\r\n\x05\x04\x04\x02\n\
    \x05\x12\x04\xed\x01\x0b\x0f\n\r\n\x05\x04\x04\x02\n\x01\x12\x04\xed\x01\
    \x10\x1f\n\r\n\x05\x04\x04\x02\n\x03\x12\x04\xed\x01\"$\n\"\n\x02\x04\
    \x05\x12\x06\xf1\x01\0\xf4\x01\x01\x1a\x14\x20Describes\x20a\x20oneof.\n\
    \n\x0b\n\x03\x04\x05\x01\x12\x04\xf1\x01\x08\x1c\n\x0c\n\x04\x04\x05\x02\
    \0\x12\x04\xf2\x01\x02\x1b\n\r\n\x05\x04\x05\x02\0\x04\x12\x04\xf2\x01\
    \x02\n\n\r\n\x05\x04\x05\x02\0\x05\x12\x04\xf2\x01\x0b\x11\n\r\n\x05\x04\
    \x05\x02\0\x01\x12\x04\xf2\x01\x12\x16\n\r\n\x05\x04\x05\x02\0\x03\x12\
    \x04\xf2\x01\x19\x1a\n\x0c\n\x04\x04\x05\x02\x01\x12\x04\xf3\x01\x02$\n\
    \r\n\x05\x04\x05\x02\x01\x04\x12\x04\xf3\x01\x02\n\n\r\n\x05\x04\x05\x02\
    \x01\x06\x12\x04\xf3\x01\x0b\x17\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\
    \xf3\x01\x18\x1f\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\xf3\x01\"#\n'\n\
    \x02\x04\x06\x12\x06\xf7\x01\0\x91\x02\x01\x1a\x19\x20Describes\x20an\
    \x20enum\x20type.\n\n\x0b\n\x03\x04\x06\x01\x12\x04\xf7\x01\x08\x1b\n\
    \x0c\n\x04\x04\x06\x02\0\x12\x04\xf8\x01\x02\x1b\n\r\n\x05\x04\x06\x02\0\
    \x04\x12\x04\xf8\x01\x02\n\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\xf8\x01\
    \x0b\x11\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xf8\x01\x12\x16\n\r\n\x05\
    \x04\x06\x02\0\x03\x12\x04\xf8\x01\x19\x1a\n\x0c\n\x04\x04\x06\x02\x01\
    \x12\x04\xfa\x01\x02.\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04\xfa\x01\x02\
    \n\n\r\n\x05\x04\x06\x02\x01\x06\x12\x04\xfa\x01\x0b#\n\r\n\x05\x04\x06\
    \x02\x01\x01\x12\x04\xfa\x01$)\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xfa\
    \x01,-\n\x0c\n\x04\x04\x06\x02\x02\x12\x04\xfc\x01\x02#\n\r\n\x05\x04\
    \x06\x02\x02\x04\x12\x04\xfc\x01\x02\n\n\r\n\x05\x04\x06\x02\x02\x06\x12\
    \x04\xfc\x01\x0b\x16\n\r\n\x05\x04\x06\x02\x02\x01\x12\x04\xfc\x01\x17\
    \x1e\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\xfc\x01!\"\n\xaf\x02\n\x04\
    \x04\x06\x03\0\x12\x06\x84\x02\x02\x87\x02\x03\x1a\x9e\x02\x20Range\x20o\
    f\x20reserved\x20numeric\x20values.\x20Reserved\x20values\x20may\x20not\
    \x20be\x20used\x20by\n\x20entries\x20in\x20the\x20same\x20enum.\x20Reser\
    ved\x20ranges\x20may\x20not\x20overlap.\n\n\x20Note\x20that\x20this\x20i\
    s\x20distinct\x20from\x20DescriptorProto.ReservedRange\x20in\x20that\x20\
    it\n\x20is\x20inclusive\x20such\x20that\x20it\x20can\x20appropriately\
    \x20represent\x20the\x20entire\x20int32\n\x20domain.\n\n\r\n\x05\x04\x06\
    \x03\0\x01\x12\x04\x84\x02\n\x1b\n\x1c\n\x06\x04\x06\x03\0\x02\0\x12\x04\
    \x85\x02\x04\x1d\"\x0c\x20Inclusive.\n\n\x0f\n\x07\x04\x06\x03\0\x02\0\
    \x04\x12\x04\x85\x02\x04\x0c\n\x0f\n\x07\x04\x06\x03\0\x02\0\x05\x12\x04\
    \x85\x02\r\x12\n\x0f\n\x07\x04\x06\x03\0\x02\0\x01\x12\x04\x85\x02\x13\
    \x18\n\x0f\n\x07\x04\x06\x03\0\x02\0\x03\x12\x04\x85\x02\x1b\x1c\n\x1c\n\
    \x06\x04\x06\x03\0\x02\x01\x12\x04\x86\x02\x04\x1b\"\x0c\x20Inclusive.\n\
    \n\x0f\n\x07\x04\x06\x03\0\x02\x01\x04\x12\x04\x86\x02\x04\x0c\n\x0f\n\
    \x07\x04\x06\x03\0\x02\x01\x05\x12\x04\x86\x02\r\x12\n\x0f\n\x07\x04\x06\
    \x03\0\x02\x01\x01\x12\x04\x86\x02\x13\x16\n\x0f\n\x07\x04\x06\x03\0\x02\
    \x01\x03\x12\x04\x86\x02\x19\x1a\n\xaa\x01\n\x04\x04\x06\x02\x03\x12\x04\
    \x8c\x02\x020\x1a\x9b\x01\x20Range\x20of\x20reserved\x20numeric\x20value\
    s.\x20Reserved\x20numeric\x20values\x20may\x20not\x20be\x20used\n\x20by\
    \x20enum\x20values\x20in\x20the\x20same\x20enum\x20declaration.\x20Reser\
    ved\x20ranges\x20may\x20not\n\x20overlap.\n\n\r\n\x05\x04\x06\x02\x03\
    \x04\x12\x04\x8c\x02\x02\n\n\r\n\x05\x04\x06\x02\x03\x06\x12\x04\x8c\x02\
    \x0b\x1c\n\r\n\x05\x04\x06\x02\x03\x01\x12\x04\x8c\x02\x1d+\n\r\n\x05\
    \x04\x06\x02\x03\x03\x12\x04\x8c\x02./\nl\n\x04\x04\x06\x02\x04\x12\x04\
    \x90\x02\x02$\x1a^\x20Reserved\x20enum\x20value\x20names,\x20which\x20ma\
    y\x20not\x20be\x20reused.\x20A\x20given\x20name\x20may\x20only\n\x20be\
    \x20reserved\x20once.\n\n\r\n\x05\x04\x06\x02\x04\x04\x12\x04\x90\x02\
    \x02\n\n\r\n\x05\x04\x06\x02\x04\x05\x12\x04\x90\x02\x0b\x11\n\r\n\x05\
    \x04\x06\x02\x04\x01\x12\x04\x90\x02\x12\x1f\n\r\n\x05\x04\x06\x02\x04\
    \x03\x12\x04\x90\x02\"#\n1\n\x02\x04\x07\x12\x06\x94\x02\0\x99\x02\x01\
    \x1a#\x20Describes\x20a\x20value\x20within\x20an\x20enum.\n\n\x0b\n\x03\
    \x04\x07\x01\x12\x04\x94\x02\x08\x20\n\x0c\n\x04\x04\x07\x02\0\x12\x04\
    \x95\x02\x02\x1b\n\r\n\x05\x04\x07\x02\0\x04\x12\x04\x95\x02\x02\n\n\r\n\
    \x05\x04\x07\x02\0\x05\x12\x04\x95\x02\x0b\x11\n\r\n\x05\x04\x07\x02\0\
    \x01\x12\x04\x95\x02\x12\x16\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\x95\x02\
    \x19\x1a\n\x0c\n\x04\x04\x07\x02\x01\x12\x04\x96\x02\x02\x1c\n\r\n\x05\
    \x04\x07\x02\x01\x04\x12\x04\x96\x02\x02\n\n\r\n\x05\x04\x07\x02\x01\x05\
    \x12\x04\x96\x02\x0b\x10\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\x96\x02\
    \x11\x17\n\r\n\x05\x04\x07\x02\x01\x03\x12\x04\x96\x02\x1a\x1b\n\x0c\n\
    \x04\x04\x07\x02\x02\x12\x04\x98\x02\x02(\n\r\n\x05\x04\x07\x02\x02\x04\
    \x12\x04\x98\x02\x02\n\n\r\n\x05\x04\x07\x02\x02\x06\x12\x04\x98\x02\x0b\
    \x1b\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\x98\x02\x1c#\n\r\n\x05\x04\
    \x07\x02\x02\x03\x12\x04\x98\x02&'\n$\n\x02\x04\x08\x12\x06\x9c\x02\0\
    \xa1\x02\x01\x1a\x16\x20Describes\x20a\x20service.\n\n\x0b\n\x03\x04\x08\
    \x01\x12\x04\x9c\x02\x08\x1e\n\x0c\n\x04\x04\x08\x02\0\x12\x04\x9d\x02\
    \x02\x1b\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\x9d\x02\x02\n\n\r\n\x05\x04\
    \x08\x02\0\x05\x12\x04\x9d\x02\x0b\x11\n\r\n\x05\x04\x08\x02\0\x01\x12\
    \x04\x9d\x02\x12\x16\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x9d\x02\x19\x1a\
    \n\x0c\n\x04\x04\x08\x02\x01\x12\x04\x9e\x02\x02,\n\r\n\x05\x04\x08\x02\
    \x01\x04\x12\x04\x9e\x02\x02\n\n\r\n\x05\x04\x08\x02\x01\x06\x12\x04\x9e\
    \x02\x0b\x20\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\x9e\x02!'\n\r\n\x05\
    \x04\x08\x02\x01\x03\x12\x04\x9e\x02*+\n\x0c\n\x04\x04\x08\x02\x02\x12\
    \x04\xa0\x02\x02&\n\r\n\x05\x04\x08\x02\x02\x04\x12\x04\xa0\x02\x02\n\n\
    \r\n\x05\x04\x08\x02\x02\x06\x12\x04\xa0\x02\x0b\x19\n\r\n\x05\x04\x08\
    \x02\x02\x01\x12\x04\xa0\x02\x1a!\n\r\n\x05\x04\x08\x02\x02\x03\x12\x04\
    \xa0\x02$%\n0\n\x02\x04\t\x12\x06\xa4\x02\0\xb2\x02\x01\x1a\"\x20Describ\
    es\x20a\x20method\x20of\x20a\x20service.\n\n\x0b\n\x03\x04\t\x01\x12\x04\
    \xa4\x02\x08\x1d\n\x0c\n\x04\x04\t\x02\0\x12\x04\xa5\x02\x02\x1b\n\r\n\
    \x05\x04\t\x02\0\x04\x12\x04\xa5\x02\x02\n\n\r\n\x05\x04\t\x02\0\x05\x12\
    \x04\xa5\x02\x0b\x11\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xa5\x02\x12\x16\n\
    \r\n\x05\x04\t\x02\0\x03\x12\x04\xa5\x02\x19\x1a\n\x97\x01\n\x04\x04\t\
    \x02\x01\x12\x04\xa9\x02\x02!\x1a\x88\x01\x20Input\x20and\x20output\x20t\
    ype\x20names.\x20\x20These\x20are\x20resolved\x20in\x20the\x20same\x20wa\
    y\x20as\n\x20FieldDescriptorProto.type_name,\x20but\x20must\x20refer\x20\
    to\x20a\x20message\x20type.\n\n\r\n\x05\x04\t\x02\x01\x04\x12\x04\xa9\
    \x02\x02\n\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\xa9\x02\x0b\x11\n\r\n\x05\
    \x04\t\x02\x01\x01\x12\x04\xa9\x02\x12\x1c\n\r\n\x05\x04\t\x02\x01\x03\
    \x12\x04\xa9\x02\x1f\x20\n\x0c\n\x04\x04\t\x02\x02\x12\x04\xaa\x02\x02\"\
    \n\r\n\x05\x04\t\x02\x02\x04\x12\x04\xaa\x02\x02\n\n\r\n\x05\x04\t\x02\
    \x02\x05\x12\x04\xaa\x02\x0b\x11\n\r\n\x05\x04\t\x02\x02\x01\x12\x04\xaa\
    \x02\x12\x1d\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xaa\x02\x20!\n\x0c\n\
    \x04\x04\t\x02\x03\x12\x04\xac\x02\x02%\n\r\n\x05\x04\t\x02\x03\x04\x12\
    \x04\xac\x02\x02\n\n\r\n\x05\x04\t\x02\x03\x06\x12\x04\xac\x02\x0b\x18\n\
    \r\n\x05\x04\t\x02\x03\x01\x12\x04\xac\x02\x19\x20\n\r\n\x05\x04\t\x02\
    \x03\x03\x12\x04\xac\x02#$\nE\n\x04\x04\t\x02\x04\x12\x04\xaf\x02\x027\
    \x1a7\x20Identifies\x20if\x20client\x20streams\x20multiple\x20client\x20\
    messages\n\n\r\n\x05\x04\t\x02\x04\x04\x12\x04\xaf\x02\x02\n\n\r\n\x05\
    \x04\t\x02\x04\x05\x12\x04\xaf\x02\x0b\x0f\n\r\n\x05\x04\t\x02\x04\x01\
    \x12\x04\xaf\x02\x10\x20\n\r\n\x05\x04\t\x02\x04\x03\x12\x04\xaf\x02#$\n\
    \r\n\x05\x04\t\x02\x04\x08\x12\x04\xaf\x02%6\n\r\n\x05\x04\t\x02\x04\x07\
    \x12\x04\xaf\x0205\nE\n\x04\x04\t\x02\x05\x12\x04\xb1\x02\x027\x1a7\x20I\
    dentifies\x20if\x20server\x20streams\x20multiple\x20server\x20messages\n\
    \n\r\n\x05\x04\t\x02\x05\x04\x12\x04\xb1\x02\x02\n\n\r\n\x05\x04\t\x02\
    \x05\x05\x12\x04\xb1\x02\x0b\x0f\n\r\n\x05\x04\t\x02\x05\x01\x12\x04\xb1\
    \x02\x10\x20\n\r\n\x05\x04\t\x02\x05\x03\x12\x04\xb1\x02#$\n\r\n\x05\x04\
    \t\x02\x05\x08\x12\x04\xb1\x02%6\n\r\n\x05\x04\t\x02\x05\x07\x12\x04\xb1\
    \x0205\n\xaf\x0e\n\x02\x04\n\x12\x06\xd5\x02\0\xd0\x03\x012N\x20========\
    ===========================================================\n\x20Options\
    \n2\xd0\r\x20Each\x20of\x20the\x20definitions\x20above\x20may\x20have\
    \x20\"options\"\x20attached.\x20\x20These\x20are\n\x20just\x20annotation\
    s\x20which\x20may\x20cause\x20code\x20to\x20be\x20generated\x20slightly\
    \x20differently\n\x20or\x20may\x20contain\x20hints\x20for\x20code\x20tha\
    t\x20manipulates\x20protocol\x20messages.\n\n\x20Clients\x20may\x20defin\
    e\x20custom\x20options\x20as\x20extensions\x20of\x20the\x20*Options\x20m\
    essages.\n\x20These\x20extensions\x20may\x20not\x20yet\x20be\x20known\
    \x20at\x20parsing\x20time,\x20so\x20the\x20parser\x20cannot\n\x20store\
    \x20the\x20values\x20in\x20them.\x20\x20Instead\x20it\x20stores\x20them\
    \x20in\x20a\x20field\x20in\x20the\x20*Options\n\x20message\x20called\x20\
    uninterpreted_option.\x20This\x20field\x20must\x20have\x20the\x20same\
    \x20name\n\x20across\x20all\x20*Options\x20messages.\x20We\x20then\x20us\
    e\x20this\x20field\x20to\x20populate\x20the\n\x20extensions\x20when\x20w\
    e\x20build\x20a\x20descriptor,\x20at\x20which\x20point\x20all\x20protos\
    \x20have\x20been\n\x20parsed\x20and\x20so\x20all\x20extensions\x20are\
    \x20known.\n\n\x20Extension\x20numbers\x20for\x20custom\x20options\x20ma\
    y\x20be\x20chosen\x20as\x20follows:\n\x20*\x20For\x20options\x20which\
    \x20will\x20only\x20be\x20used\x20within\x20a\x20single\x20application\
    \x20or\n\x20\x20\x20organization,\x20or\x20for\x20experimental\x20option\
    s,\x20use\x20field\x20numbers\x2050000\n\x20\x20\x20through\x2099999.\
    \x20\x20It\x20is\x20up\x20to\x20you\x20to\x20ensure\x20that\x20you\x20do\
    \x20not\x20use\x20the\n\x20\x20\x20same\x20number\x20for\x20multiple\x20\
    options.\n\x20*\x20For\x20options\x20which\x20will\x20be\x20published\
    \x20and\x20used\x20publicly\x20by\x20multiple\n\x20\x20\x20independent\
    \x20entities,\x20e-mail\x20protobuf-global-extension-registry@google.com\
    \n\x20\x20\x20to\x20reserve\x20extension\x20numbers.\x20Simply\x20provid\
    e\x20your\x20project\x20name\x20(e.g.\n\x20\x20\x20Objective-C\x20plugin\
    )\x20and\x20your\x20project\x20website\x20(if\x20available)\x20--\x20the\
    re's\x20no\n\x20\x20\x20need\x20to\x20explain\x20how\x20you\x20intend\
    \x20to\x20use\x20them.\x20Usually\x20you\x20only\x20need\x20one\n\x20\
    \x20\x20extension\x20number.\x20You\x20can\x20declare\x20multiple\x20opt\
    ions\x20with\x20only\x20one\x20extension\n\x20\x20\x20number\x20by\x20pu\
    tting\x20them\x20in\x20a\x20sub-message.\x20See\x20the\x20Custom\x20Opti\
    ons\x20section\x20of\n\x20\x20\x20the\x20docs\x20for\x20examples:\n\x20\
    \x20\x20https://developers.google.com/protocol-buffers/docs/proto#option\
    s\n\x20\x20\x20If\x20this\x20turns\x20out\x20to\x20be\x20popular,\x20a\
    \x20web\x20service\x20will\x20be\x20set\x20up\n\x20\x20\x20to\x20automat\
    ically\x20assign\x20option\x20numbers.\n\n\x0b\n\x03\x04\n\x01\x12\x04\
    \xd5\x02\x08\x13\n\xf4\x01\n\x04\x04\n\x02\0\x12\x04\xdb\x02\x02#\x1a\
    \xe5\x01\x20Sets\x20the\x20Java\x20package\x20where\x20classes\x20genera\
    ted\x20from\x20this\x20.proto\x20will\x20be\n\x20placed.\x20\x20By\x20de\
    fault,\x20the\x20proto\x20package\x20is\x20used,\x20but\x20this\x20is\
    \x20often\n\x20inappropriate\x20because\x20proto\x20packages\x20do\x20no\
    t\x20normally\x20start\x20with\x20backwards\n\x20domain\x20names.\n\n\r\
    \n\x05\x04\n\x02\0\x04\x12\x04\xdb\x02\x02\n\n\r\n\x05\x04\n\x02\0\x05\
    \x12\x04\xdb\x02\x0b\x11\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xdb\x02\x12\
    \x1e\n\r\n\x05\x04\n\x02\0\x03\x12\x04\xdb\x02!\"\n\xf1\x02\n\x04\x04\n\
    \x02\x01\x12\x04\xe3\x02\x02+\x1a\xe2\x02\x20Controls\x20the\x20name\x20\
    of\x20the\x20wrapper\x20Java\x20class\x20generated\x20for\x20the\x20.pro\
    to\x20file.\n\x20That\x20class\x20will\x20always\x20contain\x20the\x20.p\
    roto\x20file's\x20getDescriptor()\x20method\x20as\n\x20well\x20as\x20any\
    \x20top-level\x20extensions\x20defined\x20in\x20the\x20.proto\x20file.\n\
    \x20If\x20java_multiple_files\x20is\x20disabled,\x20then\x20all\x20the\
    \x20other\x20classes\x20from\x20the\n\x20.proto\x20file\x20will\x20be\
    \x20nested\x20inside\x20the\x20single\x20wrapper\x20outer\x20class.\n\n\
    \r\n\x05\x04\n\x02\x01\x04\x12\x04\xe3\x02\x02\n\n\r\n\x05\x04\n\x02\x01\
    \x05\x12\x04\xe3\x02\x0b\x11\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xe3\x02\
    \x12&\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\xe3\x02)*\n\xa6\x03\n\x04\x04\
    \n\x02\x02\x12\x04\xeb\x02\x02;\x1a\x97\x03\x20If\x20enabled,\x20then\
    \x20the\x20Java\x20code\x20generator\x20will\x20generate\x20a\x20separat\
    e\x20.java\n\x20file\x20for\x20each\x20top-level\x20message,\x20enum,\
    \x20and\x20service\x20defined\x20in\x20the\x20.proto\n\x20file.\x20\x20T\
    hus,\x20these\x20types\x20will\x20*not*\x20be\x20nested\x20inside\x20the\
    \x20wrapper\x20class\n\x20named\x20by\x20java_outer_classname.\x20\x20Ho\
    wever,\x20the\x20wrapper\x20class\x20will\x20still\x20be\n\x20generated\
    \x20to\x20contain\x20the\x20file's\x20getDescriptor()\x20method\x20as\
    \x20well\x20as\x20any\n\x20top-level\x20extensions\x20defined\x20in\x20t\
    he\x20file.\n\n\r\n\x05\x04\n\x02\x02\x04\x12\x04\xeb\x02\x02\n\n\r\n\
    \x05\x04\n\x02\x02\x05\x12\x04\xeb\x02\x0b\x0f\n\r\n\x05\x04\n\x02\x02\
    \x01\x12\x04\xeb\x02\x10#\n\r\n\x05\x04\n\x02\x02\x03\x12\x04\xeb\x02&(\
    \n\r\n\x05\x04\n\x02\x02\x08\x12\x04\xeb\x02):\n\r\n\x05\x04\n\x02\x02\
    \x07\x12\x04\xeb\x0249\n)\n\x04\x04\n\x02\x03\x12\x04\xee\x02\x02E\x1a\
    \x1b\x20This\x20option\x20does\x20nothing.\n\n\r\n\x05\x04\n\x02\x03\x04\
    \x12\x04\xee\x02\x02\n\n\r\n\x05\x04\n\x02\x03\x05\x12\x04\xee\x02\x0b\
    \x0f\n\r\n\x05\x04\n\x02\x03\x01\x12\x04\xee\x02\x10-\n\r\n\x05\x04\n\
    \x02\x03\x03\x12\x04\xee\x0202\n\r\n\x05\x04\n\x02\x03\x08\x12\x04\xee\
    \x023D\n\x0e\n\x06\x04\n\x02\x03\x08\x03\x12\x04\xee\x024C\n\xe6\x02\n\
    \x04\x04\n\x02\x04\x12\x04\xf6\x02\x02>\x1a\xd7\x02\x20If\x20set\x20true\
    ,\x20then\x20the\x20Java2\x20code\x20generator\x20will\x20generate\x20co\
    de\x20that\n\x20throws\x20an\x20exception\x20whenever\x20an\x20attempt\
    \x20is\x20made\x20to\x20assign\x20a\x20non-UTF-8\n\x20byte\x20sequence\
    \x20to\x20a\x20string\x20field.\n\x20Message\x20reflection\x20will\x20do\
    \x20the\x20same.\n\x20However,\x20an\x20extension\x20field\x20still\x20a\
    ccepts\x20non-UTF-8\x20byte\x20sequences.\n\x20This\x20option\x20has\x20\
    no\x20effect\x20on\x20when\x20used\x20with\x20the\x20lite\x20runtime.\n\
    \n\r\n\x05\x04\n\x02\x04\x04\x12\x04\xf6\x02\x02\n\n\r\n\x05\x04\n\x02\
    \x04\x05\x12\x04\xf6\x02\x0b\x0f\n\r\n\x05\x04\n\x02\x04\x01\x12\x04\xf6\
    \x02\x10&\n\r\n\x05\x04\n\x02\x04\x03\x12\x04\xf6\x02)+\n\r\n\x05\x04\n\
    \x02\x04\x08\x12\x04\xf6\x02,=\n\r\n\x05\x04\n\x02\x04\x07\x12\x04\xf6\
    \x027<\nL\n\x04\x04\n\x04\0\x12\x06\xfa\x02\x02\xff\x02\x03\x1a<\x20Gene\
    rated\x20classes\x20can\x20be\x20optimized\x20for\x20speed\x20or\x20code\
    \x20size.\n\n\r\n\x05\x04\n\x04\0\x01\x12\x04\xfa\x02\x07\x13\nD\n\x06\
    \x04\n\x04\0\x02\0\x12\x04\xfb\x02\x04\x0e\"4\x20Generate\x20complete\
    \x20code\x20for\x20parsing,\x20serialization,\n\n\x0f\n\x07\x04\n\x04\0\
    \x02\0\x01\x12\x04\xfb\x02\x04\t\n\x0f\n\x07\x04\n\x04\0\x02\0\x02\x12\
    \x04\xfb\x02\x0c\r\nG\n\x06\x04\n\x04\0\x02\x01\x12\x04\xfd\x02\x04\x12\
    \x1a\x06\x20etc.\n\"/\x20Use\x20ReflectionOps\x20to\x20implement\x20thes\
    e\x20methods.\n\n\x0f\n\x07\x04\n\x04\0\x02\x01\x01\x12\x04\xfd\x02\x04\
    \r\n\x0f\n\x07\x04\n\x04\0\x02\x01\x02\x12\x04\xfd\x02\x10\x11\nG\n\x06\
    \x04\n\x04\0\x02\x02\x12\x04\xfe\x02\x04\x15\"7\x20Generate\x20code\x20u\
    sing\x20MessageLite\x20and\x20the\x20lite\x20runtime.\n\n\x0f\n\x07\x04\
    \n\x04\0\x02\x02\x01\x12\x04\xfe\x02\x04\x10\n\x0f\n\x07\x04\n\x04\0\x02\
    \x02\x02\x12\x04\xfe\x02\x13\x14\n\x0c\n\x04\x04\n\x02\x05\x12\x04\x80\
    \x03\x02;\n\r\n\x05\x04\n\x02\x05\x04\x12\x04\x80\x03\x02\n\n\r\n\x05\
    \x04\n\x02\x05\x06\x12\x04\x80\x03\x0b\x17\n\r\n\x05\x04\n\x02\x05\x01\
    \x12\x04\x80\x03\x18$\n\r\n\x05\x04\n\x02\x05\x03\x12\x04\x80\x03'(\n\r\
    \n\x05\x04\n\x02\x05\x08\x12\x04\x80\x03):\n\r\n\x05\x04\n\x02\x05\x07\
    \x12\x04\x80\x0349\n\xe2\x02\n\x04\x04\n\x02\x06\x12\x04\x87\x03\x02\"\
    \x1a\xd3\x02\x20Sets\x20the\x20Go\x20package\x20where\x20structs\x20gene\
    rated\x20from\x20this\x20.proto\x20will\x20be\n\x20placed.\x20If\x20omit\
    ted,\x20the\x20Go\x20package\x20will\x20be\x20derived\x20from\x20the\x20\
    following:\n\x20\x20\x20-\x20The\x20basename\x20of\x20the\x20package\x20\
    import\x20path,\x20if\x20provided.\n\x20\x20\x20-\x20Otherwise,\x20the\
    \x20package\x20statement\x20in\x20the\x20.proto\x20file,\x20if\x20presen\
    t.\n\x20\x20\x20-\x20Otherwise,\x20the\x20basename\x20of\x20the\x20.prot\
    o\x20file,\x20without\x20extension.\n\n\r\n\x05\x04\n\x02\x06\x04\x12\
    \x04\x87\x03\x02\n\n\r\n\x05\x04\n\x02\x06\x05\x12\x04\x87\x03\x0b\x11\n\
    \r\n\x05\x04\n\x02\x06\x01\x12\x04\x87\x03\x12\x1c\n\r\n\x05\x04\n\x02\
    \x06\x03\x12\x04\x87\x03\x1f!\n\xd4\x04\n\x04\x04\n\x02\x07\x12\x04\x96\
    \x03\x02;\x1a\xc5\x04\x20Should\x20generic\x20services\x20be\x20generate\
    d\x20in\x20each\x20language?\x20\x20\"Generic\"\x20services\n\x20are\x20\
    not\x20specific\x20to\x20any\x20particular\x20RPC\x20system.\x20\x20They\
    \x20are\x20generated\x20by\x20the\n\x20main\x20code\x20generators\x20in\
    \x20each\x20language\x20(without\x20additional\x20plugins).\n\x20Generic\
    \x20services\x20were\x20the\x20only\x20kind\x20of\x20service\x20generati\
    on\x20supported\x20by\n\x20early\x20versions\x20of\x20google.protobuf.\n\
    \n\x20Generic\x20services\x20are\x20now\x20considered\x20deprecated\x20i\
    n\x20favor\x20of\x20using\x20plugins\n\x20that\x20generate\x20code\x20sp\
    ecific\x20to\x20your\x20particular\x20RPC\x20system.\x20\x20Therefore,\n\
    \x20these\x20default\x20to\x20false.\x20\x20Old\x20code\x20which\x20depe\
    nds\x20on\x20generic\x20services\x20should\n\x20explicitly\x20set\x20the\
    m\x20to\x20true.\n\n\r\n\x05\x04\n\x02\x07\x04\x12\x04\x96\x03\x02\n\n\r\
    \n\x05\x04\n\x02\x07\x05\x12\x04\x96\x03\x0b\x0f\n\r\n\x05\x04\n\x02\x07\
    \x01\x12\x04\x96\x03\x10#\n\r\n\x05\x04\n\x02\x07\x03\x12\x04\x96\x03&(\
    \n\r\n\x05\x04\n\x02\x07\x08\x12\x04\x96\x03):\n\r\n\x05\x04\n\x02\x07\
    \x07\x12\x04\x96\x0349\n\x0c\n\x04\x04\n\x02\x08\x12\x04\x97\x03\x02=\n\
    \r\n\x05\x04\n\x02\x08\x04\x12\x04\x97\x03\x02\n\n\r\n\x05\x04\n\x02\x08\
    \x05\x12\x04\x97\x03\x0b\x0f\n\r\n\x05\x04\n\x02\x08\x01\x12\x04\x97\x03\
    \x10%\n\r\n\x05\x04\n\x02\x08\x03\x12\x04\x97\x03(*\n\r\n\x05\x04\n\x02\
    \x08\x08\x12\x04\x97\x03+<\n\r\n\x05\x04\n\x02\x08\x07\x12\x04\x97\x036;\
    \n\x0c\n\x04\x04\n\x02\t\x12\x04\x98\x03\x02;\n\r\n\x05\x04\n\x02\t\x04\
    \x12\x04\x98\x03\x02\n\n\r\n\x05\x04\n\x02\t\x05\x12\x04\x98\x03\x0b\x0f\
    \n\r\n\x05\x04\n\x02\t\x01\x12\x04\x98\x03\x10#\n\r\n\x05\x04\n\x02\t\
    \x03\x12\x04\x98\x03&(\n\r\n\x05\x04\n\x02\t\x08\x12\x04\x98\x03):\n\r\n\
    \x05\x04\n\x02\t\x07\x12\x04\x98\x0349\n\x0c\n\x04\x04\n\x02\n\x12\x04\
    \x99\x03\x02<\n\r\n\x05\x04\n\x02\n\x04\x12\x04\x99\x03\x02\n\n\r\n\x05\
    \x04\n\x02\n\x05\x12\x04\x99\x03\x0b\x0f\n\r\n\x05\x04\n\x02\n\x01\x12\
    \x04\x99\x03\x10$\n\r\n\x05\x04\n\x02\n\x03\x12\x04\x99\x03')\n\r\n\x05\
    \x04\n\x02\n\x08\x12\x04\x99\x03*;\n\r\n\x05\x04\n\x02\n\x07\x12\x04\x99\
    \x035:\n\xf3\x01\n\x04\x04\n\x02\x0b\x12\x04\x9f\x03\x022\x1a\xe4\x01\
    \x20Is\x20this\x20file\x20deprecated?\n\x20Depending\x20on\x20the\x20tar\
    get\x20platform,\x20this\x20can\x20emit\x20Deprecated\x20annotations\n\
    \x20for\x20everything\x20in\x20the\x20file,\x20or\x20it\x20will\x20be\
    \x20completely\x20ignored;\x20in\x20the\x20very\n\x20least,\x20this\x20i\
    s\x20a\x20formalization\x20for\x20deprecating\x20files.\n\n\r\n\x05\x04\
    \n\x02\x0b\x04\x12\x04\x9f\x03\x02\n\n\r\n\x05\x04\n\x02\x0b\x05\x12\x04\
    \x9f\x03\x0b\x0f\n\r\n\x05\x04\n\x02\x0b\x01\x12\x04\x9f\x03\x10\x1a\n\r\
    \n\x05\x04\n\x02\x0b\x03\x12\x04\x9f\x03\x1d\x1f\n\r\n\x05\x04\n\x02\x0b\
    \x08\x12\x04\x9f\x03\x201\n\r\n\x05\x04\n\x02\x0b\x07\x12\x04\x9f\x03+0\
    \n\x7f\n\x04\x04\n\x02\x0c\x12\x04\xa3\x03\x027\x1aq\x20Enables\x20the\
    \x20use\x20of\x20arenas\x20for\x20the\x20proto\x20messages\x20in\x20this\
    \x20file.\x20This\x20applies\n\x20only\x20to\x20generated\x20classes\x20\
    for\x20C++.\n\n\r\n\x05\x04\n\x02\x0c\x04\x12\x04\xa3\x03\x02\n\n\r\n\
    \x05\x04\n\x02\x0c\x05\x12\x04\xa3\x03\x0b\x0f\n\r\n\x05\x04\n\x02\x0c\
    \x01\x12\x04\xa3\x03\x10\x20\n\r\n\x05\x04\n\x02\x0c\x03\x12\x04\xa3\x03\
    #%\n\r\n\x05\x04\n\x02\x0c\x08\x12\x04\xa3\x03&6\n\r\n\x05\x04\n\x02\x0c\
    \x07\x12\x04\xa3\x0315\n\x92\x01\n\x04\x04\n\x02\r\x12\x04\xa8\x03\x02)\
    \x1a\x83\x01\x20Sets\x20the\x20objective\x20c\x20class\x20prefix\x20whic\
    h\x20is\x20prepended\x20to\x20all\x20objective\x20c\n\x20generated\x20cl\
    asses\x20from\x20this\x20.proto.\x20There\x20is\x20no\x20default.\n\n\r\
    \n\x05\x04\n\x02\r\x04\x12\x04\xa8\x03\x02\n\n\r\n\x05\x04\n\x02\r\x05\
    \x12\x04\xa8\x03\x0b\x11\n\r\n\x05\x04\n\x02\r\x01\x12\x04\xa8\x03\x12#\
    \n\r\n\x05\x04\n\x02\r\x03\x12\x04\xa8\x03&(\nI\n\x04\x04\n\x02\x0e\x12\
    \x04\xab\x03\x02(\x1a;\x20Namespace\x20for\x20generated\x20classes;\x20d\
    efaults\x20to\x20the\x20package.\n\n\r\n\x05\x04\n\x02\x0e\x04\x12\x04\
    \xab\x03\x02\n\n\r\n\x05\x04\n\x02\x0e\x05\x12\x04\xab\x03\x0b\x11\n\r\n\
    \x05\x04\n\x02\x0e\x01\x12\x04\xab\x03\x12\"\n\r\n\x05\x04\n\x02\x0e\x03\
    \x12\x04\xab\x03%'\n\x91\x02\n\x04\x04\n\x02\x0f\x12\x04\xb1\x03\x02$\
    \x1a\x82\x02\x20By\x20default\x20Swift\x20generators\x20will\x20take\x20\
    the\x20proto\x20package\x20and\x20CamelCase\x20it\n\x20replacing\x20'.'\
    \x20with\x20underscore\x20and\x20use\x20that\x20to\x20prefix\x20the\x20t\
    ypes/symbols\n\x20defined.\x20When\x20this\x20options\x20is\x20provided,\
    \x20they\x20will\x20use\x20this\x20value\x20instead\n\x20to\x20prefix\
    \x20the\x20types/symbols\x20defined.\n\n\r\n\x05\x04\n\x02\x0f\x04\x12\
    \x04\xb1\x03\x02\n\n\r\n\x05\x04\n\x02\x0f\x05\x12\x04\xb1\x03\x0b\x11\n\
    \r\n\x05\x04\n\x02\x0f\x01\x12\x04\xb1\x03\x12\x1e\n\r\n\x05\x04\n\x02\
    \x0f\x03\x12\x04\xb1\x03!#\n~\n\x04\x04\n\x02\x10\x12\x04\xb5\x03\x02(\
    \x1ap\x20Sets\x20the\x20php\x20class\x20prefix\x20which\x20is\x20prepend\
    ed\x20to\x20all\x20php\x20generated\x20classes\n\x20from\x20this\x20.pro\
    to.\x20Default\x20is\x20empty.\n\n\r\n\x05\x04\n\x02\x10\x04\x12\x04\xb5\
    \x03\x02\n\n\r\n\x05\x04\n\x02\x10\x05\x12\x04\xb5\x03\x0b\x11\n\r\n\x05\
    \x04\n\x02\x10\x01\x12\x04\xb5\x03\x12\"\n\r\n\x05\x04\n\x02\x10\x03\x12\
    \x04\xb5\x03%'\n\xbe\x01\n\x04\x04\n\x02\x11\x12\x04\xba\x03\x02%\x1a\
    \xaf\x01\x20Use\x20this\x20option\x20to\x20change\x20the\x20namespace\
    \x20of\x20php\x20generated\x20classes.\x20Default\n\x20is\x20empty.\x20W\
    hen\x20this\x20option\x20is\x20empty,\x20the\x20package\x20name\x20will\
    \x20be\x20used\x20for\n\x20determining\x20the\x20namespace.\n\n\r\n\x05\
    \x04\n\x02\x11\x04\x12\x04\xba\x03\x02\n\n\r\n\x05\x04\n\x02\x11\x05\x12\
    \x04\xba\x03\x0b\x11\n\r\n\x05\x04\n\x02\x11\x01\x12\x04\xba\x03\x12\x1f\
    \n\r\n\x05\x04\n\x02\x11\x03\x12\x04\xba\x03\"$\n\xca\x01\n\x04\x04\n\
    \x02\x12\x12\x04\xbf\x03\x02.\x1a\xbb\x01\x20Use\x20this\x20option\x20to\
    \x20change\x20the\x20namespace\x20of\x20php\x20generated\x20metadata\x20\
    classes.\n\x20Default\x20is\x20empty.\x20When\x20this\x20option\x20is\
    \x20empty,\x20the\x20proto\x20file\x20name\x20will\x20be\n\x20used\x20fo\
    r\x20determining\x20the\x20namespace.\n\n\r\n\x05\x04\n\x02\x12\x04\x12\
    \x04\xbf\x03\x02\n\n\r\n\x05\x04\n\x02\x12\x05\x12\x04\xbf\x03\x0b\x11\n\
    \r\n\x05\x04\n\x02\x12\x01\x12\x04\xbf\x03\x12(\n\r\n\x05\x04\n\x02\x12\
    \x03\x12\x04\xbf\x03+-\n\xc2\x01\n\x04\x04\n\x02\x13\x12\x04\xc4\x03\x02\
    $\x1a\xb3\x01\x20Use\x20this\x20option\x20to\x20change\x20the\x20package\
    \x20of\x20ruby\x20generated\x20classes.\x20Default\n\x20is\x20empty.\x20\
    When\x20this\x20option\x20is\x20not\x20set,\x20the\x20package\x20name\
    \x20will\x20be\x20used\x20for\n\x20determining\x20the\x20ruby\x20package\
    .\n\n\r\n\x05\x04\n\x02\x13\x04\x12\x04\xc4\x03\x02\n\n\r\n\x05\x04\n\
    \x02\x13\x05\x12\x04\xc4\x03\x0b\x11\n\r\n\x05\x04\n\x02\x13\x01\x12\x04\
    \xc4\x03\x12\x1e\n\r\n\x05\x04\n\x02\x13\x03\x12\x04\xc4\x03!#\n|\n\x04\
    \x04\n\x02\x14\x12\x04\xc9\x03\x02:\x1an\x20The\x20parser\x20stores\x20o\
    ptions\x20it\x20doesn't\x20recognize\x20here.\n\x20See\x20the\x20documen\
    tation\x20for\x20the\x20\"Options\"\x20section\x20above.\n\n\r\n\x05\x04\
    \n\x02\x14\x04\x12\x04\xc9\x03\x02\n\n\r\n\x05\x04\n\x02\x14\x06\x12\x04\
    \xc9\x03\x0b\x1e\n\r\n\x05\x04\n\x02\x14\x01\x12\x04\xc9\x03\x1f3\n\r\n\
    \x05\x04\n\x02\x14\x03\x12\x04\xc9\x0369\n\x87\x01\n\x03\x04\n\x05\x12\
    \x04\xcd\x03\x02\x19\x1az\x20Clients\x20can\x20define\x20custom\x20optio\
    ns\x20in\x20extensions\x20of\x20this\x20message.\n\x20See\x20the\x20docu\
    mentation\x20for\x20the\x20\"Options\"\x20section\x20above.\n\n\x0c\n\
    \x04\x04\n\x05\0\x12\x04\xcd\x03\r\x18\n\r\n\x05\x04\n\x05\0\x01\x12\x04\
    \xcd\x03\r\x11\n\r\n\x05\x04\n\x05\0\x02\x12\x04\xcd\x03\x15\x18\n\x0b\n\
    \x03\x04\n\t\x12\x04\xcf\x03\x02\x0e\n\x0c\n\x04\x04\n\t\0\x12\x04\xcf\
    \x03\x0b\r\n\r\n\x05\x04\n\t\0\x01\x12\x04\xcf\x03\x0b\r\n\r\n\x05\x04\n\
    \t\0\x02\x12\x04\xcf\x03\x0b\r\n\x0c\n\x02\x04\x0b\x12\x06\xd2\x03\0\x94\
    \x04\x01\n\x0b\n\x03\x04\x0b\x01\x12\x04\xd2\x03\x08\x16\n\xd8\x05\n\x04\
    \x04\x0b\x02\0\x12\x04\xe5\x03\x02>\x1a\xc9\x05\x20Set\x20true\x20to\x20\
    use\x20the\x20old\x20proto1\x20MessageSet\x20wire\x20format\x20for\x20ex\
    tensions.\n\x20This\x20is\x20provided\x20for\x20backwards-compatibility\
    \x20with\x20the\x20MessageSet\x20wire\n\x20format.\x20\x20You\x20should\
    \x20not\x20use\x20this\x20for\x20any\x20other\x20reason:\x20\x20It's\x20\
    less\n\x20efficient,\x20has\x20fewer\x20features,\x20and\x20is\x20more\
    \x20complicated.\n\n\x20The\x20message\x20must\x20be\x20defined\x20exact\
    ly\x20as\x20follows:\n\x20\x20\x20message\x20Foo\x20{\n\x20\x20\x20\x20\
    \x20option\x20message_set_wire_format\x20=\x20true;\n\x20\x20\x20\x20\
    \x20extensions\x204\x20to\x20max;\n\x20\x20\x20}\n\x20Note\x20that\x20th\
    e\x20message\x20cannot\x20have\x20any\x20defined\x20fields;\x20MessageSe\
    ts\x20only\n\x20have\x20extensions.\n\n\x20All\x20extensions\x20of\x20yo\
    ur\x20type\x20must\x20be\x20singular\x20messages;\x20e.g.\x20they\x20can\
    not\n\x20be\x20int32s,\x20enums,\x20or\x20repeated\x20messages.\n\n\x20B\
    ecause\x20this\x20is\x20an\x20option,\x20the\x20above\x20two\x20restrict\
    ions\x20are\x20not\x20enforced\x20by\n\x20the\x20protocol\x20compiler.\n\
    \n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\xe5\x03\x02\n\n\r\n\x05\x04\x0b\x02\
    \0\x05\x12\x04\xe5\x03\x0b\x0f\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xe5\
    \x03\x10'\n\r\n\x05\x04\x0b\x02\0\x03\x12\x04\xe5\x03*+\n\r\n\x05\x04\
    \x0b\x02\0\x08\x12\x04\xe5\x03,=\n\r\n\x05\x04\x0b\x02\0\x07\x12\x04\xe5\
    \x037<\n\xeb\x01\n\x04\x04\x0b\x02\x01\x12\x04\xea\x03\x02F\x1a\xdc\x01\
    \x20Disables\x20the\x20generation\x20of\x20the\x20standard\x20\"descript\
    or()\"\x20accessor,\x20which\x20can\n\x20conflict\x20with\x20a\x20field\
    \x20of\x20the\x20same\x20name.\x20\x20This\x20is\x20meant\x20to\x20make\
    \x20migration\n\x20from\x20proto1\x20easier;\x20new\x20code\x20should\
    \x20avoid\x20fields\x20named\x20\"descriptor\".\n\n\r\n\x05\x04\x0b\x02\
    \x01\x04\x12\x04\xea\x03\x02\n\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\xea\
    \x03\x0b\x0f\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xea\x03\x10/\n\r\n\
    \x05\x04\x0b\x02\x01\x03\x12\x04\xea\x0323\n\r\n\x05\x04\x0b\x02\x01\x08\
    \x12\x04\xea\x034E\n\r\n\x05\x04\x0b\x02\x01\x07\x12\x04\xea\x03?D\n\xee\
    \x01\n\x04\x04\x0b\x02\x02\x12\x04\xf0\x03\x021\x1a\xdf\x01\x20Is\x20thi\
    s\x20message\x20deprecated?\n\x20Depending\x20on\x20the\x20target\x20pla\
    tform,\x20this\x20can\x20emit\x20Deprecated\x20annotations\n\x20for\x20t\
    he\x20message,\x20or\x20it\x20will\x20be\x20completely\x20ignored;\x20in\
    \x20the\x20very\x20least,\n\x20this\x20is\x20a\x20formalization\x20for\
    \x20deprecating\x20messages.\n\n\r\n\x05\x04\x0b\x02\x02\x04\x12\x04\xf0\
    \x03\x02\n\n\r\n\x05\x04\x0b\x02\x02\x05\x12\x04\xf0\x03\x0b\x0f\n\r\n\
    \x05\x04\x0b\x02\x02\x01\x12\x04\xf0\x03\x10\x1a\n\r\n\x05\x04\x0b\x02\
    \x02\x03\x12\x04\xf0\x03\x1d\x1e\n\r\n\x05\x04\x0b\x02\x02\x08\x12\x04\
    \xf0\x03\x1f0\n\r\n\x05\x04\x0b\x02\x02\x07\x12\x04\xf0\x03*/\n\x0b\n\
    \x03\x04\x0b\t\x12\x04\xf2\x03\x02\x13\n\x0c\n\x04\x04\x0b\t\0\x12\x04\
    \xf2\x03\x0b\x0c\n\r\n\x05\x04\x0b\t\0\x01\x12\x04\xf2\x03\x0b\x0c\n\r\n\
    \x05\x04\x0b\t\0\x02\x12\x04\xf2\x03\x0b\x0c\n\x0c\n\x04\x04\x0b\t\x01\
    \x12\x04\xf2\x03\x0e\x0f\n\r\n\x05\x04\x0b\t\x01\x01\x12\x04\xf2\x03\x0e\
    \x0f\n\r\n\x05\x04\x0b\t\x01\x02\x12\x04\xf2\x03\x0e\x0f\n\x0c\n\x04\x04\
    \x0b\t\x02\x12\x04\xf2\x03\x11\x12\n\r\n\x05\x04\x0b\t\x02\x01\x12\x04\
    \xf2\x03\x11\x12\n\r\n\x05\x04\x0b\t\x02\x02\x12\x04\xf2\x03\x11\x12\n\
    \xa0\x06\n\x04\x04\x0b\x02\x03\x12\x04\x89\x04\x02\x1e\x1a\x91\x06\x20Wh\
    ether\x20the\x20message\x20is\x20an\x20automatically\x20generated\x20map\
    \x20entry\x20type\x20for\x20the\n\x20maps\x20field.\n\n\x20For\x20maps\
    \x20fields:\n\x20\x20\x20\x20\x20map<KeyType,\x20ValueType>\x20map_field\
    \x20=\x201;\n\x20The\x20parsed\x20descriptor\x20looks\x20like:\n\x20\x20\
    \x20\x20\x20message\x20MapFieldEntry\x20{\n\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20option\x20map_entry\x20=\x20true;\n\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20optional\x20KeyType\x20key\x20=\x201;\n\x20\x20\x20\x20\x20\x20\
    \x20\x20\x20optional\x20ValueType\x20value\x20=\x202;\n\x20\x20\x20\x20\
    \x20}\n\x20\x20\x20\x20\x20repeated\x20MapFieldEntry\x20map_field\x20=\
    \x201;\n\n\x20Implementations\x20may\x20choose\x20not\x20to\x20generate\
    \x20the\x20map_entry=true\x20message,\x20but\n\x20use\x20a\x20native\x20\
    map\x20in\x20the\x20target\x20language\x20to\x20hold\x20the\x20keys\x20a\
    nd\x20values.\n\x20The\x20reflection\x20APIs\x20in\x20such\x20implementa\
    tions\x20still\x20need\x20to\x20work\x20as\n\x20if\x20the\x20field\x20is\
    \x20a\x20repeated\x20message\x20field.\n\n\x20NOTE:\x20Do\x20not\x20set\
    \x20the\x20option\x20in\x20.proto\x20files.\x20Always\x20use\x20the\x20m\
    aps\x20syntax\n\x20instead.\x20The\x20option\x20should\x20only\x20be\x20\
    implicitly\x20set\x20by\x20the\x20proto\x20compiler\n\x20parser.\n\n\r\n\
    \x05\x04\x0b\x02\x03\x04\x12\x04\x89\x04\x02\n\n\r\n\x05\x04\x0b\x02\x03\
    \x05\x12\x04\x89\x04\x0b\x0f\n\r\n\x05\x04\x0b\x02\x03\x01\x12\x04\x89\
    \x04\x10\x19\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\x89\x04\x1c\x1d\n$\n\
    \x03\x04\x0b\t\x12\x04\x8b\x04\x02\r\"\x17\x20javalite_serializable\n\n\
    \x0c\n\x04\x04\x0b\t\x03\x12\x04\x8b\x04\x0b\x0c\n\r\n\x05\x04\x0b\t\x03\
    \x01\x12\x04\x8b\x04\x0b\x0c\n\r\n\x05\x04\x0b\t\x03\x02\x12\x04\x8b\x04\
    \x0b\x0c\n\x1f\n\x03\x04\x0b\t\x12\x04\x8c\x04\x02\r\"\x12\x20javanano_a\
    s_lite\n\n\x0c\n\x04\x04\x0b\t\x04\x12\x04\x8c\x04\x0b\x0c\n\r\n\x05\x04\
    \x0b\t\x04\x01\x12\x04\x8c\x04\x0b\x0c\n\r\n\x05\x04\x0b\t\x04\x02\x12\
    \x04\x8c\x04\x0b\x0c\nO\n\x04\x04\x0b\x02\x04\x12\x04\x90\x04\x02:\x1aA\
    \x20The\x20parser\x20stores\x20options\x20it\x20doesn't\x20recognize\x20\
    here.\x20See\x20above.\n\n\r\n\x05\x04\x0b\x02\x04\x04\x12\x04\x90\x04\
    \x02\n\n\r\n\x05\x04\x0b\x02\x04\x06\x12\x04\x90\x04\x0b\x1e\n\r\n\x05\
    \x04\x0b\x02\x04\x01\x12\x04\x90\x04\x1f3\n\r\n\x05\x04\x0b\x02\x04\x03\
    \x12\x04\x90\x0469\nZ\n\x03\x04\x0b\x05\x12\x04\x93\x04\x02\x19\x1aM\x20\
    Clients\x20can\x20define\x20custom\x20options\x20in\x20extensions\x20of\
    \x20this\x20message.\x20See\x20above.\n\n\x0c\n\x04\x04\x0b\x05\0\x12\
    \x04\x93\x04\r\x18\n\r\n\x05\x04\x0b\x05\0\x01\x12\x04\x93\x04\r\x11\n\r\
    \n\x05\x04\x0b\x05\0\x02\x12\x04\x93\x04\x15\x18\n\x0c\n\x02\x04\x0c\x12\
    \x06\x96\x04\0\xf1\x04\x01\n\x0b\n\x03\x04\x0c\x01\x12\x04\x96\x04\x08\
    \x14\n\xa3\x02\n\x04\x04\x0c\x02\0\x12\x04\x9b\x04\x02.\x1a\x94\x02\x20T\
    he\x20ctype\x20option\x20instructs\x20the\x20C++\x20code\x20generator\
    \x20to\x20use\x20a\x20different\n\x20representation\x20of\x20the\x20fiel\
    d\x20than\x20it\x20normally\x20would.\x20\x20See\x20the\x20specific\n\
    \x20options\x20below.\x20\x20This\x20option\x20is\x20not\x20yet\x20imple\
    mented\x20in\x20the\x20open\x20source\n\x20release\x20--\x20sorry,\x20we\
    'll\x20try\x20to\x20include\x20it\x20in\x20a\x20future\x20version!\n\n\r\
    \n\x05\x04\x0c\x02\0\x04\x12\x04\x9b\x04\x02\n\n\r\n\x05\x04\x0c\x02\0\
    \x06\x12\x04\x9b\x04\x0b\x10\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\x9b\x04\
    \x11\x16\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\x9b\x04\x19\x1a\n\r\n\x05\
    \x04\x0c\x02\0\x08\x12\x04\x9b\x04\x1b-\n\r\n\x05\x04\x0c\x02\0\x07\x12\
    \x04\x9b\x04&,\n\x0e\n\x04\x04\x0c\x04\0\x12\x06\x9c\x04\x02\xa3\x04\x03\
    \n\r\n\x05\x04\x0c\x04\0\x01\x12\x04\x9c\x04\x07\x0c\n\x1f\n\x06\x04\x0c\
    \x04\0\x02\0\x12\x04\x9e\x04\x04\x0f\x1a\x0f\x20Default\x20mode.\n\n\x0f\
    \n\x07\x04\x0c\x04\0\x02\0\x01\x12\x04\x9e\x04\x04\n\n\x0f\n\x07\x04\x0c\
    \x04\0\x02\0\x02\x12\x04\x9e\x04\r\x0e\n\x0e\n\x06\x04\x0c\x04\0\x02\x01\
    \x12\x04\xa0\x04\x04\r\n\x0f\n\x07\x04\x0c\x04\0\x02\x01\x01\x12\x04\xa0\
    \x04\x04\x08\n\x0f\n\x07\x04\x0c\x04\0\x02\x01\x02\x12\x04\xa0\x04\x0b\
    \x0c\n\x0e\n\x06\x04\x0c\x04\0\x02\x02\x12\x04\xa2\x04\x04\x15\n\x0f\n\
    \x07\x04\x0c\x04\0\x02\x02\x01\x12\x04\xa2\x04\x04\x10\n\x0f\n\x07\x04\
    \x0c\x04\0\x02\x02\x02\x12\x04\xa2\x04\x13\x14\n\xda\x02\n\x04\x04\x0c\
    \x02\x01\x12\x04\xa9\x04\x02\x1b\x1a\xcb\x02\x20The\x20packed\x20option\
    \x20can\x20be\x20enabled\x20for\x20repeated\x20primitive\x20fields\x20to\
    \x20enable\n\x20a\x20more\x20efficient\x20representation\x20on\x20the\
    \x20wire.\x20Rather\x20than\x20repeatedly\n\x20writing\x20the\x20tag\x20\
    and\x20type\x20for\x20each\x20element,\x20the\x20entire\x20array\x20is\
    \x20encoded\x20as\n\x20a\x20single\x20length-delimited\x20blob.\x20In\
    \x20proto3,\x20only\x20explicit\x20setting\x20it\x20to\n\x20false\x20wil\
    l\x20avoid\x20using\x20packed\x20encoding.\n\n\r\n\x05\x04\x0c\x02\x01\
    \x04\x12\x04\xa9\x04\x02\n\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xa9\x04\
    \x0b\x0f\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xa9\x04\x10\x16\n\r\n\x05\
    \x04\x0c\x02\x01\x03\x12\x04\xa9\x04\x19\x1a\n\x9a\x05\n\x04\x04\x0c\x02\
    \x02\x12\x04\xb6\x04\x023\x1a\x8b\x05\x20The\x20jstype\x20option\x20dete\
    rmines\x20the\x20JavaScript\x20type\x20used\x20for\x20values\x20of\x20th\
    e\n\x20field.\x20\x20The\x20option\x20is\x20permitted\x20only\x20for\x20\
    64\x20bit\x20integral\x20and\x20fixed\x20types\n\x20(int64,\x20uint64,\
    \x20sint64,\x20fixed64,\x20sfixed64).\x20\x20A\x20field\x20with\x20jstyp\
    e\x20JS_STRING\n\x20is\x20represented\x20as\x20JavaScript\x20string,\x20\
    which\x20avoids\x20loss\x20of\x20precision\x20that\n\x20can\x20happen\
    \x20when\x20a\x20large\x20value\x20is\x20converted\x20to\x20a\x20floatin\
    g\x20point\x20JavaScript.\n\x20Specifying\x20JS_NUMBER\x20for\x20the\x20\
    jstype\x20causes\x20the\x20generated\x20JavaScript\x20code\x20to\n\x20us\
    e\x20the\x20JavaScript\x20\"number\"\x20type.\x20\x20The\x20behavior\x20\
    of\x20the\x20default\x20option\n\x20JS_NORMAL\x20is\x20implementation\
    \x20dependent.\n\n\x20This\x20option\x20is\x20an\x20enum\x20to\x20permit\
    \x20additional\x20types\x20to\x20be\x20added,\x20e.g.\n\x20goog.math.Int\
    eger.\n\n\r\n\x05\x04\x0c\x02\x02\x04\x12\x04\xb6\x04\x02\n\n\r\n\x05\
    \x04\x0c\x02\x02\x06\x12\x04\xb6\x04\x0b\x11\n\r\n\x05\x04\x0c\x02\x02\
    \x01\x12\x04\xb6\x04\x12\x18\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xb6\
    \x04\x1b\x1c\n\r\n\x05\x04\x0c\x02\x02\x08\x12\x04\xb6\x04\x1d2\n\r\n\
    \x05\x04\x0c\x02\x02\x07\x12\x04\xb6\x04(1\n\x0e\n\x04\x04\x0c\x04\x01\
    \x12\x06\xb7\x04\x02\xc0\x04\x03\n\r\n\x05\x04\x0c\x04\x01\x01\x12\x04\
    \xb7\x04\x07\r\n'\n\x06\x04\x0c\x04\x01\x02\0\x12\x04\xb9\x04\x04\x12\
    \x1a\x17\x20Use\x20the\x20default\x20type.\n\n\x0f\n\x07\x04\x0c\x04\x01\
    \x02\0\x01\x12\x04\xb9\x04\x04\r\n\x0f\n\x07\x04\x0c\x04\x01\x02\0\x02\
    \x12\x04\xb9\x04\x10\x11\n)\n\x06\x04\x0c\x04\x01\x02\x01\x12\x04\xbc\
    \x04\x04\x12\x1a\x19\x20Use\x20JavaScript\x20strings.\n\n\x0f\n\x07\x04\
    \x0c\x04\x01\x02\x01\x01\x12\x04\xbc\x04\x04\r\n\x0f\n\x07\x04\x0c\x04\
    \x01\x02\x01\x02\x12\x04\xbc\x04\x10\x11\n)\n\x06\x04\x0c\x04\x01\x02\
    \x02\x12\x04\xbf\x04\x04\x12\x1a\x19\x20Use\x20JavaScript\x20numbers.\n\
    \n\x0f\n\x07\x04\x0c\x04\x01\x02\x02\x01\x12\x04\xbf\x04\x04\r\n\x0f\n\
    \x07\x04\x0c\x04\x01\x02\x02\x02\x12\x04\xbf\x04\x10\x11\n\xef\x0c\n\x04\
    \x04\x0c\x02\x03\x12\x04\xde\x04\x02+\x1a\xe0\x0c\x20Should\x20this\x20f\
    ield\x20be\x20parsed\x20lazily?\x20\x20Lazy\x20applies\x20only\x20to\x20\
    message-type\n\x20fields.\x20\x20It\x20means\x20that\x20when\x20the\x20o\
    uter\x20message\x20is\x20initially\x20parsed,\x20the\n\x20inner\x20messa\
    ge's\x20contents\x20will\x20not\x20be\x20parsed\x20but\x20instead\x20sto\
    red\x20in\x20encoded\n\x20form.\x20\x20The\x20inner\x20message\x20will\
    \x20actually\x20be\x20parsed\x20when\x20it\x20is\x20first\x20accessed.\n\
    \n\x20This\x20is\x20only\x20a\x20hint.\x20\x20Implementations\x20are\x20\
    free\x20to\x20choose\x20whether\x20to\x20use\n\x20eager\x20or\x20lazy\
    \x20parsing\x20regardless\x20of\x20the\x20value\x20of\x20this\x20option.\
    \x20\x20However,\n\x20setting\x20this\x20option\x20true\x20suggests\x20t\
    hat\x20the\x20protocol\x20author\x20believes\x20that\n\x20using\x20lazy\
    \x20parsing\x20on\x20this\x20field\x20is\x20worth\x20the\x20additional\
    \x20bookkeeping\n\x20overhead\x20typically\x20needed\x20to\x20implement\
    \x20it.\n\n\x20This\x20option\x20does\x20not\x20affect\x20the\x20public\
    \x20interface\x20of\x20any\x20generated\x20code;\n\x20all\x20method\x20s\
    ignatures\x20remain\x20the\x20same.\x20\x20Furthermore,\x20thread-safety\
    \x20of\x20the\n\x20interface\x20is\x20not\x20affected\x20by\x20this\x20o\
    ption;\x20const\x20methods\x20remain\x20safe\x20to\n\x20call\x20from\x20\
    multiple\x20threads\x20concurrently,\x20while\x20non-const\x20methods\
    \x20continue\n\x20to\x20require\x20exclusive\x20access.\n\n\n\x20Note\
    \x20that\x20implementations\x20may\x20choose\x20not\x20to\x20check\x20re\
    quired\x20fields\x20within\n\x20a\x20lazy\x20sub-message.\x20\x20That\
    \x20is,\x20calling\x20IsInitialized()\x20on\x20the\x20outer\x20message\n\
    \x20may\x20return\x20true\x20even\x20if\x20the\x20inner\x20message\x20ha\
    s\x20missing\x20required\x20fields.\n\x20This\x20is\x20necessary\x20beca\
    use\x20otherwise\x20the\x20inner\x20message\x20would\x20have\x20to\x20be\
    \n\x20parsed\x20in\x20order\x20to\x20perform\x20the\x20check,\x20defeati\
    ng\x20the\x20purpose\x20of\x20lazy\n\x20parsing.\x20\x20An\x20implementa\
    tion\x20which\x20chooses\x20not\x20to\x20check\x20required\x20fields\n\
    \x20must\x20be\x20consistent\x20about\x20it.\x20\x20That\x20is,\x20for\
    \x20any\x20particular\x20sub-message,\x20the\n\x20implementation\x20must\
    \x20either\x20*always*\x20check\x20its\x20required\x20fields,\x20or\x20*\
    never*\n\x20check\x20its\x20required\x20fields,\x20regardless\x20of\x20w\
    hether\x20or\x20not\x20the\x20message\x20has\n\x20been\x20parsed.\n\n\r\
    \n\x05\x04\x0c\x02\x03\x04\x12\x04\xde\x04\x02\n\n\r\n\x05\x04\x0c\x02\
    \x03\x05\x12\x04\xde\x04\x0b\x0f\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\
    \xde\x04\x10\x14\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\xde\x04\x17\x18\n\
    \r\n\x05\x04\x0c\x02\x03\x08\x12\x04\xde\x04\x19*\n\r\n\x05\x04\x0c\x02\
    \x03\x07\x12\x04\xde\x04$)\n\xe8\x01\n\x04\x04\x0c\x02\x04\x12\x04\xe4\
    \x04\x021\x1a\xd9\x01\x20Is\x20this\x20field\x20deprecated?\n\x20Dependi\
    ng\x20on\x20the\x20target\x20platform,\x20this\x20can\x20emit\x20Depreca\
    ted\x20annotations\n\x20for\x20accessors,\x20or\x20it\x20will\x20be\x20c\
    ompletely\x20ignored;\x20in\x20the\x20very\x20least,\x20this\n\x20is\x20\
    a\x20formalization\x20for\x20deprecating\x20fields.\n\n\r\n\x05\x04\x0c\
    \x02\x04\x04\x12\x04\xe4\x04\x02\n\n\r\n\x05\x04\x0c\x02\x04\x05\x12\x04\
    \xe4\x04\x0b\x0f\n\r\n\x05\x04\x0c\x02\x04\x01\x12\x04\xe4\x04\x10\x1a\n\
    \r\n\x05\x04\x0c\x02\x04\x03\x12\x04\xe4\x04\x1d\x1e\n\r\n\x05\x04\x0c\
    \x02\x04\x08\x12\x04\xe4\x04\x1f0\n\r\n\x05\x04\x0c\x02\x04\x07\x12\x04\
    \xe4\x04*/\n?\n\x04\x04\x0c\x02\x05\x12\x04\xe7\x04\x02,\x1a1\x20For\x20\
    Google-internal\x20migration\x20only.\x20Do\x20not\x20use.\n\n\r\n\x05\
    \x04\x0c\x02\x05\x04\x12\x04\xe7\x04\x02\n\n\r\n\x05\x04\x0c\x02\x05\x05\
    \x12\x04\xe7\x04\x0b\x0f\n\r\n\x05\x04\x0c\x02\x05\x01\x12\x04\xe7\x04\
    \x10\x14\n\r\n\x05\x04\x0c\x02\x05\x03\x12\x04\xe7\x04\x17\x19\n\r\n\x05\
    \x04\x0c\x02\x05\x08\x12\x04\xe7\x04\x1a+\n\r\n\x05\x04\x0c\x02\x05\x07\
    \x12\x04\xe7\x04%*\nO\n\x04\x04\x0c\x02\x06\x12\x04\xeb\x04\x02:\x1aA\
    \x20The\x20parser\x20stores\x20options\x20it\x20doesn't\x20recognize\x20\
    here.\x20See\x20above.\n\n\r\n\x05\x04\x0c\x02\x06\x04\x12\x04\xeb\x04\
    \x02\n\n\r\n\x05\x04\x0c\x02\x06\x06\x12\x04\xeb\x04\x0b\x1e\n\r\n\x05\
    \x04\x0c\x02\x06\x01\x12\x04\xeb\x04\x1f3\n\r\n\x05\x04\x0c\x02\x06\x03\
    \x12\x04\xeb\x0469\nZ\n\x03\x04\x0c\x05\x12\x04\xee\x04\x02\x19\x1aM\x20\
    Clients\x20can\x20define\x20custom\x20options\x20in\x20extensions\x20of\
    \x20this\x20message.\x20See\x20above.\n\n\x0c\n\x04\x04\x0c\x05\0\x12\
    \x04\xee\x04\r\x18\n\r\n\x05\x04\x0c\x05\0\x01\x12\x04\xee\x04\r\x11\n\r\
    \n\x05\x04\x0c\x05\0\x02\x12\x04\xee\x04\x15\x18\n\x1c\n\x03\x04\x0c\t\
    \x12\x04\xf0\x04\x02\r\"\x0f\x20removed\x20jtype\n\n\x0c\n\x04\x04\x0c\t\
    \0\x12\x04\xf0\x04\x0b\x0c\n\r\n\x05\x04\x0c\t\0\x01\x12\x04\xf0\x04\x0b\
    \x0c\n\r\n\x05\x04\x0c\t\0\x02\x12\x04\xf0\x04\x0b\x0c\n\x0c\n\x02\x04\r\
    \x12\x06\xf3\x04\0\xf9\x04\x01\n\x0b\n\x03\x04\r\x01\x12\x04\xf3\x04\x08\
    \x14\nO\n\x04\x04\r\x02\0\x12\x04\xf5\x04\x02:\x1aA\x20The\x20parser\x20\
    stores\x20options\x20it\x20doesn't\x20recognize\x20here.\x20See\x20above\
    .\n\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xf5\x04\x02\n\n\r\n\x05\x04\r\x02\
    \0\x06\x12\x04\xf5\x04\x0b\x1e\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xf5\x04\
    \x1f3\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xf5\x0469\nZ\n\x03\x04\r\x05\x12\
    \x04\xf8\x04\x02\x19\x1aM\x20Clients\x20can\x20define\x20custom\x20optio\
    ns\x20in\x20extensions\x20of\x20this\x20message.\x20See\x20above.\n\n\
    \x0c\n\x04\x04\r\x05\0\x12\x04\xf8\x04\r\x18\n\r\n\x05\x04\r\x05\0\x01\
    \x12\x04\xf8\x04\r\x11\n\r\n\x05\x04\r\x05\0\x02\x12\x04\xf8\x04\x15\x18\
    \n\x0c\n\x02\x04\x0e\x12\x06\xfb\x04\0\x8e\x05\x01\n\x0b\n\x03\x04\x0e\
    \x01\x12\x04\xfb\x04\x08\x13\n`\n\x04\x04\x0e\x02\0\x12\x04\xff\x04\x02\
    \x20\x1aR\x20Set\x20this\x20option\x20to\x20true\x20to\x20allow\x20mappi\
    ng\x20different\x20tag\x20names\x20to\x20the\x20same\n\x20value.\n\n\r\n\
    \x05\x04\x0e\x02\0\x04\x12\x04\xff\x04\x02\n\n\r\n\x05\x04\x0e\x02\0\x05\
    \x12\x04\xff\x04\x0b\x0f\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xff\x04\x10\
    \x1b\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xff\x04\x1e\x1f\n\xe5\x01\n\x04\
    \x04\x0e\x02\x01\x12\x04\x85\x05\x021\x1a\xd6\x01\x20Is\x20this\x20enum\
    \x20deprecated?\n\x20Depending\x20on\x20the\x20target\x20platform,\x20th\
    is\x20can\x20emit\x20Deprecated\x20annotations\n\x20for\x20the\x20enum,\
    \x20or\x20it\x20will\x20be\x20completely\x20ignored;\x20in\x20the\x20ver\
    y\x20least,\x20this\n\x20is\x20a\x20formalization\x20for\x20deprecating\
    \x20enums.\n\n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\x85\x05\x02\n\n\r\n\
    \x05\x04\x0e\x02\x01\x05\x12\x04\x85\x05\x0b\x0f\n\r\n\x05\x04\x0e\x02\
    \x01\x01\x12\x04\x85\x05\x10\x1a\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\
    \x85\x05\x1d\x1e\n\r\n\x05\x04\x0e\x02\x01\x08\x12\x04\x85\x05\x1f0\n\r\
    \n\x05\x04\x0e\x02\x01\x07\x12\x04\x85\x05*/\n\x1f\n\x03\x04\x0e\t\x12\
    \x04\x87\x05\x02\r\"\x12\x20javanano_as_lite\n\n\x0c\n\x04\x04\x0e\t\0\
    \x12\x04\x87\x05\x0b\x0c\n\r\n\x05\x04\x0e\t\0\x01\x12\x04\x87\x05\x0b\
    \x0c\n\r\n\x05\x04\x0e\t\0\x02\x12\x04\x87\x05\x0b\x0c\nO\n\x04\x04\x0e\
    \x02\x02\x12\x04\x8a\x05\x02:\x1aA\x20The\x20parser\x20stores\x20options\
    \x20it\x20doesn't\x20recognize\x20here.\x20See\x20above.\n\n\r\n\x05\x04\
    \x0e\x02\x02\x04\x12\x04\x8a\x05\x02\n\n\r\n\x05\x04\x0e\x02\x02\x06\x12\
    \x04\x8a\x05\x0b\x1e\n\r\n\x05\x04\x0e\x02\x02\x01\x12\x04\x8a\x05\x1f3\
    \n\r\n\x05\x04\x0e\x02\x02\x03\x12\x04\x8a\x0569\nZ\n\x03\x04\x0e\x05\
    \x12\x04\x8d\x05\x02\x19\x1aM\x20Clients\x20can\x20define\x20custom\x20o\
    ptions\x20in\x20extensions\x20of\x20this\x20message.\x20See\x20above.\n\
    \n\x0c\n\x04\x04\x0e\x05\0\x12\x04\x8d\x05\r\x18\n\r\n\x05\x04\x0e\x05\0\
    \x01\x12\x04\x8d\x05\r\x11\n\r\n\x05\x04\x0e\x05\0\x02\x12\x04\x8d\x05\
    \x15\x18\n\x0c\n\x02\x04\x0f\x12\x06\x90\x05\0\x9c\x05\x01\n\x0b\n\x03\
    \x04\x0f\x01\x12\x04\x90\x05\x08\x18\n\xf7\x01\n\x04\x04\x0f\x02\0\x12\
    \x04\x95\x05\x021\x1a\xe8\x01\x20Is\x20this\x20enum\x20value\x20deprecat\
    ed?\n\x20Depending\x20on\x20the\x20target\x20platform,\x20this\x20can\
    \x20emit\x20Deprecated\x20annotations\n\x20for\x20the\x20enum\x20value,\
    \x20or\x20it\x20will\x20be\x20completely\x20ignored;\x20in\x20the\x20ver\
    y\x20least,\n\x20this\x20is\x20a\x20formalization\x20for\x20deprecating\
    \x20enum\x20values.\n\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\x95\x05\x02\n\
    \n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\x95\x05\x0b\x0f\n\r\n\x05\x04\x0f\
    \x02\0\x01\x12\x04\x95\x05\x10\x1a\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\
    \x95\x05\x1d\x1e\n\r\n\x05\x04\x0f\x02\0\x08\x12\x04\x95\x05\x1f0\n\r\n\
    \x05\x04\x0f\x02\0\x07\x12\x04\x95\x05*/\nO\n\x04\x04\x0f\x02\x01\x12\
    \x04\x98\x05\x02:\x1aA\x20The\x20parser\x20stores\x20options\x20it\x20do\
    esn't\x20recognize\x20here.\x20See\x20above.\n\n\r\n\x05\x04\x0f\x02\x01\
    \x04\x12\x04\x98\x05\x02\n\n\r\n\x05\x04\x0f\x02\x01\x06\x12\x04\x98\x05\
    \x0b\x1e\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\x98\x05\x1f3\n\r\n\x05\
    \x04\x0f\x02\x01\x03\x12\x04\x98\x0569\nZ\n\x03\x04\x0f\x05\x12\x04\x9b\
    \x05\x02\x19\x1aM\x20Clients\x20can\x20define\x20custom\x20options\x20in\
    \x20extensions\x20of\x20this\x20message.\x20See\x20above.\n\n\x0c\n\x04\
    \x04\x0f\x05\0\x12\x04\x9b\x05\r\x18\n\r\n\x05\x04\x0f\x05\0\x01\x12\x04\
    \x9b\x05\r\x11\n\r\n\x05\x04\x0f\x05\0\x02\x12\x04\x9b\x05\x15\x18\n\x0c\
    \n\x02\x04\x10\x12\x06\x9e\x05\0\xb0\x05\x01\n\x0b\n\x03\x04\x10\x01\x12\
    \x04\x9e\x05\x08\x16\n\xd9\x03\n\x04\x04\x10\x02\0\x12\x04\xa9\x05\x022\
    \x1a\xdf\x01\x20Is\x20this\x20service\x20deprecated?\n\x20Depending\x20o\
    n\x20the\x20target\x20platform,\x20this\x20can\x20emit\x20Deprecated\x20\
    annotations\n\x20for\x20the\x20service,\x20or\x20it\x20will\x20be\x20com\
    pletely\x20ignored;\x20in\x20the\x20very\x20least,\n\x20this\x20is\x20a\
    \x20formalization\x20for\x20deprecating\x20services.\n2\xe8\x01\x20Note:\
    \x20\x20Field\x20numbers\x201\x20through\x2032\x20are\x20reserved\x20for\
    \x20Google's\x20internal\x20RPC\n\x20\x20\x20framework.\x20\x20We\x20apo\
    logize\x20for\x20hoarding\x20these\x20numbers\x20to\x20ourselves,\x20but\
    \n\x20\x20\x20we\x20were\x20already\x20using\x20them\x20long\x20before\
    \x20we\x20decided\x20to\x20release\x20Protocol\n\x20\x20\x20Buffers.\n\n\
    \r\n\x05\x04\x10\x02\0\x04\x12\x04\xa9\x05\x02\n\n\r\n\x05\x04\x10\x02\0\
    \x05\x12\x04\xa9\x05\x0b\x0f\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xa9\x05\
    \x10\x1a\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xa9\x05\x1d\x1f\n\r\n\x05\
    \x04\x10\x02\0\x08\x12\x04\xa9\x05\x201\n\r\n\x05\x04\x10\x02\0\x07\x12\
    \x04\xa9\x05+0\nO\n\x04\x04\x10\x02\x01\x12\x04\xac\x05\x02:\x1aA\x20The\
    \x20parser\x20stores\x20options\x20it\x20doesn't\x20recognize\x20here.\
    \x20See\x20above.\n\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\xac\x05\x02\n\
    \n\r\n\x05\x04\x10\x02\x01\x06\x12\x04\xac\x05\x0b\x1e\n\r\n\x05\x04\x10\
    \x02\x01\x01\x12\x04\xac\x05\x1f3\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\
    \xac\x0569\nZ\n\x03\x04\x10\x05\x12\x04\xaf\x05\x02\x19\x1aM\x20Clients\
    \x20can\x20define\x20custom\x20options\x20in\x20extensions\x20of\x20this\
    \x20message.\x20See\x20above.\n\n\x0c\n\x04\x04\x10\x05\0\x12\x04\xaf\
    \x05\r\x18\n\r\n\x05\x04\x10\x05\0\x01\x12\x04\xaf\x05\r\x11\n\r\n\x05\
    \x04\x10\x05\0\x02\x12\x04\xaf\x05\x15\x18\n\x0c\n\x02\x04\x11\x12\x06\
    \xb2\x05\0\xcf\x05\x01\n\x0b\n\x03\x04\x11\x01\x12\x04\xb2\x05\x08\x15\n\
    \xd6\x03\n\x04\x04\x11\x02\0\x12\x04\xbd\x05\x022\x1a\xdc\x01\x20Is\x20t\
    his\x20method\x20deprecated?\n\x20Depending\x20on\x20the\x20target\x20pl\
    atform,\x20this\x20can\x20emit\x20Deprecated\x20annotations\n\x20for\x20\
    the\x20method,\x20or\x20it\x20will\x20be\x20completely\x20ignored;\x20in\
    \x20the\x20very\x20least,\n\x20this\x20is\x20a\x20formalization\x20for\
    \x20deprecating\x20methods.\n2\xe8\x01\x20Note:\x20\x20Field\x20numbers\
    \x201\x20through\x2032\x20are\x20reserved\x20for\x20Google's\x20internal\
    \x20RPC\n\x20\x20\x20framework.\x20\x20We\x20apologize\x20for\x20hoardin\
    g\x20these\x20numbers\x20to\x20ourselves,\x20but\n\x20\x20\x20we\x20were\
    \x20already\x20using\x20them\x20long\x20before\x20we\x20decided\x20to\
    \x20release\x20Protocol\n\x20\x20\x20Buffers.\n\n\r\n\x05\x04\x11\x02\0\
    \x04\x12\x04\xbd\x05\x02\n\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xbd\x05\
    \x0b\x0f\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xbd\x05\x10\x1a\n\r\n\x05\
    \x04\x11\x02\0\x03\x12\x04\xbd\x05\x1d\x1f\n\r\n\x05\x04\x11\x02\0\x08\
    \x12\x04\xbd\x05\x201\n\r\n\x05\x04\x11\x02\0\x07\x12\x04\xbd\x05+0\n\
    \xf0\x01\n\x04\x04\x11\x04\0\x12\x06\xc2\x05\x02\xc6\x05\x03\x1a\xdf\x01\
    \x20Is\x20this\x20method\x20side-effect-free\x20(or\x20safe\x20in\x20HTT\
    P\x20parlance),\x20or\x20idempotent,\n\x20or\x20neither?\x20HTTP\x20base\
    d\x20RPC\x20implementation\x20may\x20choose\x20GET\x20verb\x20for\x20saf\
    e\n\x20methods,\x20and\x20PUT\x20verb\x20for\x20idempotent\x20methods\
    \x20instead\x20of\x20the\x20default\x20POST.\n\n\r\n\x05\x04\x11\x04\0\
    \x01\x12\x04\xc2\x05\x07\x17\n\x0e\n\x06\x04\x11\x04\0\x02\0\x12\x04\xc3\
    \x05\x04\x1c\n\x0f\n\x07\x04\x11\x04\0\x02\0\x01\x12\x04\xc3\x05\x04\x17\
    \n\x0f\n\x07\x04\x11\x04\0\x02\0\x02\x12\x04\xc3\x05\x1a\x1b\n$\n\x06\
    \x04\x11\x04\0\x02\x01\x12\x04\xc4\x05\x04\x18\"\x14\x20implies\x20idemp\
    otent\n\n\x0f\n\x07\x04\x11\x04\0\x02\x01\x01\x12\x04\xc4\x05\x04\x13\n\
    \x0f\n\x07\x04\x11\x04\0\x02\x01\x02\x12\x04\xc4\x05\x16\x17\n7\n\x06\
    \x04\x11\x04\0\x02\x02\x12\x04\xc5\x05\x04\x13\"'\x20idempotent,\x20but\
    \x20may\x20have\x20side\x20effects\n\n\x0f\n\x07\x04\x11\x04\0\x02\x02\
    \x01\x12\x04\xc5\x05\x04\x0e\n\x0f\n\x07\x04\x11\x04\0\x02\x02\x02\x12\
    \x04\xc5\x05\x11\x12\n\x0e\n\x04\x04\x11\x02\x01\x12\x06\xc7\x05\x02\xc8\
    \x05&\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xc7\x05\x02\n\n\r\n\x05\x04\
    \x11\x02\x01\x06\x12\x04\xc7\x05\x0b\x1b\n\r\n\x05\x04\x11\x02\x01\x01\
    \x12\x04\xc7\x05\x1c-\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xc7\x0502\n\
    \r\n\x05\x04\x11\x02\x01\x08\x12\x04\xc8\x05\x06%\n\r\n\x05\x04\x11\x02\
    \x01\x07\x12\x04\xc8\x05\x11$\nO\n\x04\x04\x11\x02\x02\x12\x04\xcb\x05\
    \x02:\x1aA\x20The\x20parser\x20stores\x20options\x20it\x20doesn't\x20rec\
    ognize\x20here.\x20See\x20above.\n\n\r\n\x05\x04\x11\x02\x02\x04\x12\x04\
    \xcb\x05\x02\n\n\r\n\x05\x04\x11\x02\x02\x06\x12\x04\xcb\x05\x0b\x1e\n\r\
    \n\x05\x04\x11\x02\x02\x01\x12\x04\xcb\x05\x1f3\n\r\n\x05\x04\x11\x02\
    \x02\x03\x12\x04\xcb\x0569\nZ\n\x03\x04\x11\x05\x12\x04\xce\x05\x02\x19\
    \x1aM\x20Clients\x20can\x20define\x20custom\x20options\x20in\x20extensio\
    ns\x20of\x20this\x20message.\x20See\x20above.\n\n\x0c\n\x04\x04\x11\x05\
    \0\x12\x04\xce\x05\r\x18\n\r\n\x05\x04\x11\x05\0\x01\x12\x04\xce\x05\r\
    \x11\n\r\n\x05\x04\x11\x05\0\x02\x12\x04\xce\x05\x15\x18\n\x8b\x03\n\x02\
    \x04\x12\x12\x06\xd8\x05\0\xec\x05\x01\x1a\xfc\x02\x20A\x20message\x20re\
    presenting\x20a\x20option\x20the\x20parser\x20does\x20not\x20recognize.\
    \x20This\x20only\n\x20appears\x20in\x20options\x20protos\x20created\x20b\
    y\x20the\x20compiler::Parser\x20class.\n\x20DescriptorPool\x20resolves\
    \x20these\x20when\x20building\x20Descriptor\x20objects.\x20Therefore,\n\
    \x20options\x20protos\x20in\x20descriptor\x20objects\x20(e.g.\x20returne\
    d\x20by\x20Descriptor::options(),\n\x20or\x20produced\x20by\x20Descripto\
    r::CopyTo())\x20will\x20never\x20have\x20UninterpretedOptions\n\x20in\
    \x20them.\n\n\x0b\n\x03\x04\x12\x01\x12\x04\xd8\x05\x08\x1b\n\xcb\x02\n\
    \x04\x04\x12\x03\0\x12\x06\xde\x05\x02\xe1\x05\x03\x1a\xba\x02\x20The\
    \x20name\x20of\x20the\x20uninterpreted\x20option.\x20\x20Each\x20string\
    \x20represents\x20a\x20segment\x20in\n\x20a\x20dot-separated\x20name.\
    \x20\x20is_extension\x20is\x20true\x20iff\x20a\x20segment\x20represents\
    \x20an\n\x20extension\x20(denoted\x20with\x20parentheses\x20in\x20option\
    s\x20specs\x20in\x20.proto\x20files).\n\x20E.g.,{\x20[\"foo\",\x20false]\
    ,\x20[\"bar.baz\",\x20true],\x20[\"qux\",\x20false]\x20}\x20represents\n\
    \x20\"foo.(bar.baz).qux\".\n\n\r\n\x05\x04\x12\x03\0\x01\x12\x04\xde\x05\
    \n\x12\n\x0e\n\x06\x04\x12\x03\0\x02\0\x12\x04\xdf\x05\x04\"\n\x0f\n\x07\
    \x04\x12\x03\0\x02\0\x04\x12\x04\xdf\x05\x04\x0c\n\x0f\n\x07\x04\x12\x03\
    \0\x02\0\x05\x12\x04\xdf\x05\r\x13\n\x0f\n\x07\x04\x12\x03\0\x02\0\x01\
    \x12\x04\xdf\x05\x14\x1d\n\x0f\n\x07\x04\x12\x03\0\x02\0\x03\x12\x04\xdf\
    \x05\x20!\n\x0e\n\x06\x04\x12\x03\0\x02\x01\x12\x04\xe0\x05\x04#\n\x0f\n\
    \x07\x04\x12\x03\0\x02\x01\x04\x12\x04\xe0\x05\x04\x0c\n\x0f\n\x07\x04\
    \x12\x03\0\x02\x01\x05\x12\x04\xe0\x05\r\x11\n\x0f\n\x07\x04\x12\x03\0\
    \x02\x01\x01\x12\x04\xe0\x05\x12\x1e\n\x0f\n\x07\x04\x12\x03\0\x02\x01\
    \x03\x12\x04\xe0\x05!\"\n\x0c\n\x04\x04\x12\x02\0\x12\x04\xe2\x05\x02\
    \x1d\n\r\n\x05\x04\x12\x02\0\x04\x12\x04\xe2\x05\x02\n\n\r\n\x05\x04\x12\
    \x02\0\x06\x12\x04\xe2\x05\x0b\x13\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\
    \xe2\x05\x14\x18\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xe2\x05\x1b\x1c\n\
    \x9c\x01\n\x04\x04\x12\x02\x01\x12\x04\xe6\x05\x02'\x1a\x8d\x01\x20The\
    \x20value\x20of\x20the\x20uninterpreted\x20option,\x20in\x20whatever\x20\
    type\x20the\x20tokenizer\n\x20identified\x20it\x20as\x20during\x20parsin\
    g.\x20Exactly\x20one\x20of\x20these\x20should\x20be\x20set.\n\n\r\n\x05\
    \x04\x12\x02\x01\x04\x12\x04\xe6\x05\x02\n\n\r\n\x05\x04\x12\x02\x01\x05\
    \x12\x04\xe6\x05\x0b\x11\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xe6\x05\
    \x12\"\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xe6\x05%&\n\x0c\n\x04\x04\
    \x12\x02\x02\x12\x04\xe7\x05\x02)\n\r\n\x05\x04\x12\x02\x02\x04\x12\x04\
    \xe7\x05\x02\n\n\r\n\x05\x04\x12\x02\x02\x05\x12\x04\xe7\x05\x0b\x11\n\r\
    \n\x05\x04\x12\x02\x02\x01\x12\x04\xe7\x05\x12$\n\r\n\x05\x04\x12\x02\
    \x02\x03\x12\x04\xe7\x05'(\n\x0c\n\x04\x04\x12\x02\x03\x12\x04\xe8\x05\
    \x02(\n\r\n\x05\x04\x12\x02\x03\x04\x12\x04\xe8\x05\x02\n\n\r\n\x05\x04\
    \x12\x02\x03\x05\x12\x04\xe8\x05\x0b\x10\n\r\n\x05\x04\x12\x02\x03\x01\
    \x12\x04\xe8\x05\x11#\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\xe8\x05&'\n\
    \x0c\n\x04\x04\x12\x02\x04\x12\x04\xe9\x05\x02#\n\r\n\x05\x04\x12\x02\
    \x04\x04\x12\x04\xe9\x05\x02\n\n\r\n\x05\x04\x12\x02\x04\x05\x12\x04\xe9\
    \x05\x0b\x11\n\r\n\x05\x04\x12\x02\x04\x01\x12\x04\xe9\x05\x12\x1e\n\r\n\
    \x05\x04\x12\x02\x04\x03\x12\x04\xe9\x05!\"\n\x0c\n\x04\x04\x12\x02\x05\
    \x12\x04\xea\x05\x02\"\n\r\n\x05\x04\x12\x02\x05\x04\x12\x04\xea\x05\x02\
    \n\n\r\n\x05\x04\x12\x02\x05\x05\x12\x04\xea\x05\x0b\x10\n\r\n\x05\x04\
    \x12\x02\x05\x01\x12\x04\xea\x05\x11\x1d\n\r\n\x05\x04\x12\x02\x05\x03\
    \x12\x04\xea\x05\x20!\n\x0c\n\x04\x04\x12\x02\x06\x12\x04\xeb\x05\x02&\n\
    \r\n\x05\x04\x12\x02\x06\x04\x12\x04\xeb\x05\x02\n\n\r\n\x05\x04\x12\x02\
    \x06\x05\x12\x04\xeb\x05\x0b\x11\n\r\n\x05\x04\x12\x02\x06\x01\x12\x04\
    \xeb\x05\x12!\n\r\n\x05\x04\x12\x02\x06\x03\x12\x04\xeb\x05$%\n\xda\x01\
    \n\x02\x04\x13\x12\x06\xf3\x05\0\xf4\x06\x01\x1aj\x20Encapsulates\x20inf\
    ormation\x20about\x20the\x20original\x20source\x20file\x20from\x20which\
    \x20a\n\x20FileDescriptorProto\x20was\x20generated.\n2`\x20=============\
    ======================================================\n\x20Optional\x20\
    source\x20code\x20info\n\n\x0b\n\x03\x04\x13\x01\x12\x04\xf3\x05\x08\x16\
    \n\x82\x11\n\x04\x04\x13\x02\0\x12\x04\x9f\x06\x02!\x1a\xf3\x10\x20A\x20\
    Location\x20identifies\x20a\x20piece\x20of\x20source\x20code\x20in\x20a\
    \x20.proto\x20file\x20which\n\x20corresponds\x20to\x20a\x20particular\
    \x20definition.\x20\x20This\x20information\x20is\x20intended\n\x20to\x20\
    be\x20useful\x20to\x20IDEs,\x20code\x20indexers,\x20documentation\x20gen\
    erators,\x20and\x20similar\n\x20tools.\n\n\x20For\x20example,\x20say\x20\
    we\x20have\x20a\x20file\x20like:\n\x20\x20\x20message\x20Foo\x20{\n\x20\
    \x20\x20\x20\x20optional\x20string\x20foo\x20=\x201;\n\x20\x20\x20}\n\
    \x20Let's\x20look\x20at\x20just\x20the\x20field\x20definition:\n\x20\x20\
    \x20optional\x20string\x20foo\x20=\x201;\n\x20\x20\x20^\x20\x20\x20\x20\
    \x20\x20\x20^^\x20\x20\x20\x20\x20^^\x20\x20^\x20\x20^^^\n\x20\x20\x20a\
    \x20\x20\x20\x20\x20\x20\x20bc\x20\x20\x20\x20\x20de\x20\x20f\x20\x20ghi\
    \n\x20We\x20have\x20the\x20following\x20locations:\n\x20\x20\x20span\x20\
    \x20\x20path\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    represents\n\x20\x20\x20[a,i)\x20\x20[\x204,\x200,\x202,\x200\x20]\x20\
    \x20\x20\x20\x20The\x20whole\x20field\x20definition.\n\x20\x20\x20[a,b)\
    \x20\x20[\x204,\x200,\x202,\x200,\x204\x20]\x20\x20The\x20label\x20(opti\
    onal).\n\x20\x20\x20[c,d)\x20\x20[\x204,\x200,\x202,\x200,\x205\x20]\x20\
    \x20The\x20type\x20(string).\n\x20\x20\x20[e,f)\x20\x20[\x204,\x200,\x20\
    2,\x200,\x201\x20]\x20\x20The\x20name\x20(foo).\n\x20\x20\x20[g,h)\x20\
    \x20[\x204,\x200,\x202,\x200,\x203\x20]\x20\x20The\x20number\x20(1).\n\n\
    \x20Notes:\n\x20-\x20A\x20location\x20may\x20refer\x20to\x20a\x20repeate\
    d\x20field\x20itself\x20(i.e.\x20not\x20to\x20any\n\x20\x20\x20particula\
    r\x20index\x20within\x20it).\x20\x20This\x20is\x20used\x20whenever\x20a\
    \x20set\x20of\x20elements\x20are\n\x20\x20\x20logically\x20enclosed\x20i\
    n\x20a\x20single\x20code\x20segment.\x20\x20For\x20example,\x20an\x20ent\
    ire\n\x20\x20\x20extend\x20block\x20(possibly\x20containing\x20multiple\
    \x20extension\x20definitions)\x20will\n\x20\x20\x20have\x20an\x20outer\
    \x20location\x20whose\x20path\x20refers\x20to\x20the\x20\"extensions\"\
    \x20repeated\n\x20\x20\x20field\x20without\x20an\x20index.\n\x20-\x20Mul\
    tiple\x20locations\x20may\x20have\x20the\x20same\x20path.\x20\x20This\
    \x20happens\x20when\x20a\x20single\n\x20\x20\x20logical\x20declaration\
    \x20is\x20spread\x20out\x20across\x20multiple\x20places.\x20\x20The\x20m\
    ost\n\x20\x20\x20obvious\x20example\x20is\x20the\x20\"extend\"\x20block\
    \x20again\x20--\x20there\x20may\x20be\x20multiple\n\x20\x20\x20extend\
    \x20blocks\x20in\x20the\x20same\x20scope,\x20each\x20of\x20which\x20will\
    \x20have\x20the\x20same\x20path.\n\x20-\x20A\x20location's\x20span\x20is\
    \x20not\x20always\x20a\x20subset\x20of\x20its\x20parent's\x20span.\x20\
    \x20For\n\x20\x20\x20example,\x20the\x20\"extendee\"\x20of\x20an\x20exte\
    nsion\x20declaration\x20appears\x20at\x20the\n\x20\x20\x20beginning\x20o\
    f\x20the\x20\"extend\"\x20block\x20and\x20is\x20shared\x20by\x20all\x20e\
    xtensions\x20within\n\x20\x20\x20the\x20block.\n\x20-\x20Just\x20because\
    \x20a\x20location's\x20span\x20is\x20a\x20subset\x20of\x20some\x20other\
    \x20location's\x20span\n\x20\x20\x20does\x20not\x20mean\x20that\x20it\
    \x20is\x20a\x20descendant.\x20\x20For\x20example,\x20a\x20\"group\"\x20d\
    efines\n\x20\x20\x20both\x20a\x20type\x20and\x20a\x20field\x20in\x20a\
    \x20single\x20declaration.\x20\x20Thus,\x20the\x20locations\n\x20\x20\
    \x20corresponding\x20to\x20the\x20type\x20and\x20field\x20and\x20their\
    \x20components\x20will\x20overlap.\n\x20-\x20Code\x20which\x20tries\x20t\
    o\x20interpret\x20locations\x20should\x20probably\x20be\x20designed\x20t\
    o\n\x20\x20\x20ignore\x20those\x20that\x20it\x20doesn't\x20understand,\
    \x20as\x20more\x20types\x20of\x20locations\x20could\n\x20\x20\x20be\x20r\
    ecorded\x20in\x20the\x20future.\n\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\
    \x9f\x06\x02\n\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\x9f\x06\x0b\x13\n\r\n\
    \x05\x04\x13\x02\0\x01\x12\x04\x9f\x06\x14\x1c\n\r\n\x05\x04\x13\x02\0\
    \x03\x12\x04\x9f\x06\x1f\x20\n\x0e\n\x04\x04\x13\x03\0\x12\x06\xa0\x06\
    \x02\xf3\x06\x03\n\r\n\x05\x04\x13\x03\0\x01\x12\x04\xa0\x06\n\x12\n\x83\
    \x07\n\x06\x04\x13\x03\0\x02\0\x12\x04\xb8\x06\x04,\x1a\xf2\x06\x20Ident\
    ifies\x20which\x20part\x20of\x20the\x20FileDescriptorProto\x20was\x20def\
    ined\x20at\x20this\n\x20location.\n\n\x20Each\x20element\x20is\x20a\x20f\
    ield\x20number\x20or\x20an\x20index.\x20\x20They\x20form\x20a\x20path\
    \x20from\n\x20the\x20root\x20FileDescriptorProto\x20to\x20the\x20place\
    \x20where\x20the\x20definition.\x20\x20For\n\x20example,\x20this\x20path\
    :\n\x20\x20\x20[\x204,\x203,\x202,\x207,\x201\x20]\n\x20refers\x20to:\n\
    \x20\x20\x20file.message_type(3)\x20\x20//\x204,\x203\n\x20\x20\x20\x20\
    \x20\x20\x20.field(7)\x20\x20\x20\x20\x20\x20\x20\x20\x20//\x202,\x207\n\
    \x20\x20\x20\x20\x20\x20\x20.name()\x20\x20\x20\x20\x20\x20\x20\x20\x20\
    \x20\x20//\x201\n\x20This\x20is\x20because\x20FileDescriptorProto.messag\
    e_type\x20has\x20field\x20number\x204:\n\x20\x20\x20repeated\x20Descript\
    orProto\x20message_type\x20=\x204;\n\x20and\x20DescriptorProto.field\x20\
    has\x20field\x20number\x202:\n\x20\x20\x20repeated\x20FieldDescriptorPro\
    to\x20field\x20=\x202;\n\x20and\x20FieldDescriptorProto.name\x20has\x20f\
    ield\x20number\x201:\n\x20\x20\x20optional\x20string\x20name\x20=\x201;\
    \n\n\x20Thus,\x20the\x20above\x20path\x20gives\x20the\x20location\x20of\
    \x20a\x20field\x20name.\x20\x20If\x20we\x20removed\n\x20the\x20last\x20e\
    lement:\n\x20\x20\x20[\x204,\x203,\x202,\x207\x20]\n\x20this\x20path\x20\
    refers\x20to\x20the\x20whole\x20field\x20declaration\x20(from\x20the\x20\
    beginning\n\x20of\x20the\x20label\x20to\x20the\x20terminating\x20semicol\
    on).\n\n\x0f\n\x07\x04\x13\x03\0\x02\0\x04\x12\x04\xb8\x06\x04\x0c\n\x0f\
    \n\x07\x04\x13\x03\0\x02\0\x05\x12\x04\xb8\x06\r\x12\n\x0f\n\x07\x04\x13\
    \x03\0\x02\0\x01\x12\x04\xb8\x06\x13\x17\n\x0f\n\x07\x04\x13\x03\0\x02\0\
    \x03\x12\x04\xb8\x06\x1a\x1b\n\x0f\n\x07\x04\x13\x03\0\x02\0\x08\x12\x04\
    \xb8\x06\x1c+\n\x10\n\x08\x04\x13\x03\0\x02\0\x08\x02\x12\x04\xb8\x06\
    \x1d*\n\xd2\x02\n\x06\x04\x13\x03\0\x02\x01\x12\x04\xbf\x06\x04,\x1a\xc1\
    \x02\x20Always\x20has\x20exactly\x20three\x20or\x20four\x20elements:\x20\
    start\x20line,\x20start\x20column,\n\x20end\x20line\x20(optional,\x20oth\
    erwise\x20assumed\x20same\x20as\x20start\x20line),\x20end\x20column.\n\
    \x20These\x20are\x20packed\x20into\x20a\x20single\x20field\x20for\x20eff\
    iciency.\x20\x20Note\x20that\x20line\n\x20and\x20column\x20numbers\x20ar\
    e\x20zero-based\x20--\x20typically\x20you\x20will\x20want\x20to\x20add\n\
    \x201\x20to\x20each\x20before\x20displaying\x20to\x20a\x20user.\n\n\x0f\
    \n\x07\x04\x13\x03\0\x02\x01\x04\x12\x04\xbf\x06\x04\x0c\n\x0f\n\x07\x04\
    \x13\x03\0\x02\x01\x05\x12\x04\xbf\x06\r\x12\n\x0f\n\x07\x04\x13\x03\0\
    \x02\x01\x01\x12\x04\xbf\x06\x13\x17\n\x0f\n\x07\x04\x13\x03\0\x02\x01\
    \x03\x12\x04\xbf\x06\x1a\x1b\n\x0f\n\x07\x04\x13\x03\0\x02\x01\x08\x12\
    \x04\xbf\x06\x1c+\n\x10\n\x08\x04\x13\x03\0\x02\x01\x08\x02\x12\x04\xbf\
    \x06\x1d*\n\xa5\x0c\n\x06\x04\x13\x03\0\x02\x02\x12\x04\xf0\x06\x04)\x1a\
    \x94\x0c\x20If\x20this\x20SourceCodeInfo\x20represents\x20a\x20complete\
    \x20declaration,\x20these\x20are\x20any\n\x20comments\x20appearing\x20be\
    fore\x20and\x20after\x20the\x20declaration\x20which\x20appear\x20to\x20b\
    e\n\x20attached\x20to\x20the\x20declaration.\n\n\x20A\x20series\x20of\
    \x20line\x20comments\x20appearing\x20on\x20consecutive\x20lines,\x20with\
    \x20no\x20other\n\x20tokens\x20appearing\x20on\x20those\x20lines,\x20wil\
    l\x20be\x20treated\x20as\x20a\x20single\x20comment.\n\n\x20leading_detac\
    hed_comments\x20will\x20keep\x20paragraphs\x20of\x20comments\x20that\x20\
    appear\n\x20before\x20(but\x20not\x20connected\x20to)\x20the\x20current\
    \x20element.\x20Each\x20paragraph,\n\x20separated\x20by\x20empty\x20line\
    s,\x20will\x20be\x20one\x20comment\x20element\x20in\x20the\x20repeated\n\
    \x20field.\n\n\x20Only\x20the\x20comment\x20content\x20is\x20provided;\
    \x20comment\x20markers\x20(e.g.\x20//)\x20are\n\x20stripped\x20out.\x20\
    \x20For\x20block\x20comments,\x20leading\x20whitespace\x20and\x20an\x20a\
    sterisk\n\x20will\x20be\x20stripped\x20from\x20the\x20beginning\x20of\
    \x20each\x20line\x20other\x20than\x20the\x20first.\n\x20Newlines\x20are\
    \x20included\x20in\x20the\x20output.\n\n\x20Examples:\n\n\x20\x20\x20opt\
    ional\x20int32\x20foo\x20=\x201;\x20\x20//\x20Comment\x20attached\x20to\
    \x20foo.\n\x20\x20\x20//\x20Comment\x20attached\x20to\x20bar.\n\x20\x20\
    \x20optional\x20int32\x20bar\x20=\x202;\n\n\x20\x20\x20optional\x20strin\
    g\x20baz\x20=\x203;\n\x20\x20\x20//\x20Comment\x20attached\x20to\x20baz.\
    \n\x20\x20\x20//\x20Another\x20line\x20attached\x20to\x20baz.\n\n\x20\
    \x20\x20//\x20Comment\x20attached\x20to\x20qux.\n\x20\x20\x20//\n\x20\
    \x20\x20//\x20Another\x20line\x20attached\x20to\x20qux.\n\x20\x20\x20opt\
    ional\x20double\x20qux\x20=\x204;\n\n\x20\x20\x20//\x20Detached\x20comme\
    nt\x20for\x20corge.\x20This\x20is\x20not\x20leading\x20or\x20trailing\
    \x20comments\n\x20\x20\x20//\x20to\x20qux\x20or\x20corge\x20because\x20t\
    here\x20are\x20blank\x20lines\x20separating\x20it\x20from\n\x20\x20\x20/\
    /\x20both.\n\n\x20\x20\x20//\x20Detached\x20comment\x20for\x20corge\x20p\
    aragraph\x202.\n\n\x20\x20\x20optional\x20string\x20corge\x20=\x205;\n\
    \x20\x20\x20/*\x20Block\x20comment\x20attached\n\x20\x20\x20\x20*\x20to\
    \x20corge.\x20\x20Leading\x20asterisks\n\x20\x20\x20\x20*\x20will\x20be\
    \x20removed.\x20*/\n\x20\x20\x20/*\x20Block\x20comment\x20attached\x20to\
    \n\x20\x20\x20\x20*\x20grault.\x20*/\n\x20\x20\x20optional\x20int32\x20g\
    rault\x20=\x206;\n\n\x20\x20\x20//\x20ignored\x20detached\x20comments.\n\
    \n\x0f\n\x07\x04\x13\x03\0\x02\x02\x04\x12\x04\xf0\x06\x04\x0c\n\x0f\n\
    \x07\x04\x13\x03\0\x02\x02\x05\x12\x04\xf0\x06\r\x13\n\x0f\n\x07\x04\x13\
    \x03\0\x02\x02\x01\x12\x04\xf0\x06\x14$\n\x0f\n\x07\x04\x13\x03\0\x02\
    \x02\x03\x12\x04\xf0\x06'(\n\x0e\n\x06\x04\x13\x03\0\x02\x03\x12\x04\xf1\
    \x06\x04*\n\x0f\n\x07\x04\x13\x03\0\x02\x03\x04\x12\x04\xf1\x06\x04\x0c\
    \n\x0f\n\x07\x04\x13\x03\0\x02\x03\x05\x12\x04\xf1\x06\r\x13\n\x0f\n\x07\
    \x04\x13\x03\0\x02\x03\x01\x12\x04\xf1\x06\x14%\n\x0f\n\x07\x04\x13\x03\
    \0\x02\x03\x03\x12\x04\xf1\x06()\n\x0e\n\x06\x04\x13\x03\0\x02\x04\x12\
    \x04\xf2\x06\x042\n\x0f\n\x07\x04\x13\x03\0\x02\x04\x04\x12\x04\xf2\x06\
    \x04\x0c\n\x0f\n\x07\x04\x13\x03\0\x02\x04\x05\x12\x04\xf2\x06\r\x13\n\
    \x0f\n\x07\x04\x13\x03\0\x02\x04\x01\x12\x04\xf2\x06\x14-\n\x0f\n\x07\
    \x04\x13\x03\0\x02\x04\x03\x12\x04\xf2\x0601\n\xee\x01\n\x02\x04\x14\x12\
    \x06\xf9\x06\0\x8e\x07\x01\x1a\xdf\x01\x20Describes\x20the\x20relationsh\
    ip\x20between\x20generated\x20code\x20and\x20its\x20original\x20source\n\
    \x20file.\x20A\x20GeneratedCodeInfo\x20message\x20is\x20associated\x20wi\
    th\x20only\x20one\x20generated\n\x20source\x20file,\x20but\x20may\x20con\
    tain\x20references\x20to\x20different\x20source\x20.proto\x20files.\n\n\
    \x0b\n\x03\x04\x14\x01\x12\x04\xf9\x06\x08\x19\nx\n\x04\x04\x14\x02\0\
    \x12\x04\xfc\x06\x02%\x1aj\x20An\x20Annotation\x20connects\x20some\x20sp\
    an\x20of\x20text\x20in\x20generated\x20code\x20to\x20an\x20element\n\x20\
    of\x20its\x20generating\x20.proto\x20file.\n\n\r\n\x05\x04\x14\x02\0\x04\
    \x12\x04\xfc\x06\x02\n\n\r\n\x05\x04\x14\x02\0\x06\x12\x04\xfc\x06\x0b\
    \x15\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xfc\x06\x16\x20\n\r\n\x05\x04\
    \x14\x02\0\x03\x12\x04\xfc\x06#$\n\x0e\n\x04\x04\x14\x03\0\x12\x06\xfd\
    \x06\x02\x8d\x07\x03\n\r\n\x05\x04\x14\x03\0\x01\x12\x04\xfd\x06\n\x14\n\
    \x8f\x01\n\x06\x04\x14\x03\0\x02\0\x12\x04\x80\x07\x04,\x1a\x7f\x20Ident\
    ifies\x20the\x20element\x20in\x20the\x20original\x20source\x20.proto\x20\
    file.\x20This\x20field\n\x20is\x20formatted\x20the\x20same\x20as\x20Sour\
    ceCodeInfo.Location.path.\n\n\x0f\n\x07\x04\x14\x03\0\x02\0\x04\x12\x04\
    \x80\x07\x04\x0c\n\x0f\n\x07\x04\x14\x03\0\x02\0\x05\x12\x04\x80\x07\r\
    \x12\n\x0f\n\x07\x04\x14\x03\0\x02\0\x01\x12\x04\x80\x07\x13\x17\n\x0f\n\
    \x07\x04\x14\x03\0\x02\0\x03\x12\x04\x80\x07\x1a\x1b\n\x0f\n\x07\x04\x14\
    \x03\0\x02\0\x08\x12\x04\x80\x07\x1c+\n\x10\n\x08\x04\x14\x03\0\x02\0\
    \x08\x02\x12\x04\x80\x07\x1d*\nO\n\x06\x04\x14\x03\0\x02\x01\x12\x04\x83\
    \x07\x04$\x1a?\x20Identifies\x20the\x20filesystem\x20path\x20to\x20the\
    \x20original\x20source\x20.proto.\n\n\x0f\n\x07\x04\x14\x03\0\x02\x01\
    \x04\x12\x04\x83\x07\x04\x0c\n\x0f\n\x07\x04\x14\x03\0\x02\x01\x05\x12\
    \x04\x83\x07\r\x13\n\x0f\n\x07\x04\x14\x03\0\x02\x01\x01\x12\x04\x83\x07\
    \x14\x1f\n\x0f\n\x07\x04\x14\x03\0\x02\x01\x03\x12\x04\x83\x07\"#\nw\n\
    \x06\x04\x14\x03\0\x02\x02\x12\x04\x87\x07\x04\x1d\x1ag\x20Identifies\
    \x20the\x20starting\x20offset\x20in\x20bytes\x20in\x20the\x20generated\
    \x20code\n\x20that\x20relates\x20to\x20the\x20identified\x20object.\n\n\
    \x0f\n\x07\x04\x14\x03\0\x02\x02\x04\x12\x04\x87\x07\x04\x0c\n\x0f\n\x07\
    \x04\x14\x03\0\x02\x02\x05\x12\x04\x87\x07\r\x12\n\x0f\n\x07\x04\x14\x03\
    \0\x02\x02\x01\x12\x04\x87\x07\x13\x18\n\x0f\n\x07\x04\x14\x03\0\x02\x02\
    \x03\x12\x04\x87\x07\x1b\x1c\n\xdb\x01\n\x06\x04\x14\x03\0\x02\x03\x12\
    \x04\x8c\x07\x04\x1b\x1a\xca\x01\x20Identifies\x20the\x20ending\x20offse\
    t\x20in\x20bytes\x20in\x20the\x20generated\x20code\x20that\n\x20relates\
    \x20to\x20the\x20identified\x20offset.\x20The\x20end\x20offset\x20should\
    \x20be\x20one\x20past\n\x20the\x20last\x20relevant\x20byte\x20(so\x20the\
    \x20length\x20of\x20the\x20text\x20=\x20end\x20-\x20begin).\n\n\x0f\n\
    \x07\x04\x14\x03\0\x02\x03\x04\x12\x04\x8c\x07\x04\x0c\n\x0f\n\x07\x04\
    \x14\x03\0\x02\x03\x05\x12\x04\x8c\x07\r\x12\n\x0f\n\x07\x04\x14\x03\0\
    \x02\x03\x01\x12\x04\x8c\x07\x13\x16\n\x0f\n\x07\x04\x14\x03\0\x02\x03\
    \x03\x12\x04\x8c\x07\x19\x1a\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        crate::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static crate::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: crate::rt::Lazy<crate::reflect::GeneratedFileDescriptor> = crate::rt::Lazy::new();
    static file_descriptor: crate::rt::Lazy<crate::reflect::FileDescriptor> = crate::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(0);
            let mut messages = ::std::vec::Vec::with_capacity(27);
            messages.push(FileDescriptorSet::generated_message_descriptor_data());
            messages.push(FileDescriptorProto::generated_message_descriptor_data());
            messages.push(DescriptorProto::generated_message_descriptor_data());
            messages.push(ExtensionRangeOptions::generated_message_descriptor_data());
            messages.push(FieldDescriptorProto::generated_message_descriptor_data());
            messages.push(OneofDescriptorProto::generated_message_descriptor_data());
            messages.push(EnumDescriptorProto::generated_message_descriptor_data());
            messages.push(EnumValueDescriptorProto::generated_message_descriptor_data());
            messages.push(ServiceDescriptorProto::generated_message_descriptor_data());
            messages.push(MethodDescriptorProto::generated_message_descriptor_data());
            messages.push(FileOptions::generated_message_descriptor_data());
            messages.push(MessageOptions::generated_message_descriptor_data());
            messages.push(FieldOptions::generated_message_descriptor_data());
            messages.push(OneofOptions::generated_message_descriptor_data());
            messages.push(EnumOptions::generated_message_descriptor_data());
            messages.push(EnumValueOptions::generated_message_descriptor_data());
            messages.push(ServiceOptions::generated_message_descriptor_data());
            messages.push(MethodOptions::generated_message_descriptor_data());
            messages.push(UninterpretedOption::generated_message_descriptor_data());
            messages.push(SourceCodeInfo::generated_message_descriptor_data());
            messages.push(GeneratedCodeInfo::generated_message_descriptor_data());
            messages.push(descriptor_proto::ExtensionRange::generated_message_descriptor_data());
            messages.push(descriptor_proto::ReservedRange::generated_message_descriptor_data());
            messages.push(enum_descriptor_proto::EnumReservedRange::generated_message_descriptor_data());
            messages.push(uninterpreted_option::NamePart::generated_message_descriptor_data());
            messages.push(source_code_info::Location::generated_message_descriptor_data());
            messages.push(generated_code_info::Annotation::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(6);
            enums.push(field_descriptor_proto::Type::generated_enum_descriptor_data());
            enums.push(field_descriptor_proto::Label::generated_enum_descriptor_data());
            enums.push(file_options::OptimizeMode::generated_enum_descriptor_data());
            enums.push(field_options::CType::generated_enum_descriptor_data());
            enums.push(field_options::JSType::generated_enum_descriptor_data());
            enums.push(method_options::IdempotencyLevel::generated_enum_descriptor_data());
            crate::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        crate::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
