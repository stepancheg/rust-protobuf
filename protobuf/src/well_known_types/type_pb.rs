// This file is generated by rust-protobuf 3.0.0-pre. Do not edit
// .proto file is parsed by protoc --rust-out=...
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]

//! Generated file from `google/protobuf/type.proto`

///  A protocol buffer message type.
#[derive(PartialEq,Clone,Default)]
#[cfg_attr(serde, derive(Serialize, Deserialize))]
pub struct Type {
    // message fields
    ///  The fully qualified message name.
    pub name: ::std::string::String,
    ///  The list of fields.
    pub fields: crate::RepeatedField<Field>,
    ///  The list of types appearing in `oneof` definitions in this type.
    pub oneofs: crate::RepeatedField<::std::string::String>,
    ///  The protocol buffer options.
    pub options: crate::RepeatedField<Option>,
    ///  The source context.
    pub source_context: crate::SingularPtrField<crate::well_known_types::SourceContext>,
    ///  The source syntax.
    pub syntax: crate::ProtobufEnumOrUnknown<Syntax>,
    // special fields
    #[cfg_attr(serde, serde(skip))]
    pub unknown_fields: crate::UnknownFields,
    #[cfg_attr(serde, serde(skip))]
    pub cached_size: crate::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Type {
    fn default() -> &'a Type {
        <Type as crate::Message>::default_instance()
    }
}

impl Type {
    pub fn new() -> Type {
        ::std::default::Default::default()
    }
}

impl crate::Message for Type {
    fn is_initialized(&self) -> bool {
        for v in &self.fields {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source_context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    crate::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    crate::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.fields)?;
                },
                3 => {
                    crate::rt::read_repeated_string_into(wire_type, is, &mut self.oneofs)?;
                },
                4 => {
                    crate::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.options)?;
                },
                5 => {
                    crate::rt::read_singular_message_into::<crate::well_known_types::SourceContext, _>(wire_type, is, &mut self.source_context)?;
                },
                6 => {
                    if wire_type != crate::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(crate::rt::unexpected_wire_type(wire_type));
                    }
                    self.syntax = is.read_enum_or_unknown()?;
                },
                _ => {
                    crate::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += crate::rt::string_size(1, &self.name);
        }
        for value in &self.fields {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.oneofs {
            my_size += crate::rt::string_size(3, &value);
        };
        for value in &self.options {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.source_context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint32_size(len) + len;
        }
        if self.syntax != crate::ProtobufEnumOrUnknown::new(Syntax::SYNTAX_PROTO2) {
            my_size += crate::rt::enum_or_unknown_size(6, self.syntax);
        }
        my_size += crate::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.fields {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.oneofs {
            os.write_string(3, &v)?;
        };
        for v in &self.options {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.source_context.as_ref() {
            crate::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if self.syntax != crate::ProtobufEnumOrUnknown::new(Syntax::SYNTAX_PROTO2) {
            os.write_enum(6, crate::ProtobufEnumOrUnknown::value(&self.syntax))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &crate::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut crate::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static crate::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Type {
        Type::new()
    }

    fn descriptor_static() -> &'static crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(crate::reflect::rt::make_simple_field_accessor::<_, crate::reflect::types::ProtobufTypeString>(
                "name",
                |m: &Type| { &m.name },
                |m: &mut Type| { &mut m.name },
            ));
            fields.push(crate::reflect::rt::make_repeated_field_accessor::<_, crate::reflect::types::ProtobufTypeMessage<Field>>(
                "fields",
                |m: &Type| { &m.fields },
                |m: &mut Type| { &mut m.fields },
            ));
            fields.push(crate::reflect::rt::make_repeated_field_accessor::<_, crate::reflect::types::ProtobufTypeString>(
                "oneofs",
                |m: &Type| { &m.oneofs },
                |m: &mut Type| { &mut m.oneofs },
            ));
            fields.push(crate::reflect::rt::make_repeated_field_accessor::<_, crate::reflect::types::ProtobufTypeMessage<Option>>(
                "options",
                |m: &Type| { &m.options },
                |m: &mut Type| { &mut m.options },
            ));
            fields.push(crate::reflect::rt::make_option_accessor::<_, crate::reflect::types::ProtobufTypeMessage<crate::well_known_types::SourceContext>, _>(
                "source_context",
                |m: &Type| { &m.source_context },
                |m: &mut Type| { &mut m.source_context },
            ));
            fields.push(crate::reflect::rt::make_simple_field_accessor::<_, crate::reflect::types::ProtobufTypeEnumOrUnknown<Syntax>>(
                "syntax",
                |m: &Type| { &m.syntax },
                |m: &mut Type| { &mut m.syntax },
            ));
            crate::reflect::MessageDescriptor::new::<Type>(
                "Type",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Type {
        static instance: crate::rt::Lazy<Type> = crate::rt::Lazy::INIT;
        instance.get(Type::new)
    }
}

impl crate::Clear for Type {
    fn clear(&mut self) {
        self.name.clear();
        self.fields.clear();
        self.oneofs.clear();
        self.options.clear();
        self.source_context.clear();
        self.syntax = crate::ProtobufEnumOrUnknown::new(Syntax::SYNTAX_PROTO2);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Type {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for Type {
}

///  A single field of a message type.
#[derive(PartialEq,Clone,Default)]
#[cfg_attr(serde, derive(Serialize, Deserialize))]
pub struct Field {
    // message fields
    ///  The field type.
    pub kind: crate::ProtobufEnumOrUnknown<field::Kind>,
    ///  The field cardinality.
    pub cardinality: crate::ProtobufEnumOrUnknown<field::Cardinality>,
    ///  The field number.
    pub number: i32,
    ///  The field name.
    pub name: ::std::string::String,
    ///  The field type URL, without the scheme, for message or enumeration
    ///  types. Example: `"type.googleapis.com/google.protobuf.Timestamp"`.
    pub type_url: ::std::string::String,
    ///  The index of the field type in `Type.oneofs`, for message or enumeration
    ///  types. The first type has index 1; zero means the type is not in the list.
    pub oneof_index: i32,
    ///  Whether to use alternative packed wire representation.
    pub packed: bool,
    ///  The protocol buffer options.
    pub options: crate::RepeatedField<Option>,
    ///  The field JSON name.
    pub json_name: ::std::string::String,
    ///  The string value of the default value of this field. Proto2 syntax only.
    pub default_value: ::std::string::String,
    // special fields
    #[cfg_attr(serde, serde(skip))]
    pub unknown_fields: crate::UnknownFields,
    #[cfg_attr(serde, serde(skip))]
    pub cached_size: crate::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Field {
    fn default() -> &'a Field {
        <Field as crate::Message>::default_instance()
    }
}

impl Field {
    pub fn new() -> Field {
        ::std::default::Default::default()
    }
}

impl crate::Message for Field {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != crate::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(crate::rt::unexpected_wire_type(wire_type));
                    }
                    self.kind = is.read_enum_or_unknown()?;
                },
                2 => {
                    if wire_type != crate::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(crate::rt::unexpected_wire_type(wire_type));
                    }
                    self.cardinality = is.read_enum_or_unknown()?;
                },
                3 => {
                    if wire_type != crate::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(crate::rt::unexpected_wire_type(wire_type));
                    }
                    self.number = is.read_int32()?;
                },
                4 => {
                    crate::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                6 => {
                    crate::rt::read_singular_proto3_string_into(wire_type, is, &mut self.type_url)?;
                },
                7 => {
                    if wire_type != crate::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(crate::rt::unexpected_wire_type(wire_type));
                    }
                    self.oneof_index = is.read_int32()?;
                },
                8 => {
                    if wire_type != crate::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(crate::rt::unexpected_wire_type(wire_type));
                    }
                    self.packed = is.read_bool()?;
                },
                9 => {
                    crate::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.options)?;
                },
                10 => {
                    crate::rt::read_singular_proto3_string_into(wire_type, is, &mut self.json_name)?;
                },
                11 => {
                    crate::rt::read_singular_proto3_string_into(wire_type, is, &mut self.default_value)?;
                },
                _ => {
                    crate::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.kind != crate::ProtobufEnumOrUnknown::new(field::Kind::TYPE_UNKNOWN) {
            my_size += crate::rt::enum_or_unknown_size(1, self.kind);
        }
        if self.cardinality != crate::ProtobufEnumOrUnknown::new(field::Cardinality::CARDINALITY_UNKNOWN) {
            my_size += crate::rt::enum_or_unknown_size(2, self.cardinality);
        }
        if self.number != 0 {
            my_size += crate::rt::value_size(3, self.number, crate::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += crate::rt::string_size(4, &self.name);
        }
        if !self.type_url.is_empty() {
            my_size += crate::rt::string_size(6, &self.type_url);
        }
        if self.oneof_index != 0 {
            my_size += crate::rt::value_size(7, self.oneof_index, crate::wire_format::WireTypeVarint);
        }
        if self.packed != false {
            my_size += 2;
        }
        for value in &self.options {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.json_name.is_empty() {
            my_size += crate::rt::string_size(10, &self.json_name);
        }
        if !self.default_value.is_empty() {
            my_size += crate::rt::string_size(11, &self.default_value);
        }
        my_size += crate::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::ProtobufResult<()> {
        if self.kind != crate::ProtobufEnumOrUnknown::new(field::Kind::TYPE_UNKNOWN) {
            os.write_enum(1, crate::ProtobufEnumOrUnknown::value(&self.kind))?;
        }
        if self.cardinality != crate::ProtobufEnumOrUnknown::new(field::Cardinality::CARDINALITY_UNKNOWN) {
            os.write_enum(2, crate::ProtobufEnumOrUnknown::value(&self.cardinality))?;
        }
        if self.number != 0 {
            os.write_int32(3, self.number)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        if !self.type_url.is_empty() {
            os.write_string(6, &self.type_url)?;
        }
        if self.oneof_index != 0 {
            os.write_int32(7, self.oneof_index)?;
        }
        if self.packed != false {
            os.write_bool(8, self.packed)?;
        }
        for v in &self.options {
            crate::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if !self.json_name.is_empty() {
            os.write_string(10, &self.json_name)?;
        }
        if !self.default_value.is_empty() {
            os.write_string(11, &self.default_value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &crate::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut crate::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static crate::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Field {
        Field::new()
    }

    fn descriptor_static() -> &'static crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(crate::reflect::rt::make_simple_field_accessor::<_, crate::reflect::types::ProtobufTypeEnumOrUnknown<field::Kind>>(
                "kind",
                |m: &Field| { &m.kind },
                |m: &mut Field| { &mut m.kind },
            ));
            fields.push(crate::reflect::rt::make_simple_field_accessor::<_, crate::reflect::types::ProtobufTypeEnumOrUnknown<field::Cardinality>>(
                "cardinality",
                |m: &Field| { &m.cardinality },
                |m: &mut Field| { &mut m.cardinality },
            ));
            fields.push(crate::reflect::rt::make_simple_field_accessor::<_, crate::reflect::types::ProtobufTypeInt32>(
                "number",
                |m: &Field| { &m.number },
                |m: &mut Field| { &mut m.number },
            ));
            fields.push(crate::reflect::rt::make_simple_field_accessor::<_, crate::reflect::types::ProtobufTypeString>(
                "name",
                |m: &Field| { &m.name },
                |m: &mut Field| { &mut m.name },
            ));
            fields.push(crate::reflect::rt::make_simple_field_accessor::<_, crate::reflect::types::ProtobufTypeString>(
                "type_url",
                |m: &Field| { &m.type_url },
                |m: &mut Field| { &mut m.type_url },
            ));
            fields.push(crate::reflect::rt::make_simple_field_accessor::<_, crate::reflect::types::ProtobufTypeInt32>(
                "oneof_index",
                |m: &Field| { &m.oneof_index },
                |m: &mut Field| { &mut m.oneof_index },
            ));
            fields.push(crate::reflect::rt::make_simple_field_accessor::<_, crate::reflect::types::ProtobufTypeBool>(
                "packed",
                |m: &Field| { &m.packed },
                |m: &mut Field| { &mut m.packed },
            ));
            fields.push(crate::reflect::rt::make_repeated_field_accessor::<_, crate::reflect::types::ProtobufTypeMessage<Option>>(
                "options",
                |m: &Field| { &m.options },
                |m: &mut Field| { &mut m.options },
            ));
            fields.push(crate::reflect::rt::make_simple_field_accessor::<_, crate::reflect::types::ProtobufTypeString>(
                "json_name",
                |m: &Field| { &m.json_name },
                |m: &mut Field| { &mut m.json_name },
            ));
            fields.push(crate::reflect::rt::make_simple_field_accessor::<_, crate::reflect::types::ProtobufTypeString>(
                "default_value",
                |m: &Field| { &m.default_value },
                |m: &mut Field| { &mut m.default_value },
            ));
            crate::reflect::MessageDescriptor::new::<Field>(
                "Field",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Field {
        static instance: crate::rt::Lazy<Field> = crate::rt::Lazy::INIT;
        instance.get(Field::new)
    }
}

impl crate::Clear for Field {
    fn clear(&mut self) {
        self.kind = crate::ProtobufEnumOrUnknown::new(field::Kind::TYPE_UNKNOWN);
        self.cardinality = crate::ProtobufEnumOrUnknown::new(field::Cardinality::CARDINALITY_UNKNOWN);
        self.number = 0;
        self.name.clear();
        self.type_url.clear();
        self.oneof_index = 0;
        self.packed = false;
        self.options.clear();
        self.json_name.clear();
        self.default_value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Field {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for Field {
}

/// Nested message and enums of message `Field`
pub mod field {
    ///  Basic field types.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    #[cfg_attr(serde, derive(Serialize, Deserialize))]
    pub enum Kind {
        TYPE_UNKNOWN = 0,
        TYPE_DOUBLE = 1,
        TYPE_FLOAT = 2,
        TYPE_INT64 = 3,
        TYPE_UINT64 = 4,
        TYPE_INT32 = 5,
        TYPE_FIXED64 = 6,
        TYPE_FIXED32 = 7,
        TYPE_BOOL = 8,
        TYPE_STRING = 9,
        TYPE_GROUP = 10,
        TYPE_MESSAGE = 11,
        TYPE_BYTES = 12,
        TYPE_UINT32 = 13,
        TYPE_ENUM = 14,
        TYPE_SFIXED32 = 15,
        TYPE_SFIXED64 = 16,
        TYPE_SINT32 = 17,
        TYPE_SINT64 = 18,
    }

    impl crate::ProtobufEnum for Kind {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Kind> {
            match value {
                0 => ::std::option::Option::Some(Kind::TYPE_UNKNOWN),
                1 => ::std::option::Option::Some(Kind::TYPE_DOUBLE),
                2 => ::std::option::Option::Some(Kind::TYPE_FLOAT),
                3 => ::std::option::Option::Some(Kind::TYPE_INT64),
                4 => ::std::option::Option::Some(Kind::TYPE_UINT64),
                5 => ::std::option::Option::Some(Kind::TYPE_INT32),
                6 => ::std::option::Option::Some(Kind::TYPE_FIXED64),
                7 => ::std::option::Option::Some(Kind::TYPE_FIXED32),
                8 => ::std::option::Option::Some(Kind::TYPE_BOOL),
                9 => ::std::option::Option::Some(Kind::TYPE_STRING),
                10 => ::std::option::Option::Some(Kind::TYPE_GROUP),
                11 => ::std::option::Option::Some(Kind::TYPE_MESSAGE),
                12 => ::std::option::Option::Some(Kind::TYPE_BYTES),
                13 => ::std::option::Option::Some(Kind::TYPE_UINT32),
                14 => ::std::option::Option::Some(Kind::TYPE_ENUM),
                15 => ::std::option::Option::Some(Kind::TYPE_SFIXED32),
                16 => ::std::option::Option::Some(Kind::TYPE_SFIXED64),
                17 => ::std::option::Option::Some(Kind::TYPE_SINT32),
                18 => ::std::option::Option::Some(Kind::TYPE_SINT64),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [Kind] = &[
                Kind::TYPE_UNKNOWN,
                Kind::TYPE_DOUBLE,
                Kind::TYPE_FLOAT,
                Kind::TYPE_INT64,
                Kind::TYPE_UINT64,
                Kind::TYPE_INT32,
                Kind::TYPE_FIXED64,
                Kind::TYPE_FIXED32,
                Kind::TYPE_BOOL,
                Kind::TYPE_STRING,
                Kind::TYPE_GROUP,
                Kind::TYPE_MESSAGE,
                Kind::TYPE_BYTES,
                Kind::TYPE_UINT32,
                Kind::TYPE_ENUM,
                Kind::TYPE_SFIXED32,
                Kind::TYPE_SFIXED64,
                Kind::TYPE_SINT32,
                Kind::TYPE_SINT64,
            ];
            values
        }

        fn enum_descriptor_static() -> &'static crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::INIT;
            descriptor.get(|| {
                crate::reflect::EnumDescriptor::new::<Kind>("Field.Kind", super::file_descriptor_proto())
            })
        }
    }

    impl ::std::default::Default for Kind {
        fn default() -> Self {
            Kind::TYPE_UNKNOWN
        }
    }

    impl crate::reflect::ProtobufValue for Kind {
    }

    ///  Whether a field is optional, required, or repeated.
    #[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
    #[cfg_attr(serde, derive(Serialize, Deserialize))]
    pub enum Cardinality {
        CARDINALITY_UNKNOWN = 0,
        CARDINALITY_OPTIONAL = 1,
        CARDINALITY_REQUIRED = 2,
        CARDINALITY_REPEATED = 3,
    }

    impl crate::ProtobufEnum for Cardinality {
        fn value(&self) -> i32 {
            *self as i32
        }

        fn from_i32(value: i32) -> ::std::option::Option<Cardinality> {
            match value {
                0 => ::std::option::Option::Some(Cardinality::CARDINALITY_UNKNOWN),
                1 => ::std::option::Option::Some(Cardinality::CARDINALITY_OPTIONAL),
                2 => ::std::option::Option::Some(Cardinality::CARDINALITY_REQUIRED),
                3 => ::std::option::Option::Some(Cardinality::CARDINALITY_REPEATED),
                _ => ::std::option::Option::None
            }
        }

        fn values() -> &'static [Self] {
            static values: &'static [Cardinality] = &[
                Cardinality::CARDINALITY_UNKNOWN,
                Cardinality::CARDINALITY_OPTIONAL,
                Cardinality::CARDINALITY_REQUIRED,
                Cardinality::CARDINALITY_REPEATED,
            ];
            values
        }

        fn enum_descriptor_static() -> &'static crate::reflect::EnumDescriptor {
            static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::INIT;
            descriptor.get(|| {
                crate::reflect::EnumDescriptor::new::<Cardinality>("Field.Cardinality", super::file_descriptor_proto())
            })
        }
    }

    impl ::std::default::Default for Cardinality {
        fn default() -> Self {
            Cardinality::CARDINALITY_UNKNOWN
        }
    }

    impl crate::reflect::ProtobufValue for Cardinality {
    }
}

///  Enum type definition.
#[derive(PartialEq,Clone,Default)]
#[cfg_attr(serde, derive(Serialize, Deserialize))]
pub struct Enum {
    // message fields
    ///  Enum type name.
    pub name: ::std::string::String,
    ///  Enum value definitions.
    pub enumvalue: crate::RepeatedField<EnumValue>,
    ///  Protocol buffer options.
    pub options: crate::RepeatedField<Option>,
    ///  The source context.
    pub source_context: crate::SingularPtrField<crate::well_known_types::SourceContext>,
    ///  The source syntax.
    pub syntax: crate::ProtobufEnumOrUnknown<Syntax>,
    // special fields
    #[cfg_attr(serde, serde(skip))]
    pub unknown_fields: crate::UnknownFields,
    #[cfg_attr(serde, serde(skip))]
    pub cached_size: crate::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Enum {
    fn default() -> &'a Enum {
        <Enum as crate::Message>::default_instance()
    }
}

impl Enum {
    pub fn new() -> Enum {
        ::std::default::Default::default()
    }
}

impl crate::Message for Enum {
    fn is_initialized(&self) -> bool {
        for v in &self.enumvalue {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source_context {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    crate::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    crate::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.enumvalue)?;
                },
                3 => {
                    crate::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.options)?;
                },
                4 => {
                    crate::rt::read_singular_message_into::<crate::well_known_types::SourceContext, _>(wire_type, is, &mut self.source_context)?;
                },
                5 => {
                    if wire_type != crate::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(crate::rt::unexpected_wire_type(wire_type));
                    }
                    self.syntax = is.read_enum_or_unknown()?;
                },
                _ => {
                    crate::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += crate::rt::string_size(1, &self.name);
        }
        for value in &self.enumvalue {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.options {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.source_context.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint32_size(len) + len;
        }
        if self.syntax != crate::ProtobufEnumOrUnknown::new(Syntax::SYNTAX_PROTO2) {
            my_size += crate::rt::enum_or_unknown_size(5, self.syntax);
        }
        my_size += crate::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.enumvalue {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.options {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.source_context.as_ref() {
            crate::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if self.syntax != crate::ProtobufEnumOrUnknown::new(Syntax::SYNTAX_PROTO2) {
            os.write_enum(5, crate::ProtobufEnumOrUnknown::value(&self.syntax))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &crate::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut crate::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static crate::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Enum {
        Enum::new()
    }

    fn descriptor_static() -> &'static crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(crate::reflect::rt::make_simple_field_accessor::<_, crate::reflect::types::ProtobufTypeString>(
                "name",
                |m: &Enum| { &m.name },
                |m: &mut Enum| { &mut m.name },
            ));
            fields.push(crate::reflect::rt::make_repeated_field_accessor::<_, crate::reflect::types::ProtobufTypeMessage<EnumValue>>(
                "enumvalue",
                |m: &Enum| { &m.enumvalue },
                |m: &mut Enum| { &mut m.enumvalue },
            ));
            fields.push(crate::reflect::rt::make_repeated_field_accessor::<_, crate::reflect::types::ProtobufTypeMessage<Option>>(
                "options",
                |m: &Enum| { &m.options },
                |m: &mut Enum| { &mut m.options },
            ));
            fields.push(crate::reflect::rt::make_option_accessor::<_, crate::reflect::types::ProtobufTypeMessage<crate::well_known_types::SourceContext>, _>(
                "source_context",
                |m: &Enum| { &m.source_context },
                |m: &mut Enum| { &mut m.source_context },
            ));
            fields.push(crate::reflect::rt::make_simple_field_accessor::<_, crate::reflect::types::ProtobufTypeEnumOrUnknown<Syntax>>(
                "syntax",
                |m: &Enum| { &m.syntax },
                |m: &mut Enum| { &mut m.syntax },
            ));
            crate::reflect::MessageDescriptor::new::<Enum>(
                "Enum",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Enum {
        static instance: crate::rt::Lazy<Enum> = crate::rt::Lazy::INIT;
        instance.get(Enum::new)
    }
}

impl crate::Clear for Enum {
    fn clear(&mut self) {
        self.name.clear();
        self.enumvalue.clear();
        self.options.clear();
        self.source_context.clear();
        self.syntax = crate::ProtobufEnumOrUnknown::new(Syntax::SYNTAX_PROTO2);
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Enum {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for Enum {
}

///  Enum value definition.
#[derive(PartialEq,Clone,Default)]
#[cfg_attr(serde, derive(Serialize, Deserialize))]
pub struct EnumValue {
    // message fields
    ///  Enum value name.
    pub name: ::std::string::String,
    ///  Enum value number.
    pub number: i32,
    ///  Protocol buffer options.
    pub options: crate::RepeatedField<Option>,
    // special fields
    #[cfg_attr(serde, serde(skip))]
    pub unknown_fields: crate::UnknownFields,
    #[cfg_attr(serde, serde(skip))]
    pub cached_size: crate::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnumValue {
    fn default() -> &'a EnumValue {
        <EnumValue as crate::Message>::default_instance()
    }
}

impl EnumValue {
    pub fn new() -> EnumValue {
        ::std::default::Default::default()
    }
}

impl crate::Message for EnumValue {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    crate::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != crate::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(crate::rt::unexpected_wire_type(wire_type));
                    }
                    self.number = is.read_int32()?;
                },
                3 => {
                    crate::rt::read_repeated_message_into_repeated_field(wire_type, is, &mut self.options)?;
                },
                _ => {
                    crate::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += crate::rt::string_size(1, &self.name);
        }
        if self.number != 0 {
            my_size += crate::rt::value_size(2, self.number, crate::wire_format::WireTypeVarint);
        }
        for value in &self.options {
            let len = value.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += crate::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.number != 0 {
            os.write_int32(2, self.number)?;
        }
        for v in &self.options {
            crate::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &crate::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut crate::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static crate::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnumValue {
        EnumValue::new()
    }

    fn descriptor_static() -> &'static crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(crate::reflect::rt::make_simple_field_accessor::<_, crate::reflect::types::ProtobufTypeString>(
                "name",
                |m: &EnumValue| { &m.name },
                |m: &mut EnumValue| { &mut m.name },
            ));
            fields.push(crate::reflect::rt::make_simple_field_accessor::<_, crate::reflect::types::ProtobufTypeInt32>(
                "number",
                |m: &EnumValue| { &m.number },
                |m: &mut EnumValue| { &mut m.number },
            ));
            fields.push(crate::reflect::rt::make_repeated_field_accessor::<_, crate::reflect::types::ProtobufTypeMessage<Option>>(
                "options",
                |m: &EnumValue| { &m.options },
                |m: &mut EnumValue| { &mut m.options },
            ));
            crate::reflect::MessageDescriptor::new::<EnumValue>(
                "EnumValue",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EnumValue {
        static instance: crate::rt::Lazy<EnumValue> = crate::rt::Lazy::INIT;
        instance.get(EnumValue::new)
    }
}

impl crate::Clear for EnumValue {
    fn clear(&mut self) {
        self.name.clear();
        self.number = 0;
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnumValue {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for EnumValue {
}

///  A protocol buffer option, which can be attached to a message, field,
///  enumeration, etc.
#[derive(PartialEq,Clone,Default)]
#[cfg_attr(serde, derive(Serialize, Deserialize))]
pub struct Option {
    // message fields
    ///  The option's name. For example, `"java_package"`.
    pub name: ::std::string::String,
    ///  The option's value. For example, `"com.google.protobuf"`.
    pub value: crate::SingularPtrField<crate::well_known_types::Any>,
    // special fields
    #[cfg_attr(serde, serde(skip))]
    pub unknown_fields: crate::UnknownFields,
    #[cfg_attr(serde, serde(skip))]
    pub cached_size: crate::rt::CachedSize,
}

impl<'a> ::std::default::Default for &'a Option {
    fn default() -> &'a Option {
        <Option as crate::Message>::default_instance()
    }
}

impl Option {
    pub fn new() -> Option {
        ::std::default::Default::default()
    }
}

impl crate::Message for Option {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut crate::CodedInputStream<'_>) -> crate::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    crate::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    crate::rt::read_singular_message_into::<crate::well_known_types::Any, _>(wire_type, is, &mut self.value)?;
                },
                _ => {
                    crate::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += crate::rt::string_size(1, &self.name);
        }
        if let Some(v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + crate::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += crate::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut crate::CodedOutputStream<'_>) -> crate::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(v) = self.value.as_ref() {
            crate::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &crate::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut crate::UnknownFields {
        &mut self.unknown_fields
    }

    fn descriptor(&self) -> &'static crate::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Option {
        Option::new()
    }

    fn descriptor_static() -> &'static crate::reflect::MessageDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::MessageDescriptor> = crate::rt::Lazy::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(crate::reflect::rt::make_simple_field_accessor::<_, crate::reflect::types::ProtobufTypeString>(
                "name",
                |m: &Option| { &m.name },
                |m: &mut Option| { &mut m.name },
            ));
            fields.push(crate::reflect::rt::make_option_accessor::<_, crate::reflect::types::ProtobufTypeMessage<crate::well_known_types::Any>, _>(
                "value",
                |m: &Option| { &m.value },
                |m: &mut Option| { &mut m.value },
            ));
            crate::reflect::MessageDescriptor::new::<Option>(
                "Option",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Option {
        static instance: crate::rt::Lazy<Option> = crate::rt::Lazy::INIT;
        instance.get(Option::new)
    }
}

impl crate::Clear for Option {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Option {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        crate::text_format::fmt(self, f)
    }
}

impl crate::reflect::ProtobufValue for Option {
}

///  The syntax in which a protocol buffer element is defined.
#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(serde, derive(Serialize, Deserialize))]
pub enum Syntax {
    SYNTAX_PROTO2 = 0,
    SYNTAX_PROTO3 = 1,
}

impl crate::ProtobufEnum for Syntax {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Syntax> {
        match value {
            0 => ::std::option::Option::Some(Syntax::SYNTAX_PROTO2),
            1 => ::std::option::Option::Some(Syntax::SYNTAX_PROTO3),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Syntax] = &[
            Syntax::SYNTAX_PROTO2,
            Syntax::SYNTAX_PROTO3,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static crate::reflect::EnumDescriptor {
        static descriptor: crate::rt::Lazy<crate::reflect::EnumDescriptor> = crate::rt::Lazy::INIT;
        descriptor.get(|| {
            crate::reflect::EnumDescriptor::new::<Syntax>("Syntax", file_descriptor_proto())
        })
    }
}

impl ::std::default::Default for Syntax {
    fn default() -> Self {
        Syntax::SYNTAX_PROTO2
    }
}

impl crate::reflect::ProtobufValue for Syntax {
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x1agoogle/protobuf/type.proto\x12\x0fgoogle.protobuf\x1a\x19google/pr\
    otobuf/any.proto\x1a$google/protobuf/source_context.proto\"\x8d\x02\n\
    \x04Type\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12.\n\x06fields\
    \x18\x02\x20\x03(\x0b2\x16.google.protobuf.FieldR\x06fields\x12\x16\n\
    \x06oneofs\x18\x03\x20\x03(\tR\x06oneofs\x121\n\x07options\x18\x04\x20\
    \x03(\x0b2\x17.google.protobuf.OptionR\x07options\x12E\n\x0esource_conte\
    xt\x18\x05\x20\x01(\x0b2\x1e.google.protobuf.SourceContextR\rsourceConte\
    xt\x12/\n\x06syntax\x18\x06\x20\x01(\x0e2\x17.google.protobuf.SyntaxR\
    \x06syntax\"\xb4\x06\n\x05Field\x12/\n\x04kind\x18\x01\x20\x01(\x0e2\x1b\
    .google.protobuf.Field.KindR\x04kind\x12D\n\x0bcardinality\x18\x02\x20\
    \x01(\x0e2\".google.protobuf.Field.CardinalityR\x0bcardinality\x12\x16\n\
    \x06number\x18\x03\x20\x01(\x05R\x06number\x12\x12\n\x04name\x18\x04\x20\
    \x01(\tR\x04name\x12\x19\n\x08type_url\x18\x06\x20\x01(\tR\x07typeUrl\
    \x12\x1f\n\x0boneof_index\x18\x07\x20\x01(\x05R\noneofIndex\x12\x16\n\
    \x06packed\x18\x08\x20\x01(\x08R\x06packed\x121\n\x07options\x18\t\x20\
    \x03(\x0b2\x17.google.protobuf.OptionR\x07options\x12\x1b\n\tjson_name\
    \x18\n\x20\x01(\tR\x08jsonName\x12#\n\rdefault_value\x18\x0b\x20\x01(\tR\
    \x0cdefaultValue\"\xc8\x02\n\x04Kind\x12\x10\n\x0cTYPE_UNKNOWN\x10\0\x12\
    \x0f\n\x0bTYPE_DOUBLE\x10\x01\x12\x0e\n\nTYPE_FLOAT\x10\x02\x12\x0e\n\nT\
    YPE_INT64\x10\x03\x12\x0f\n\x0bTYPE_UINT64\x10\x04\x12\x0e\n\nTYPE_INT32\
    \x10\x05\x12\x10\n\x0cTYPE_FIXED64\x10\x06\x12\x10\n\x0cTYPE_FIXED32\x10\
    \x07\x12\r\n\tTYPE_BOOL\x10\x08\x12\x0f\n\x0bTYPE_STRING\x10\t\x12\x0e\n\
    \nTYPE_GROUP\x10\n\x12\x10\n\x0cTYPE_MESSAGE\x10\x0b\x12\x0e\n\nTYPE_BYT\
    ES\x10\x0c\x12\x0f\n\x0bTYPE_UINT32\x10\r\x12\r\n\tTYPE_ENUM\x10\x0e\x12\
    \x11\n\rTYPE_SFIXED32\x10\x0f\x12\x11\n\rTYPE_SFIXED64\x10\x10\x12\x0f\n\
    \x0bTYPE_SINT32\x10\x11\x12\x0f\n\x0bTYPE_SINT64\x10\x12\"t\n\x0bCardina\
    lity\x12\x17\n\x13CARDINALITY_UNKNOWN\x10\0\x12\x18\n\x14CARDINALITY_OPT\
    IONAL\x10\x01\x12\x18\n\x14CARDINALITY_REQUIRED\x10\x02\x12\x18\n\x14CAR\
    DINALITY_REPEATED\x10\x03\"\xff\x01\n\x04Enum\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x128\n\tenumvalue\x18\x02\x20\x03(\x0b2\x1a.google.\
    protobuf.EnumValueR\tenumvalue\x121\n\x07options\x18\x03\x20\x03(\x0b2\
    \x17.google.protobuf.OptionR\x07options\x12E\n\x0esource_context\x18\x04\
    \x20\x01(\x0b2\x1e.google.protobuf.SourceContextR\rsourceContext\x12/\n\
    \x06syntax\x18\x05\x20\x01(\x0e2\x17.google.protobuf.SyntaxR\x06syntax\"\
    j\n\tEnumValue\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x16\n\
    \x06number\x18\x02\x20\x01(\x05R\x06number\x121\n\x07options\x18\x03\x20\
    \x03(\x0b2\x17.google.protobuf.OptionR\x07options\"H\n\x06Option\x12\x12\
    \n\x04name\x18\x01\x20\x01(\tR\x04name\x12*\n\x05value\x18\x02\x20\x01(\
    \x0b2\x14.google.protobuf.AnyR\x05value*.\n\x06Syntax\x12\x11\n\rSYNTAX_\
    PROTO2\x10\0\x12\x11\n\rSYNTAX_PROTO3\x10\x01BL\n\x13com.google.protobuf\
    B\tTypeProtoP\x01\xf8\x01\x01\xa2\x02\x03GPB\xaa\x02\x1eGoogle.Protobuf.\
    WellKnownTypesJ\x9a5\n\x07\x12\x05\x1e\0\xb3\x01\x01\n\xcc\x0c\n\x01\x0c\
    \x12\x03\x1e\0\x122\xc1\x0c\x20Protocol\x20Buffers\x20-\x20Google's\x20d\
    ata\x20interchange\x20format\n\x20Copyright\x202008\x20Google\x20Inc.\
    \x20\x20All\x20rights\x20reserved.\n\x20https://developers.google.com/pr\
    otocol-buffers/\n\n\x20Redistribution\x20and\x20use\x20in\x20source\x20a\
    nd\x20binary\x20forms,\x20with\x20or\x20without\n\x20modification,\x20ar\
    e\x20permitted\x20provided\x20that\x20the\x20following\x20conditions\x20\
    are\n\x20met:\n\n\x20\x20\x20\x20\x20*\x20Redistributions\x20of\x20sourc\
    e\x20code\x20must\x20retain\x20the\x20above\x20copyright\n\x20notice,\
    \x20this\x20list\x20of\x20conditions\x20and\x20the\x20following\x20discl\
    aimer.\n\x20\x20\x20\x20\x20*\x20Redistributions\x20in\x20binary\x20form\
    \x20must\x20reproduce\x20the\x20above\n\x20copyright\x20notice,\x20this\
    \x20list\x20of\x20conditions\x20and\x20the\x20following\x20disclaimer\n\
    \x20in\x20the\x20documentation\x20and/or\x20other\x20materials\x20provid\
    ed\x20with\x20the\n\x20distribution.\n\x20\x20\x20\x20\x20*\x20Neither\
    \x20the\x20name\x20of\x20Google\x20Inc.\x20nor\x20the\x20names\x20of\x20\
    its\n\x20contributors\x20may\x20be\x20used\x20to\x20endorse\x20or\x20pro\
    mote\x20products\x20derived\x20from\n\x20this\x20software\x20without\x20\
    specific\x20prior\x20written\x20permission.\n\n\x20THIS\x20SOFTWARE\x20I\
    S\x20PROVIDED\x20BY\x20THE\x20COPYRIGHT\x20HOLDERS\x20AND\x20CONTRIBUTOR\
    S\n\x20\"AS\x20IS\"\x20AND\x20ANY\x20EXPRESS\x20OR\x20IMPLIED\x20WARRANT\
    IES,\x20INCLUDING,\x20BUT\x20NOT\n\x20LIMITED\x20TO,\x20THE\x20IMPLIED\
    \x20WARRANTIES\x20OF\x20MERCHANTABILITY\x20AND\x20FITNESS\x20FOR\n\x20A\
    \x20PARTICULAR\x20PURPOSE\x20ARE\x20DISCLAIMED.\x20IN\x20NO\x20EVENT\x20\
    SHALL\x20THE\x20COPYRIGHT\n\x20OWNER\x20OR\x20CONTRIBUTORS\x20BE\x20LIAB\
    LE\x20FOR\x20ANY\x20DIRECT,\x20INDIRECT,\x20INCIDENTAL,\n\x20SPECIAL,\
    \x20EXEMPLARY,\x20OR\x20CONSEQUENTIAL\x20DAMAGES\x20(INCLUDING,\x20BUT\
    \x20NOT\n\x20LIMITED\x20TO,\x20PROCUREMENT\x20OF\x20SUBSTITUTE\x20GOODS\
    \x20OR\x20SERVICES;\x20LOSS\x20OF\x20USE,\n\x20DATA,\x20OR\x20PROFITS;\
    \x20OR\x20BUSINESS\x20INTERRUPTION)\x20HOWEVER\x20CAUSED\x20AND\x20ON\
    \x20ANY\n\x20THEORY\x20OF\x20LIABILITY,\x20WHETHER\x20IN\x20CONTRACT,\
    \x20STRICT\x20LIABILITY,\x20OR\x20TORT\n\x20(INCLUDING\x20NEGLIGENCE\x20\
    OR\x20OTHERWISE)\x20ARISING\x20IN\x20ANY\x20WAY\x20OUT\x20OF\x20THE\x20U\
    SE\n\x20OF\x20THIS\x20SOFTWARE,\x20EVEN\x20IF\x20ADVISED\x20OF\x20THE\
    \x20POSSIBILITY\x20OF\x20SUCH\x20DAMAGE.\n\n\x08\n\x01\x02\x12\x03\x20\0\
    \x18\n\t\n\x02\x03\0\x12\x03\"\0#\n\t\n\x02\x03\x01\x12\x03#\0.\n\x08\n\
    \x01\x08\x12\x03%\0;\n\t\n\x02\x08%\x12\x03%\0;\n\x08\n\x01\x08\x12\x03&\
    \0\x1f\n\t\n\x02\x08\x1f\x12\x03&\0\x1f\n\x08\n\x01\x08\x12\x03'\0,\n\t\
    \n\x02\x08\x01\x12\x03'\0,\n\x08\n\x01\x08\x12\x03(\0*\n\t\n\x02\x08\x08\
    \x12\x03(\0*\n\x08\n\x01\x08\x12\x03)\0\"\n\t\n\x02\x08\n\x12\x03)\0\"\n\
    \x08\n\x01\x08\x12\x03*\0!\n\t\n\x02\x08$\x12\x03*\0!\n-\n\x02\x04\0\x12\
    \x04-\0:\x01\x1a!\x20A\x20protocol\x20buffer\x20message\x20type.\n\n\n\n\
    \x03\x04\0\x01\x12\x03-\x08\x0c\n0\n\x04\x04\0\x02\0\x12\x03/\x02\x12\
    \x1a#\x20The\x20fully\x20qualified\x20message\x20name.\n\n\x0c\n\x05\x04\
    \0\x02\0\x05\x12\x03/\x02\x08\n\x0c\n\x05\x04\0\x02\0\x01\x12\x03/\t\r\n\
    \x0c\n\x05\x04\0\x02\0\x03\x12\x03/\x10\x11\n\"\n\x04\x04\0\x02\x01\x12\
    \x031\x02\x1c\x1a\x15\x20The\x20list\x20of\x20fields.\n\n\x0c\n\x05\x04\
    \0\x02\x01\x04\x12\x031\x02\n\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x031\x0b\
    \x10\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x031\x11\x17\n\x0c\n\x05\x04\0\
    \x02\x01\x03\x12\x031\x1a\x1b\nO\n\x04\x04\0\x02\x02\x12\x033\x02\x1d\
    \x1aB\x20The\x20list\x20of\x20types\x20appearing\x20in\x20`oneof`\x20def\
    initions\x20in\x20this\x20type.\n\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x033\
    \x02\n\n\x0c\n\x05\x04\0\x02\x02\x05\x12\x033\x0b\x11\n\x0c\n\x05\x04\0\
    \x02\x02\x01\x12\x033\x12\x18\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x033\x1b\
    \x1c\n+\n\x04\x04\0\x02\x03\x12\x035\x02\x1e\x1a\x1e\x20The\x20protocol\
    \x20buffer\x20options.\n\n\x0c\n\x05\x04\0\x02\x03\x04\x12\x035\x02\n\n\
    \x0c\n\x05\x04\0\x02\x03\x06\x12\x035\x0b\x11\n\x0c\n\x05\x04\0\x02\x03\
    \x01\x12\x035\x12\x19\n\x0c\n\x05\x04\0\x02\x03\x03\x12\x035\x1c\x1d\n\"\
    \n\x04\x04\0\x02\x04\x12\x037\x02#\x1a\x15\x20The\x20source\x20context.\
    \n\n\x0c\n\x05\x04\0\x02\x04\x06\x12\x037\x02\x0f\n\x0c\n\x05\x04\0\x02\
    \x04\x01\x12\x037\x10\x1e\n\x0c\n\x05\x04\0\x02\x04\x03\x12\x037!\"\n!\n\
    \x04\x04\0\x02\x05\x12\x039\x02\x14\x1a\x14\x20The\x20source\x20syntax.\
    \n\n\x0c\n\x05\x04\0\x02\x05\x06\x12\x039\x02\x08\n\x0c\n\x05\x04\0\x02\
    \x05\x01\x12\x039\t\x0f\n\x0c\n\x05\x04\0\x02\x05\x03\x12\x039\x12\x13\n\
    0\n\x02\x04\x01\x12\x05=\0\x8a\x01\x01\x1a#\x20A\x20single\x20field\x20o\
    f\x20a\x20message\x20type.\n\n\n\n\x03\x04\x01\x01\x12\x03=\x08\r\n\"\n\
    \x04\x04\x01\x04\0\x12\x04?\x02f\x03\x1a\x14\x20Basic\x20field\x20types.\
    \n\n\x0c\n\x05\x04\x01\x04\0\x01\x12\x03?\x07\x0b\n$\n\x06\x04\x01\x04\0\
    \x02\0\x12\x03A\x04\x1c\x1a\x15\x20Field\x20type\x20unknown.\n\n\x0e\n\
    \x07\x04\x01\x04\0\x02\0\x01\x12\x03A\x04\x10\n\x0e\n\x07\x04\x01\x04\0\
    \x02\0\x02\x12\x03A\x1a\x1b\n#\n\x06\x04\x01\x04\0\x02\x01\x12\x03C\x04\
    \x1c\x1a\x14\x20Field\x20type\x20double.\n\n\x0e\n\x07\x04\x01\x04\0\x02\
    \x01\x01\x12\x03C\x04\x0f\n\x0e\n\x07\x04\x01\x04\0\x02\x01\x02\x12\x03C\
    \x1a\x1b\n\"\n\x06\x04\x01\x04\0\x02\x02\x12\x03E\x04\x1c\x1a\x13\x20Fie\
    ld\x20type\x20float.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x02\x01\x12\x03E\
    \x04\x0e\n\x0e\n\x07\x04\x01\x04\0\x02\x02\x02\x12\x03E\x1a\x1b\n\"\n\
    \x06\x04\x01\x04\0\x02\x03\x12\x03G\x04\x1c\x1a\x13\x20Field\x20type\x20\
    int64.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x03\x01\x12\x03G\x04\x0e\n\x0e\n\
    \x07\x04\x01\x04\0\x02\x03\x02\x12\x03G\x1a\x1b\n#\n\x06\x04\x01\x04\0\
    \x02\x04\x12\x03I\x04\x1c\x1a\x14\x20Field\x20type\x20uint64.\n\n\x0e\n\
    \x07\x04\x01\x04\0\x02\x04\x01\x12\x03I\x04\x0f\n\x0e\n\x07\x04\x01\x04\
    \0\x02\x04\x02\x12\x03I\x1a\x1b\n\"\n\x06\x04\x01\x04\0\x02\x05\x12\x03K\
    \x04\x1c\x1a\x13\x20Field\x20type\x20int32.\n\n\x0e\n\x07\x04\x01\x04\0\
    \x02\x05\x01\x12\x03K\x04\x0e\n\x0e\n\x07\x04\x01\x04\0\x02\x05\x02\x12\
    \x03K\x1a\x1b\n$\n\x06\x04\x01\x04\0\x02\x06\x12\x03M\x04\x1c\x1a\x15\
    \x20Field\x20type\x20fixed64.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x06\x01\
    \x12\x03M\x04\x10\n\x0e\n\x07\x04\x01\x04\0\x02\x06\x02\x12\x03M\x1a\x1b\
    \n$\n\x06\x04\x01\x04\0\x02\x07\x12\x03O\x04\x1c\x1a\x15\x20Field\x20typ\
    e\x20fixed32.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x07\x01\x12\x03O\x04\x10\n\
    \x0e\n\x07\x04\x01\x04\0\x02\x07\x02\x12\x03O\x1a\x1b\n!\n\x06\x04\x01\
    \x04\0\x02\x08\x12\x03Q\x04\x1c\x1a\x12\x20Field\x20type\x20bool.\n\n\
    \x0e\n\x07\x04\x01\x04\0\x02\x08\x01\x12\x03Q\x04\r\n\x0e\n\x07\x04\x01\
    \x04\0\x02\x08\x02\x12\x03Q\x1a\x1b\n#\n\x06\x04\x01\x04\0\x02\t\x12\x03\
    S\x04\x1c\x1a\x14\x20Field\x20type\x20string.\n\n\x0e\n\x07\x04\x01\x04\
    \0\x02\t\x01\x12\x03S\x04\x0f\n\x0e\n\x07\x04\x01\x04\0\x02\t\x02\x12\
    \x03S\x1a\x1b\nF\n\x06\x04\x01\x04\0\x02\n\x12\x03U\x04\x1d\x1a7\x20Fiel\
    d\x20type\x20group.\x20Proto2\x20syntax\x20only,\x20and\x20deprecated.\n\
    \n\x0e\n\x07\x04\x01\x04\0\x02\n\x01\x12\x03U\x04\x0e\n\x0e\n\x07\x04\
    \x01\x04\0\x02\n\x02\x12\x03U\x1a\x1c\n$\n\x06\x04\x01\x04\0\x02\x0b\x12\
    \x03W\x04\x1d\x1a\x15\x20Field\x20type\x20message.\n\n\x0e\n\x07\x04\x01\
    \x04\0\x02\x0b\x01\x12\x03W\x04\x10\n\x0e\n\x07\x04\x01\x04\0\x02\x0b\
    \x02\x12\x03W\x1a\x1c\n\"\n\x06\x04\x01\x04\0\x02\x0c\x12\x03Y\x04\x1d\
    \x1a\x13\x20Field\x20type\x20bytes.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x0c\
    \x01\x12\x03Y\x04\x0e\n\x0e\n\x07\x04\x01\x04\0\x02\x0c\x02\x12\x03Y\x1a\
    \x1c\n#\n\x06\x04\x01\x04\0\x02\r\x12\x03[\x04\x1d\x1a\x14\x20Field\x20t\
    ype\x20uint32.\n\n\x0e\n\x07\x04\x01\x04\0\x02\r\x01\x12\x03[\x04\x0f\n\
    \x0e\n\x07\x04\x01\x04\0\x02\r\x02\x12\x03[\x1a\x1c\n!\n\x06\x04\x01\x04\
    \0\x02\x0e\x12\x03]\x04\x1d\x1a\x12\x20Field\x20type\x20enum.\n\n\x0e\n\
    \x07\x04\x01\x04\0\x02\x0e\x01\x12\x03]\x04\r\n\x0e\n\x07\x04\x01\x04\0\
    \x02\x0e\x02\x12\x03]\x1a\x1c\n%\n\x06\x04\x01\x04\0\x02\x0f\x12\x03_\
    \x04\x1d\x1a\x16\x20Field\x20type\x20sfixed32.\n\n\x0e\n\x07\x04\x01\x04\
    \0\x02\x0f\x01\x12\x03_\x04\x11\n\x0e\n\x07\x04\x01\x04\0\x02\x0f\x02\
    \x12\x03_\x1a\x1c\n%\n\x06\x04\x01\x04\0\x02\x10\x12\x03a\x04\x1d\x1a\
    \x16\x20Field\x20type\x20sfixed64.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x10\
    \x01\x12\x03a\x04\x11\n\x0e\n\x07\x04\x01\x04\0\x02\x10\x02\x12\x03a\x1a\
    \x1c\n#\n\x06\x04\x01\x04\0\x02\x11\x12\x03c\x04\x1d\x1a\x14\x20Field\
    \x20type\x20sint32.\n\n\x0e\n\x07\x04\x01\x04\0\x02\x11\x01\x12\x03c\x04\
    \x0f\n\x0e\n\x07\x04\x01\x04\0\x02\x11\x02\x12\x03c\x1a\x1c\n#\n\x06\x04\
    \x01\x04\0\x02\x12\x12\x03e\x04\x1d\x1a\x14\x20Field\x20type\x20sint64.\
    \n\n\x0e\n\x07\x04\x01\x04\0\x02\x12\x01\x12\x03e\x04\x0f\n\x0e\n\x07\
    \x04\x01\x04\0\x02\x12\x02\x12\x03e\x1a\x1c\nC\n\x04\x04\x01\x04\x01\x12\
    \x04i\x02r\x03\x1a5\x20Whether\x20a\x20field\x20is\x20optional,\x20requi\
    red,\x20or\x20repeated.\n\n\x0c\n\x05\x04\x01\x04\x01\x01\x12\x03i\x07\
    \x12\n5\n\x06\x04\x01\x04\x01\x02\0\x12\x03k\x04\x1c\x1a&\x20For\x20fiel\
    ds\x20with\x20unknown\x20cardinality.\n\n\x0e\n\x07\x04\x01\x04\x01\x02\
    \0\x01\x12\x03k\x04\x17\n\x0e\n\x07\x04\x01\x04\x01\x02\0\x02\x12\x03k\
    \x1a\x1b\n%\n\x06\x04\x01\x04\x01\x02\x01\x12\x03m\x04\x1d\x1a\x16\x20Fo\
    r\x20optional\x20fields.\n\n\x0e\n\x07\x04\x01\x04\x01\x02\x01\x01\x12\
    \x03m\x04\x18\n\x0e\n\x07\x04\x01\x04\x01\x02\x01\x02\x12\x03m\x1b\x1c\n\
    9\n\x06\x04\x01\x04\x01\x02\x02\x12\x03o\x04\x1d\x1a*\x20For\x20required\
    \x20fields.\x20Proto2\x20syntax\x20only.\n\n\x0e\n\x07\x04\x01\x04\x01\
    \x02\x02\x01\x12\x03o\x04\x18\n\x0e\n\x07\x04\x01\x04\x01\x02\x02\x02\
    \x12\x03o\x1b\x1c\n%\n\x06\x04\x01\x04\x01\x02\x03\x12\x03q\x04\x1d\x1a\
    \x16\x20For\x20repeated\x20fields.\n\n\x0e\n\x07\x04\x01\x04\x01\x02\x03\
    \x01\x12\x03q\x04\x18\n\x0e\n\x07\x04\x01\x04\x01\x02\x03\x02\x12\x03q\
    \x1b\x1c\n\x1e\n\x04\x04\x01\x02\0\x12\x03u\x02\x10\x1a\x11\x20The\x20fi\
    eld\x20type.\n\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03u\x02\x06\n\x0c\n\
    \x05\x04\x01\x02\0\x01\x12\x03u\x07\x0b\n\x0c\n\x05\x04\x01\x02\0\x03\
    \x12\x03u\x0e\x0f\n%\n\x04\x04\x01\x02\x01\x12\x03w\x02\x1e\x1a\x18\x20T\
    he\x20field\x20cardinality.\n\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03w\
    \x02\r\n\x0c\n\x05\x04\x01\x02\x01\x01\x12\x03w\x0e\x19\n\x0c\n\x05\x04\
    \x01\x02\x01\x03\x12\x03w\x1c\x1d\n\x20\n\x04\x04\x01\x02\x02\x12\x03y\
    \x02\x13\x1a\x13\x20The\x20field\x20number.\n\n\x0c\n\x05\x04\x01\x02\
    \x02\x05\x12\x03y\x02\x07\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03y\x08\
    \x0e\n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03y\x11\x12\n\x1e\n\x04\x04\
    \x01\x02\x03\x12\x03{\x02\x12\x1a\x11\x20The\x20field\x20name.\n\n\x0c\n\
    \x05\x04\x01\x02\x03\x05\x12\x03{\x02\x08\n\x0c\n\x05\x04\x01\x02\x03\
    \x01\x12\x03{\t\r\n\x0c\n\x05\x04\x01\x02\x03\x03\x12\x03{\x10\x11\n\x96\
    \x01\n\x04\x04\x01\x02\x04\x12\x03~\x02\x16\x1a\x88\x01\x20The\x20field\
    \x20type\x20URL,\x20without\x20the\x20scheme,\x20for\x20message\x20or\
    \x20enumeration\n\x20types.\x20Example:\x20`\"type.googleapis.com/google\
    .protobuf.Timestamp\"`.\n\n\x0c\n\x05\x04\x01\x02\x04\x05\x12\x03~\x02\
    \x08\n\x0c\n\x05\x04\x01\x02\x04\x01\x12\x03~\t\x11\n\x0c\n\x05\x04\x01\
    \x02\x04\x03\x12\x03~\x14\x15\n\xa5\x01\n\x04\x04\x01\x02\x05\x12\x04\
    \x81\x01\x02\x18\x1a\x96\x01\x20The\x20index\x20of\x20the\x20field\x20ty\
    pe\x20in\x20`Type.oneofs`,\x20for\x20message\x20or\x20enumeration\n\x20t\
    ypes.\x20The\x20first\x20type\x20has\x20index\x201;\x20zero\x20means\x20\
    the\x20type\x20is\x20not\x20in\x20the\x20list.\n\n\r\n\x05\x04\x01\x02\
    \x05\x05\x12\x04\x81\x01\x02\x07\n\r\n\x05\x04\x01\x02\x05\x01\x12\x04\
    \x81\x01\x08\x13\n\r\n\x05\x04\x01\x02\x05\x03\x12\x04\x81\x01\x16\x17\n\
    F\n\x04\x04\x01\x02\x06\x12\x04\x83\x01\x02\x12\x1a8\x20Whether\x20to\
    \x20use\x20alternative\x20packed\x20wire\x20representation.\n\n\r\n\x05\
    \x04\x01\x02\x06\x05\x12\x04\x83\x01\x02\x06\n\r\n\x05\x04\x01\x02\x06\
    \x01\x12\x04\x83\x01\x07\r\n\r\n\x05\x04\x01\x02\x06\x03\x12\x04\x83\x01\
    \x10\x11\n,\n\x04\x04\x01\x02\x07\x12\x04\x85\x01\x02\x1e\x1a\x1e\x20The\
    \x20protocol\x20buffer\x20options.\n\n\r\n\x05\x04\x01\x02\x07\x04\x12\
    \x04\x85\x01\x02\n\n\r\n\x05\x04\x01\x02\x07\x06\x12\x04\x85\x01\x0b\x11\
    \n\r\n\x05\x04\x01\x02\x07\x01\x12\x04\x85\x01\x12\x19\n\r\n\x05\x04\x01\
    \x02\x07\x03\x12\x04\x85\x01\x1c\x1d\n$\n\x04\x04\x01\x02\x08\x12\x04\
    \x87\x01\x02\x18\x1a\x16\x20The\x20field\x20JSON\x20name.\n\n\r\n\x05\
    \x04\x01\x02\x08\x05\x12\x04\x87\x01\x02\x08\n\r\n\x05\x04\x01\x02\x08\
    \x01\x12\x04\x87\x01\t\x12\n\r\n\x05\x04\x01\x02\x08\x03\x12\x04\x87\x01\
    \x15\x17\nX\n\x04\x04\x01\x02\t\x12\x04\x89\x01\x02\x1c\x1aJ\x20The\x20s\
    tring\x20value\x20of\x20the\x20default\x20value\x20of\x20this\x20field.\
    \x20Proto2\x20syntax\x20only.\n\n\r\n\x05\x04\x01\x02\t\x05\x12\x04\x89\
    \x01\x02\x08\n\r\n\x05\x04\x01\x02\t\x01\x12\x04\x89\x01\t\x16\n\r\n\x05\
    \x04\x01\x02\t\x03\x12\x04\x89\x01\x19\x1b\n%\n\x02\x04\x02\x12\x06\x8d\
    \x01\0\x98\x01\x01\x1a\x17\x20Enum\x20type\x20definition.\n\n\x0b\n\x03\
    \x04\x02\x01\x12\x04\x8d\x01\x08\x0c\n\x1f\n\x04\x04\x02\x02\0\x12\x04\
    \x8f\x01\x02\x12\x1a\x11\x20Enum\x20type\x20name.\n\n\r\n\x05\x04\x02\
    \x02\0\x05\x12\x04\x8f\x01\x02\x08\n\r\n\x05\x04\x02\x02\0\x01\x12\x04\
    \x8f\x01\t\r\n\r\n\x05\x04\x02\x02\0\x03\x12\x04\x8f\x01\x10\x11\n'\n\
    \x04\x04\x02\x02\x01\x12\x04\x91\x01\x02#\x1a\x19\x20Enum\x20value\x20de\
    finitions.\n\n\r\n\x05\x04\x02\x02\x01\x04\x12\x04\x91\x01\x02\n\n\r\n\
    \x05\x04\x02\x02\x01\x06\x12\x04\x91\x01\x0b\x14\n\r\n\x05\x04\x02\x02\
    \x01\x01\x12\x04\x91\x01\x15\x1e\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\
    \x91\x01!\"\n(\n\x04\x04\x02\x02\x02\x12\x04\x93\x01\x02\x1e\x1a\x1a\x20\
    Protocol\x20buffer\x20options.\n\n\r\n\x05\x04\x02\x02\x02\x04\x12\x04\
    \x93\x01\x02\n\n\r\n\x05\x04\x02\x02\x02\x06\x12\x04\x93\x01\x0b\x11\n\r\
    \n\x05\x04\x02\x02\x02\x01\x12\x04\x93\x01\x12\x19\n\r\n\x05\x04\x02\x02\
    \x02\x03\x12\x04\x93\x01\x1c\x1d\n#\n\x04\x04\x02\x02\x03\x12\x04\x95\
    \x01\x02#\x1a\x15\x20The\x20source\x20context.\n\n\r\n\x05\x04\x02\x02\
    \x03\x06\x12\x04\x95\x01\x02\x0f\n\r\n\x05\x04\x02\x02\x03\x01\x12\x04\
    \x95\x01\x10\x1e\n\r\n\x05\x04\x02\x02\x03\x03\x12\x04\x95\x01!\"\n\"\n\
    \x04\x04\x02\x02\x04\x12\x04\x97\x01\x02\x14\x1a\x14\x20The\x20source\
    \x20syntax.\n\n\r\n\x05\x04\x02\x02\x04\x06\x12\x04\x97\x01\x02\x08\n\r\
    \n\x05\x04\x02\x02\x04\x01\x12\x04\x97\x01\t\x0f\n\r\n\x05\x04\x02\x02\
    \x04\x03\x12\x04\x97\x01\x12\x13\n&\n\x02\x04\x03\x12\x06\x9b\x01\0\xa2\
    \x01\x01\x1a\x18\x20Enum\x20value\x20definition.\n\n\x0b\n\x03\x04\x03\
    \x01\x12\x04\x9b\x01\x08\x11\n\x20\n\x04\x04\x03\x02\0\x12\x04\x9d\x01\
    \x02\x12\x1a\x12\x20Enum\x20value\x20name.\n\n\r\n\x05\x04\x03\x02\0\x05\
    \x12\x04\x9d\x01\x02\x08\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\x9d\x01\t\r\
    \n\r\n\x05\x04\x03\x02\0\x03\x12\x04\x9d\x01\x10\x11\n\"\n\x04\x04\x03\
    \x02\x01\x12\x04\x9f\x01\x02\x13\x1a\x14\x20Enum\x20value\x20number.\n\n\
    \r\n\x05\x04\x03\x02\x01\x05\x12\x04\x9f\x01\x02\x07\n\r\n\x05\x04\x03\
    \x02\x01\x01\x12\x04\x9f\x01\x08\x0e\n\r\n\x05\x04\x03\x02\x01\x03\x12\
    \x04\x9f\x01\x11\x12\n(\n\x04\x04\x03\x02\x02\x12\x04\xa1\x01\x02\x1e\
    \x1a\x1a\x20Protocol\x20buffer\x20options.\n\n\r\n\x05\x04\x03\x02\x02\
    \x04\x12\x04\xa1\x01\x02\n\n\r\n\x05\x04\x03\x02\x02\x06\x12\x04\xa1\x01\
    \x0b\x11\n\r\n\x05\x04\x03\x02\x02\x01\x12\x04\xa1\x01\x12\x19\n\r\n\x05\
    \x04\x03\x02\x02\x03\x12\x04\xa1\x01\x1c\x1d\ng\n\x02\x04\x04\x12\x06\
    \xa6\x01\0\xab\x01\x01\x1aY\x20A\x20protocol\x20buffer\x20option,\x20whi\
    ch\x20can\x20be\x20attached\x20to\x20a\x20message,\x20field,\n\x20enumer\
    ation,\x20etc.\n\n\x0b\n\x03\x04\x04\x01\x12\x04\xa6\x01\x08\x0e\nA\n\
    \x04\x04\x04\x02\0\x12\x04\xa8\x01\x02\x12\x1a3\x20The\x20option's\x20na\
    me.\x20For\x20example,\x20`\"java_package\"`.\n\n\r\n\x05\x04\x04\x02\0\
    \x05\x12\x04\xa8\x01\x02\x08\n\r\n\x05\x04\x04\x02\0\x01\x12\x04\xa8\x01\
    \t\r\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\xa8\x01\x10\x11\nI\n\x04\x04\
    \x04\x02\x01\x12\x04\xaa\x01\x02\x10\x1a;\x20The\x20option's\x20value.\
    \x20For\x20example,\x20`\"com.google.protobuf\"`.\n\n\r\n\x05\x04\x04\
    \x02\x01\x06\x12\x04\xaa\x01\x02\x05\n\r\n\x05\x04\x04\x02\x01\x01\x12\
    \x04\xaa\x01\x06\x0b\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\xaa\x01\x0e\
    \x0f\nI\n\x02\x05\0\x12\x06\xae\x01\0\xb3\x01\x01\x1a;\x20The\x20syntax\
    \x20in\x20which\x20a\x20protocol\x20buffer\x20element\x20is\x20defined.\
    \n\n\x0b\n\x03\x05\0\x01\x12\x04\xae\x01\x05\x0b\n\x20\n\x04\x05\0\x02\0\
    \x12\x04\xb0\x01\x02\x14\x1a\x12\x20Syntax\x20`proto2`.\n\n\r\n\x05\x05\
    \0\x02\0\x01\x12\x04\xb0\x01\x02\x0f\n\r\n\x05\x05\0\x02\0\x02\x12\x04\
    \xb0\x01\x12\x13\n\x20\n\x04\x05\0\x02\x01\x12\x04\xb2\x01\x02\x14\x1a\
    \x12\x20Syntax\x20`proto3`.\n\n\r\n\x05\x05\0\x02\x01\x01\x12\x04\xb2\
    \x01\x02\x0f\n\r\n\x05\x05\0\x02\x01\x02\x12\x04\xb2\x01\x12\x13b\x06pro\
    to3\
";

static file_descriptor_proto_lazy: crate::rt::Lazy<crate::descriptor::FileDescriptorProto> = crate::rt::Lazy::INIT;

fn parse_descriptor_proto() -> crate::descriptor::FileDescriptorProto {
    crate::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

/// `FileDescriptorProto` object which was a source for this generated file
pub fn file_descriptor_proto() -> &'static crate::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
